var $4tN2K$reactstatelyutils = require("@react-stately/utils");
var $4tN2K$internationalizedmessage = require("@internationalized/message");
var $4tN2K$internationalizednumber = require("@internationalized/number");
var $4tN2K$react = require("react");
var $4tN2K$reactstatelyslider = require("@react-stately/slider");

function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}
function $parcel$exportWildcard(dest, source) {
  Object.keys(source).forEach(function(key) {
    if (key === 'default' || key === '__esModule' || dest.hasOwnProperty(key)) {
      return;
    }

    Object.defineProperty(dest, key, {
      enumerable: true,
      get: function get() {
        return source[key];
      }
    });
  });

  return dest;
}
function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}

$parcel$export(module.exports, "parseColor", () => $83fe1a57d631223b$export$6e865ea70d7724f);

var $c0b600cf8eafdee9$exports = {};
var $b044e7150534af04$exports = {};
$b044e7150534af04$exports = JSON.parse("{\"alpha\":\"ألفا\",\"blue\":\"أزرق\",\"brightness\":\"السطوع\",\"green\":\"أخضر\",\"hue\":\"درجة اللون\",\"lightness\":\"الإضاءة\",\"red\":\"أحمر\",\"saturation\":\"التشبع\"}");


var $c8bf89547a4a9b3f$exports = {};
$c8bf89547a4a9b3f$exports = JSON.parse("{\"alpha\":\"Алфа\",\"blue\":\"Синьо\",\"brightness\":\"Яркост\",\"green\":\"Зелено\",\"hue\":\"Оттенък\",\"lightness\":\"Лекота\",\"red\":\"Червено\",\"saturation\":\"Наситеност\"}");


var $8365d8dfc7e4c985$exports = {};
$8365d8dfc7e4c985$exports = JSON.parse("{\"alpha\":\"Alfa\",\"blue\":\"Modrá\",\"brightness\":\"Jas\",\"green\":\"Zelená\",\"hue\":\"Odstín\",\"lightness\":\"Světlost\",\"red\":\"Červená\",\"saturation\":\"Sytost\"}");


var $8d95eeaa73699e56$exports = {};
$8d95eeaa73699e56$exports = JSON.parse("{\"alpha\":\"Alfa\",\"blue\":\"Blå\",\"brightness\":\"Lysstyrke\",\"green\":\"Grøn\",\"hue\":\"Tone\",\"lightness\":\"Lyshed\",\"red\":\"Rød\",\"saturation\":\"Farvemætning\"}");


var $2dbbd166053d6d10$exports = {};
$2dbbd166053d6d10$exports = JSON.parse("{\"alpha\":\"Alpha\",\"blue\":\"Blau\",\"brightness\":\"Helligkeit\",\"green\":\"Grün\",\"hue\":\"Farbton\",\"lightness\":\"Leuchtkraft\",\"red\":\"Rot\",\"saturation\":\"Sättigung\"}");


var $1fcbdf9eaf6cc074$exports = {};
$1fcbdf9eaf6cc074$exports = JSON.parse("{\"alpha\":\"Άλφα\",\"blue\":\"Μπλε\",\"brightness\":\"Φωτεινότητα\",\"green\":\"Πράσινο\",\"hue\":\"Τόνος\",\"lightness\":\"Φωτεινότητα\",\"red\":\"Κόκκινο\",\"saturation\":\"Κορεσμός\"}");


var $42d54be461715959$exports = {};
$42d54be461715959$exports = JSON.parse("{\"hue\":\"Hue\",\"saturation\":\"Saturation\",\"lightness\":\"Lightness\",\"brightness\":\"Brightness\",\"red\":\"Red\",\"green\":\"Green\",\"blue\":\"Blue\",\"alpha\":\"Alpha\"}");


var $911646bd5662c33d$exports = {};
$911646bd5662c33d$exports = JSON.parse("{\"alpha\":\"Alpha\",\"blue\":\"Azul\",\"brightness\":\"Brillo\",\"green\":\"Verde\",\"hue\":\"Tono\",\"lightness\":\"Luminosidad\",\"red\":\"Rojo\",\"saturation\":\"Saturación\"}");


var $6e8998796901e680$exports = {};
$6e8998796901e680$exports = JSON.parse("{\"alpha\":\"Alfa\",\"blue\":\"Sinine\",\"brightness\":\"Heledus\",\"green\":\"Roheline\",\"hue\":\"Värv\",\"lightness\":\"Valgus\",\"red\":\"Punane\",\"saturation\":\"Küllastus\"}");


var $4503b4001036be6d$exports = {};
$4503b4001036be6d$exports = JSON.parse("{\"alpha\":\"Alpha\",\"blue\":\"Sininen\",\"brightness\":\"Kirkkaus\",\"green\":\"Vihreä\",\"hue\":\"Sävy\",\"lightness\":\"Valomäärä\",\"red\":\"Punainen\",\"saturation\":\"Värikylläisyys\"}");


var $721e7016769a7a7f$exports = {};
$721e7016769a7a7f$exports = JSON.parse("{\"alpha\":\"Alpha\",\"blue\":\"Bleu\",\"brightness\":\"Luminosité\",\"green\":\"Vert\",\"hue\":\"Teinte\",\"lightness\":\"Luminosité\",\"red\":\"Rouge\",\"saturation\":\"Saturation\"}");


var $dcc290e5792f9bab$exports = {};
$dcc290e5792f9bab$exports = JSON.parse("{\"alpha\":\"אלפא\",\"blue\":\"כחול\",\"brightness\":\"בהירות\",\"green\":\"ירוק\",\"hue\":\"גוון\",\"lightness\":\"כמות אור\",\"red\":\"אדום\",\"saturation\":\"רוויה\"}");


var $d93d5aebdd12334c$exports = {};
$d93d5aebdd12334c$exports = JSON.parse("{\"alpha\":\"Alfa\",\"blue\":\"Plava\",\"brightness\":\"Svjetlina\",\"green\":\"Zelena\",\"hue\":\"Nijansa\",\"lightness\":\"Osvijetljenost\",\"red\":\"Crvena\",\"saturation\":\"Zasićenost\"}");


var $a3749e0ee87dbebc$exports = {};
$a3749e0ee87dbebc$exports = JSON.parse("{\"alpha\":\"Alfa\",\"blue\":\"Kék\",\"brightness\":\"Fényesség\",\"green\":\"Zöld\",\"hue\":\"Színárnyalat\",\"lightness\":\"Világosság\",\"red\":\"Piros\",\"saturation\":\"Telítettség\"}");


var $2fdb931b6c9652b9$exports = {};
$2fdb931b6c9652b9$exports = JSON.parse("{\"alpha\":\"Alfa\",\"blue\":\"Blu\",\"brightness\":\"Luminosità\",\"green\":\"Verde\",\"hue\":\"Tonalità\",\"lightness\":\"Luminosità\",\"red\":\"Rosso\",\"saturation\":\"Saturazione\"}");


var $219c839b59015b4f$exports = {};
$219c839b59015b4f$exports = JSON.parse("{\"alpha\":\"アルファ\",\"blue\":\"青\",\"brightness\":\"明るさ\",\"green\":\"緑\",\"hue\":\"色相\",\"lightness\":\"明度\",\"red\":\"赤\",\"saturation\":\"彩度\"}");


var $b7f67f414086d976$exports = {};
$b7f67f414086d976$exports = JSON.parse("{\"alpha\":\"알파\",\"blue\":\"파랑\",\"brightness\":\"명도\",\"green\":\"초록\",\"hue\":\"색조\",\"lightness\":\"밝기\",\"red\":\"빨강\",\"saturation\":\"채도\"}");


var $f27b2ac7d517417c$exports = {};
$f27b2ac7d517417c$exports = JSON.parse("{\"alpha\":\"Alfa\",\"blue\":\"Mėlyna\",\"brightness\":\"Ryškumas\",\"green\":\"Žalia\",\"hue\":\"Atspalvis\",\"lightness\":\"Šviesumas\",\"red\":\"Raudona\",\"saturation\":\"Įsotinimas\"}");


var $e92168db3cbe2797$exports = {};
$e92168db3cbe2797$exports = JSON.parse("{\"alpha\":\"Alfa\",\"blue\":\"Zila\",\"brightness\":\"Spilgtums\",\"green\":\"Zaļa\",\"hue\":\"Nokrāsa\",\"lightness\":\"Gaišums\",\"red\":\"Sarkana\",\"saturation\":\"Piesātinājums\"}");


var $44b012e02982e825$exports = {};
$44b012e02982e825$exports = JSON.parse("{\"alpha\":\"Alfa\",\"blue\":\"Blå\",\"brightness\":\"Lysstyrke\",\"green\":\"Grønn\",\"hue\":\"Fargetone\",\"lightness\":\"Lyshet\",\"red\":\"Rød\",\"saturation\":\"Metning\"}");


var $64fbd91459613d8b$exports = {};
$64fbd91459613d8b$exports = JSON.parse("{\"alpha\":\"Alfa\",\"blue\":\"Blauw\",\"brightness\":\"Helderheid\",\"green\":\"Groen\",\"hue\":\"Kleurtoon\",\"lightness\":\"Lichtsterkte\",\"red\":\"Rood\",\"saturation\":\"Verzadiging\"}");


var $83fabdc4e0df6af9$exports = {};
$83fabdc4e0df6af9$exports = JSON.parse("{\"alpha\":\"Alfa\",\"blue\":\"Niebieski\",\"brightness\":\"Jasność\",\"green\":\"Zielony\",\"hue\":\"Odcień\",\"lightness\":\"Jaskrawość\",\"red\":\"Czerwony\",\"saturation\":\"Nasycenie\"}");


var $30b915257fa66ccf$exports = {};
$30b915257fa66ccf$exports = JSON.parse("{\"alpha\":\"Alfa\",\"blue\":\"Azul\",\"brightness\":\"Brilho\",\"green\":\"Verde\",\"hue\":\"Matiz\",\"lightness\":\"Luminosidade\",\"red\":\"Vermelho\",\"saturation\":\"Saturação\"}");


var $ce75e45ccbc92491$exports = {};
$ce75e45ccbc92491$exports = JSON.parse("{\"alpha\":\"Alfa\",\"blue\":\"Azul\",\"brightness\":\"Luminosidade\",\"green\":\"Verde\",\"hue\":\"Tonalidade\",\"lightness\":\"Claridade\",\"red\":\"Vermelho\",\"saturation\":\"Saturação\"}");


var $225440ee53a1fecd$exports = {};
$225440ee53a1fecd$exports = JSON.parse("{\"alpha\":\"Alfa\",\"blue\":\"Albastru\",\"brightness\":\"Luminozitate\",\"green\":\"Verde\",\"hue\":\"Nuanță\",\"lightness\":\"Luminozitate\",\"red\":\"Roșu\",\"saturation\":\"Saturație\"}");


var $cbc60c1dd4e689ff$exports = {};
$cbc60c1dd4e689ff$exports = JSON.parse("{\"alpha\":\"Альфа\",\"blue\":\"Синий\",\"brightness\":\"Яркость\",\"green\":\"Зеленый\",\"hue\":\"Оттенок\",\"lightness\":\"Освещенность\",\"red\":\"Красный\",\"saturation\":\"Насыщенность\"}");


var $8612080ab5efe0cf$exports = {};
$8612080ab5efe0cf$exports = JSON.parse("{\"alpha\":\"Alfa\",\"blue\":\"Modrá\",\"brightness\":\"Jas\",\"green\":\"Zelená\",\"hue\":\"Odtieň\",\"lightness\":\"Svetlosť\",\"red\":\"Červená\",\"saturation\":\"Sýtosť\"}");


var $99cc034ddd2b7d86$exports = {};
$99cc034ddd2b7d86$exports = JSON.parse("{\"alpha\":\"Alfa\",\"blue\":\"Modra\",\"brightness\":\"Svetlost\",\"green\":\"Zelena\",\"hue\":\"Barva\",\"lightness\":\"Lahkost\",\"red\":\"Rdeča\",\"saturation\":\"Nasičenost\"}");


var $dc671800d61be83e$exports = {};
$dc671800d61be83e$exports = JSON.parse("{\"alpha\":\"Alfa\",\"blue\":\"Plava\",\"brightness\":\"Osvetljenost\",\"green\":\"Zelena\",\"hue\":\"Nijansa\",\"lightness\":\"Osvetljenje\",\"red\":\"Crvena\",\"saturation\":\"Zasićenje\"}");


var $0f4790e2f696e63f$exports = {};
$0f4790e2f696e63f$exports = JSON.parse("{\"alpha\":\"Alfa\",\"blue\":\"Blått\",\"brightness\":\"Ljusstyrka\",\"green\":\"Grönt\",\"hue\":\"Nyans\",\"lightness\":\"Ljushet\",\"red\":\"Rött\",\"saturation\":\"Mättnad\"}");


var $deb5f82eb1998a3c$exports = {};
$deb5f82eb1998a3c$exports = JSON.parse("{\"alpha\":\"Alfa\",\"blue\":\"Mavi\",\"brightness\":\"Parlaklık\",\"green\":\"Yeşil\",\"hue\":\"Ton\",\"lightness\":\"Canlılık\",\"red\":\"Kırmızı\",\"saturation\":\"Doygunluk\"}");


var $99530e1782ca02cc$exports = {};
$99530e1782ca02cc$exports = JSON.parse("{\"alpha\":\"Альфа\",\"blue\":\"Синій\",\"brightness\":\"Яскравість\",\"green\":\"Зелений\",\"hue\":\"Тон\",\"lightness\":\"Освітленість\",\"red\":\"Червоний\",\"saturation\":\"Насиченість\"}");


var $a6e8f490b423d65e$exports = {};
$a6e8f490b423d65e$exports = JSON.parse("{\"alpha\":\"Alpha\",\"blue\":\"蓝色\",\"brightness\":\"亮度\",\"green\":\"绿色\",\"hue\":\"色相\",\"lightness\":\"明亮度\",\"red\":\"红色\",\"saturation\":\"饱和度\"}");


var $eba443dcc93cab9a$exports = {};
$eba443dcc93cab9a$exports = JSON.parse("{\"alpha\":\"Alpha\",\"blue\":\"藍色\",\"brightness\":\"亮度\",\"green\":\"綠色\",\"hue\":\"色相\",\"lightness\":\"明亮\",\"red\":\"紅色\",\"saturation\":\"飽和度\"}");


$c0b600cf8eafdee9$exports = {
    "ar-AE": $b044e7150534af04$exports,
    "bg-BG": $c8bf89547a4a9b3f$exports,
    "cs-CZ": $8365d8dfc7e4c985$exports,
    "da-DK": $8d95eeaa73699e56$exports,
    "de-DE": $2dbbd166053d6d10$exports,
    "el-GR": $1fcbdf9eaf6cc074$exports,
    "en-US": $42d54be461715959$exports,
    "es-ES": $911646bd5662c33d$exports,
    "et-EE": $6e8998796901e680$exports,
    "fi-FI": $4503b4001036be6d$exports,
    "fr-FR": $721e7016769a7a7f$exports,
    "he-IL": $dcc290e5792f9bab$exports,
    "hr-HR": $d93d5aebdd12334c$exports,
    "hu-HU": $a3749e0ee87dbebc$exports,
    "it-IT": $2fdb931b6c9652b9$exports,
    "ja-JP": $219c839b59015b4f$exports,
    "ko-KR": $b7f67f414086d976$exports,
    "lt-LT": $f27b2ac7d517417c$exports,
    "lv-LV": $e92168db3cbe2797$exports,
    "nb-NO": $44b012e02982e825$exports,
    "nl-NL": $64fbd91459613d8b$exports,
    "pl-PL": $83fabdc4e0df6af9$exports,
    "pt-BR": $30b915257fa66ccf$exports,
    "pt-PT": $ce75e45ccbc92491$exports,
    "ro-RO": $225440ee53a1fecd$exports,
    "ru-RU": $cbc60c1dd4e689ff$exports,
    "sk-SK": $8612080ab5efe0cf$exports,
    "sl-SI": $99cc034ddd2b7d86$exports,
    "sr-SP": $dc671800d61be83e$exports,
    "sv-SE": $0f4790e2f696e63f$exports,
    "tr-TR": $deb5f82eb1998a3c$exports,
    "uk-UA": $99530e1782ca02cc$exports,
    "zh-CN": $a6e8f490b423d65e$exports,
    "zh-TW": $eba443dcc93cab9a$exports
};




const $83fe1a57d631223b$var$messages = new $4tN2K$internationalizedmessage.MessageDictionary((/*@__PURE__*/$parcel$interopDefault($c0b600cf8eafdee9$exports)));
function $83fe1a57d631223b$export$6e865ea70d7724f(value) {
    let res = $83fe1a57d631223b$var$RGBColor.parse(value) || $83fe1a57d631223b$var$HSBColor.parse(value) || $83fe1a57d631223b$var$HSLColor.parse(value);
    if (res) return res;
    throw new Error('Invalid color value: ' + value);
}
function $83fe1a57d631223b$export$4cde5df63f53f473(v) {
    if (typeof v === 'string') return $83fe1a57d631223b$export$6e865ea70d7724f(v);
    else return v;
}
class $83fe1a57d631223b$var$Color {
    toHexInt() {
        return this.toFormat('rgb').toHexInt();
    }
    getChannelValue(channel) {
        if (channel in this) return this[channel];
        throw new Error('Unsupported color channel: ' + channel);
    }
    withChannelValue(channel, value) {
        if (channel in this) {
            let x = this.clone();
            x[channel] = value;
            return x;
        }
        throw new Error('Unsupported color channel: ' + channel);
    }
    getChannelName(channel, locale) {
        return $83fe1a57d631223b$var$messages.getStringForLocale(channel, locale);
    }
    getColorSpaceAxes(xyChannels) {
        let { xChannel: xChannel , yChannel: yChannel  } = xyChannels;
        let xCh = xChannel || this.getColorChannels().find((c)=>c !== yChannel
        );
        let yCh = yChannel || this.getColorChannels().find((c)=>c !== xCh
        );
        let zCh = this.getColorChannels().find((c)=>c !== xCh && c !== yCh
        );
        return {
            xChannel: xCh,
            yChannel: yCh,
            zChannel: zCh
        };
    }
}
const $83fe1a57d631223b$var$HEX_REGEX = /^#(?:([0-9a-f]{3})|([0-9a-f]{6}))$/i;
// X = <negative/positive number with/without decimal places>
// before/after a comma, 0 or more whitespaces are allowed
// - rgb(X, X, X)
// - rgba(X, X, X, X)
const $83fe1a57d631223b$var$RGB_REGEX = /rgb\(([-+]?\d+(?:.\d+)?\s*,\s*[-+]?\d+(?:.\d+)?\s*,\s*[-+]?\d+(?:.\d+)?)\)|rgba\(([-+]?\d+(?:.\d+)?\s*,\s*[-+]?\d+(?:.\d+)?\s*,\s*[-+]?\d+(?:.\d+)?\s*,\s*[-+]?\d(.\d+)?)\)/;
class $83fe1a57d631223b$var$RGBColor extends $83fe1a57d631223b$var$Color {
    static parse(value) {
        let m;
        if (m = value.match($83fe1a57d631223b$var$HEX_REGEX)) {
            if (m[1]) {
                let r = parseInt(m[1][0] + m[1][0], 16);
                let g = parseInt(m[1][1] + m[1][1], 16);
                let b = parseInt(m[1][2] + m[1][2], 16);
                return new $83fe1a57d631223b$var$RGBColor(r, g, b, 1);
            } else if (m[2]) {
                let r = parseInt(m[2][0] + m[2][1], 16);
                let g = parseInt(m[2][2] + m[2][3], 16);
                let b = parseInt(m[2][4] + m[2][5], 16);
                return new $83fe1a57d631223b$var$RGBColor(r, g, b, 1);
            }
        }
        if (m = value.match($83fe1a57d631223b$var$RGB_REGEX)) {
            var ref;
            const [r, g, b, a] = ((ref = m[1]) !== null && ref !== void 0 ? ref : m[2]).split(',').map((n)=>Number(n.trim())
            );
            return new $83fe1a57d631223b$var$RGBColor($4tN2K$reactstatelyutils.clamp(r, 0, 255), $4tN2K$reactstatelyutils.clamp(g, 0, 255), $4tN2K$reactstatelyutils.clamp(b, 0, 255), $4tN2K$reactstatelyutils.clamp(a !== null && a !== void 0 ? a : 1, 0, 1));
        }
    }
    toString(format) {
        switch(format){
            case 'hex':
                return '#' + (this.red.toString(16).padStart(2, '0') + this.green.toString(16).padStart(2, '0') + this.blue.toString(16).padStart(2, '0')).toUpperCase();
            case 'hexa':
                return '#' + (this.red.toString(16).padStart(2, '0') + this.green.toString(16).padStart(2, '0') + this.blue.toString(16).padStart(2, '0') + Math.round(this.alpha * 255).toString(16).padStart(2, '0')).toUpperCase();
            case 'rgb':
                return `rgb(${this.red}, ${this.green}, ${this.blue})`;
            case 'css':
            case 'rgba':
                return `rgba(${this.red}, ${this.green}, ${this.blue}, ${this.alpha})`;
            default:
                return this.toFormat(format).toString(format);
        }
    }
    toFormat(format) {
        switch(format){
            case 'hex':
            case 'hexa':
            case 'rgb':
            case 'rgba':
                return this;
            case 'hsb':
            case 'hsba':
                return this.toHSB();
            case 'hsl':
            case 'hsla':
                return this.toHSL();
            default:
                throw new Error('Unsupported color conversion: rgb -> ' + format);
        }
    }
    toHexInt() {
        return this.red << 16 | this.green << 8 | this.blue;
    }
    /**
   * Converts an RGB color value to HSB.
   * Conversion formula adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#From_RGB.
   * @returns An HSBColor object.
   */ toHSB() {
        const red = this.red / 255;
        const green = this.green / 255;
        const blue = this.blue / 255;
        const min = Math.min(red, green, blue);
        const brightness = Math.max(red, green, blue);
        const chroma = brightness - min;
        const saturation = brightness === 0 ? 0 : chroma / brightness;
        let hue = 0; // achromatic
        if (chroma !== 0) {
            switch(brightness){
                case red:
                    hue = (green - blue) / chroma + (green < blue ? 6 : 0);
                    break;
                case green:
                    hue = (blue - red) / chroma + 2;
                    break;
                case blue:
                    hue = (red - green) / chroma + 4;
                    break;
            }
            hue /= 6;
        }
        return new $83fe1a57d631223b$var$HSBColor($4tN2K$reactstatelyutils.toFixedNumber(hue * 360, 2), $4tN2K$reactstatelyutils.toFixedNumber(saturation * 100, 2), $4tN2K$reactstatelyutils.toFixedNumber(brightness * 100, 2), this.alpha);
    }
    /**
   * Converts an RGB color value to HSL.
   * Conversion formula adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#From_RGB.
   * @returns An HSLColor object.
   */ toHSL() {
        const red = this.red / 255;
        const green = this.green / 255;
        const blue = this.blue / 255;
        const min = Math.min(red, green, blue);
        const max = Math.max(red, green, blue);
        const lightness = (max + min) / 2;
        const chroma = max - min;
        let hue;
        let saturation;
        if (chroma === 0) hue = saturation = 0; // achromatic
        else {
            saturation = chroma / (lightness < 0.5 ? max + min : 2 - max - min);
            switch(max){
                case red:
                    hue = (green - blue) / chroma + (green < blue ? 6 : 0);
                    break;
                case green:
                    hue = (blue - red) / chroma + 2;
                    break;
                case blue:
                    hue = (red - green) / chroma + 4;
                    break;
            }
            hue /= 6;
        }
        return new $83fe1a57d631223b$var$HSLColor($4tN2K$reactstatelyutils.toFixedNumber(hue * 360, 2), $4tN2K$reactstatelyutils.toFixedNumber(saturation * 100, 2), $4tN2K$reactstatelyutils.toFixedNumber(lightness * 100, 2), this.alpha);
    }
    clone() {
        return new $83fe1a57d631223b$var$RGBColor(this.red, this.green, this.blue, this.alpha);
    }
    getChannelRange(channel) {
        switch(channel){
            case 'red':
            case 'green':
            case 'blue':
                return {
                    minValue: 0,
                    maxValue: 255,
                    step: 1,
                    pageSize: 17
                };
            case 'alpha':
                return {
                    minValue: 0,
                    maxValue: 1,
                    step: 0.01,
                    pageSize: 0.1
                };
            default:
                throw new Error('Unknown color channel: ' + channel);
        }
    }
    formatChannelValue(channel, locale) {
        let options;
        let value = this.getChannelValue(channel);
        switch(channel){
            case 'red':
            case 'green':
            case 'blue':
                options = {
                    style: 'decimal'
                };
                break;
            case 'alpha':
                options = {
                    style: 'percent'
                };
                break;
            default:
                throw new Error('Unknown color channel: ' + channel);
        }
        return new $4tN2K$internationalizednumber.NumberFormatter(locale, options).format(value);
    }
    getColorSpace() {
        return 'rgb';
    }
    getColorChannels() {
        return $83fe1a57d631223b$var$RGBColor.colorChannels;
    }
    constructor(red, green, blue, alpha){
        super();
        this.red = red;
        this.green = green;
        this.blue = blue;
        this.alpha = alpha;
    }
}
$83fe1a57d631223b$var$RGBColor.colorChannels = [
    'red',
    'green',
    'blue'
];
// X = <negative/positive number with/without decimal places>
// before/after a comma, 0 or more whitespaces are allowed
// - hsb(X, X%, X%)
// - hsba(X, X%, X%, X)
const $83fe1a57d631223b$var$HSB_REGEX = /hsb\(([-+]?\d+(?:.\d+)?\s*,\s*[-+]?\d+(?:.\d+)?%\s*,\s*[-+]?\d+(?:.\d+)?%)\)|hsba\(([-+]?\d+(?:.\d+)?\s*,\s*[-+]?\d+(?:.\d+)?%\s*,\s*[-+]?\d+(?:.\d+)?%\s*,\s*[-+]?\d(.\d+)?)\)/;
class $83fe1a57d631223b$var$HSBColor extends $83fe1a57d631223b$var$Color {
    static parse(value) {
        let m;
        if (m = value.match($83fe1a57d631223b$var$HSB_REGEX)) {
            var ref;
            const [h, s, b, a] = ((ref = m[1]) !== null && ref !== void 0 ? ref : m[2]).split(',').map((n)=>Number(n.trim().replace('%', ''))
            );
            return new $83fe1a57d631223b$var$HSBColor($83fe1a57d631223b$var$mod(h, 360), $4tN2K$reactstatelyutils.clamp(s, 0, 100), $4tN2K$reactstatelyutils.clamp(b, 0, 100), $4tN2K$reactstatelyutils.clamp(a !== null && a !== void 0 ? a : 1, 0, 1));
        }
    }
    toString(format) {
        switch(format){
            case 'css':
                return this.toHSL().toString('css');
            case 'hex':
                return this.toRGB().toString('hex');
            case 'hexa':
                return this.toRGB().toString('hexa');
            case 'hsb':
                return `hsb(${this.hue}, ${$4tN2K$reactstatelyutils.toFixedNumber(this.saturation, 2)}%, ${$4tN2K$reactstatelyutils.toFixedNumber(this.brightness, 2)}%)`;
            case 'hsba':
                return `hsba(${this.hue}, ${$4tN2K$reactstatelyutils.toFixedNumber(this.saturation, 2)}%, ${$4tN2K$reactstatelyutils.toFixedNumber(this.brightness, 2)}%, ${this.alpha})`;
            default:
                return this.toFormat(format).toString(format);
        }
    }
    toFormat(format) {
        switch(format){
            case 'hsb':
            case 'hsba':
                return this;
            case 'hsl':
            case 'hsla':
                return this.toHSL();
            case 'rgb':
            case 'rgba':
                return this.toRGB();
            default:
                throw new Error('Unsupported color conversion: hsb -> ' + format);
        }
    }
    /**
   * Converts a HSB color to HSL.
   * Conversion formula adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#HSV_to_HSL.
   * @returns An HSLColor object.
   */ toHSL() {
        let saturation = this.saturation / 100;
        let brightness = this.brightness / 100;
        let lightness = brightness * (1 - saturation / 2);
        saturation = lightness === 0 || lightness === 1 ? 0 : (brightness - lightness) / Math.min(lightness, 1 - lightness);
        return new $83fe1a57d631223b$var$HSLColor($4tN2K$reactstatelyutils.toFixedNumber(this.hue, 2), $4tN2K$reactstatelyutils.toFixedNumber(saturation * 100, 2), $4tN2K$reactstatelyutils.toFixedNumber(lightness * 100, 2), this.alpha);
    }
    /**
   * Converts a HSV color value to RGB.
   * Conversion formula adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#HSV_to_RGB_alternative.
   * @returns An RGBColor object.
   */ toRGB() {
        let hue = this.hue;
        let saturation = this.saturation / 100;
        let brightness = this.brightness / 100;
        let fn = (n, k = (n + hue / 60) % 6)=>brightness - saturation * brightness * Math.max(Math.min(k, 4 - k, 1), 0)
        ;
        return new $83fe1a57d631223b$var$RGBColor(Math.round(fn(5) * 255), Math.round(fn(3) * 255), Math.round(fn(1) * 255), this.alpha);
    }
    clone() {
        return new $83fe1a57d631223b$var$HSBColor(this.hue, this.saturation, this.brightness, this.alpha);
    }
    getChannelRange(channel) {
        switch(channel){
            case 'hue':
                return {
                    minValue: 0,
                    maxValue: 360,
                    step: 1,
                    pageSize: 15
                };
            case 'saturation':
            case 'brightness':
                return {
                    minValue: 0,
                    maxValue: 100,
                    step: 1,
                    pageSize: 10
                };
            case 'alpha':
                return {
                    minValue: 0,
                    maxValue: 1,
                    step: 0.01,
                    pageSize: 0.1
                };
            default:
                throw new Error('Unknown color channel: ' + channel);
        }
    }
    formatChannelValue(channel, locale) {
        let options;
        let value = this.getChannelValue(channel);
        switch(channel){
            case 'hue':
                options = {
                    style: 'unit',
                    unit: 'degree',
                    unitDisplay: 'narrow'
                };
                break;
            case 'saturation':
            case 'brightness':
                options = {
                    style: 'percent'
                };
                value /= 100;
                break;
            case 'alpha':
                options = {
                    style: 'percent'
                };
                break;
            default:
                throw new Error('Unknown color channel: ' + channel);
        }
        return new $4tN2K$internationalizednumber.NumberFormatter(locale, options).format(value);
    }
    getColorSpace() {
        return 'hsb';
    }
    getColorChannels() {
        return $83fe1a57d631223b$var$HSBColor.colorChannels;
    }
    constructor(hue, saturation, brightness, alpha){
        super();
        this.hue = hue;
        this.saturation = saturation;
        this.brightness = brightness;
        this.alpha = alpha;
    }
}
$83fe1a57d631223b$var$HSBColor.colorChannels = [
    'hue',
    'saturation',
    'brightness'
];
// X = <negative/positive number with/without decimal places>
// before/after a comma, 0 or more whitespaces are allowed
// - hsl(X, X%, X%)
// - hsla(X, X%, X%, X)
const $83fe1a57d631223b$var$HSL_REGEX = /hsl\(([-+]?\d+(?:.\d+)?\s*,\s*[-+]?\d+(?:.\d+)?%\s*,\s*[-+]?\d+(?:.\d+)?%)\)|hsla\(([-+]?\d+(?:.\d+)?\s*,\s*[-+]?\d+(?:.\d+)?%\s*,\s*[-+]?\d+(?:.\d+)?%\s*,\s*[-+]?\d(.\d+)?)\)/;
function $83fe1a57d631223b$var$mod(n, m) {
    return (n % m + m) % m;
}
class $83fe1a57d631223b$var$HSLColor extends $83fe1a57d631223b$var$Color {
    static parse(value) {
        let m;
        if (m = value.match($83fe1a57d631223b$var$HSL_REGEX)) {
            var ref;
            const [h, s, l, a] = ((ref = m[1]) !== null && ref !== void 0 ? ref : m[2]).split(',').map((n)=>Number(n.trim().replace('%', ''))
            );
            return new $83fe1a57d631223b$var$HSLColor($83fe1a57d631223b$var$mod(h, 360), $4tN2K$reactstatelyutils.clamp(s, 0, 100), $4tN2K$reactstatelyutils.clamp(l, 0, 100), $4tN2K$reactstatelyutils.clamp(a !== null && a !== void 0 ? a : 1, 0, 1));
        }
    }
    toString(format) {
        switch(format){
            case 'hex':
                return this.toRGB().toString('hex');
            case 'hexa':
                return this.toRGB().toString('hexa');
            case 'hsl':
                return `hsl(${this.hue}, ${$4tN2K$reactstatelyutils.toFixedNumber(this.saturation, 2)}%, ${$4tN2K$reactstatelyutils.toFixedNumber(this.lightness, 2)}%)`;
            case 'css':
            case 'hsla':
                return `hsla(${this.hue}, ${$4tN2K$reactstatelyutils.toFixedNumber(this.saturation, 2)}%, ${$4tN2K$reactstatelyutils.toFixedNumber(this.lightness, 2)}%, ${this.alpha})`;
            default:
                return this.toFormat(format).toString(format);
        }
    }
    toFormat(format) {
        switch(format){
            case 'hsl':
            case 'hsla':
                return this;
            case 'hsb':
            case 'hsba':
                return this.toHSB();
            case 'rgb':
            case 'rgba':
                return this.toRGB();
            default:
                throw new Error('Unsupported color conversion: hsl -> ' + format);
        }
    }
    /**
   * Converts a HSL color to HSB.
   * Conversion formula adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#HSL_to_HSV.
   * @returns An HSBColor object.
   */ toHSB() {
        let saturation = this.saturation / 100;
        let lightness = this.lightness / 100;
        let brightness = lightness + saturation * Math.min(lightness, 1 - lightness);
        saturation = brightness === 0 ? 0 : 2 * (1 - lightness / brightness);
        return new $83fe1a57d631223b$var$HSBColor($4tN2K$reactstatelyutils.toFixedNumber(this.hue, 2), $4tN2K$reactstatelyutils.toFixedNumber(saturation * 100, 2), $4tN2K$reactstatelyutils.toFixedNumber(brightness * 100, 2), this.alpha);
    }
    /**
   * Converts a HSL color to RGB.
   * Conversion formula adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#HSL_to_RGB_alternative.
   * @returns An RGBColor object.
   */ toRGB() {
        let hue = this.hue;
        let saturation = this.saturation / 100;
        let lightness = this.lightness / 100;
        let a = saturation * Math.min(lightness, 1 - lightness);
        let fn = (n, k = (n + hue / 30) % 12)=>lightness - a * Math.max(Math.min(k - 3, 9 - k, 1), -1)
        ;
        return new $83fe1a57d631223b$var$RGBColor(Math.round(fn(0) * 255), Math.round(fn(8) * 255), Math.round(fn(4) * 255), this.alpha);
    }
    clone() {
        return new $83fe1a57d631223b$var$HSLColor(this.hue, this.saturation, this.lightness, this.alpha);
    }
    getChannelRange(channel) {
        switch(channel){
            case 'hue':
                return {
                    minValue: 0,
                    maxValue: 360,
                    step: 1,
                    pageSize: 15
                };
            case 'saturation':
            case 'lightness':
                return {
                    minValue: 0,
                    maxValue: 100,
                    step: 1,
                    pageSize: 10
                };
            case 'alpha':
                return {
                    minValue: 0,
                    maxValue: 1,
                    step: 0.01,
                    pageSize: 0.1
                };
            default:
                throw new Error('Unknown color channel: ' + channel);
        }
    }
    formatChannelValue(channel, locale) {
        let options;
        let value = this.getChannelValue(channel);
        switch(channel){
            case 'hue':
                options = {
                    style: 'unit',
                    unit: 'degree',
                    unitDisplay: 'narrow'
                };
                break;
            case 'saturation':
            case 'lightness':
                options = {
                    style: 'percent'
                };
                value /= 100;
                break;
            case 'alpha':
                options = {
                    style: 'percent'
                };
                break;
            default:
                throw new Error('Unknown color channel: ' + channel);
        }
        return new $4tN2K$internationalizednumber.NumberFormatter(locale, options).format(value);
    }
    getColorSpace() {
        return 'hsl';
    }
    getColorChannels() {
        return $83fe1a57d631223b$var$HSLColor.colorChannels;
    }
    constructor(hue, saturation, lightness, alpha){
        super();
        this.hue = hue;
        this.saturation = saturation;
        this.lightness = lightness;
        this.alpha = alpha;
    }
}
$83fe1a57d631223b$var$HSLColor.colorChannels = [
    'hue',
    'saturation',
    'lightness'
];


var $af2d7ac9990cfee2$exports = {};

$parcel$export($af2d7ac9990cfee2$exports, "useColorAreaState", () => $af2d7ac9990cfee2$export$6df7f0e2cabc7eef);



const $af2d7ac9990cfee2$var$DEFAULT_COLOR = $83fe1a57d631223b$export$6e865ea70d7724f('#ffffff');
function $af2d7ac9990cfee2$export$6df7f0e2cabc7eef(props) {
    let { value: value1 , defaultValue: defaultValue , xChannel: xChannel , yChannel: yChannel , onChange: onChange , onChangeEnd: onChangeEnd  } = props;
    if (!value1 && !defaultValue) defaultValue = $af2d7ac9990cfee2$var$DEFAULT_COLOR;
    let [color, setColor] = $4tN2K$reactstatelyutils.useControlledState(value1 && $83fe1a57d631223b$export$4cde5df63f53f473(value1), defaultValue && $83fe1a57d631223b$export$4cde5df63f53f473(defaultValue), onChange);
    let valueRef = $4tN2K$react.useRef(color);
    valueRef.current = color;
    let channels = $4tN2K$react.useMemo(()=>valueRef.current.getColorSpaceAxes({
            xChannel: xChannel,
            yChannel: yChannel
        })
    , [
        xChannel,
        yChannel
    ]);
    let xChannelRange = color.getChannelRange(channels.xChannel);
    let yChannelRange = color.getChannelRange(channels.yChannel);
    let { minValue: minValueX , maxValue: maxValueX , step: stepX , pageSize: pageSizeX  } = xChannelRange;
    let { minValue: minValueY , maxValue: maxValueY , step: stepY , pageSize: pageSizeY  } = yChannelRange;
    let [isDragging1, setDragging] = $4tN2K$react.useState(false);
    let isDraggingRef = $4tN2K$react.useRef(false).current;
    let xValue = color.getChannelValue(channels.xChannel);
    let yValue = color.getChannelValue(channels.yChannel);
    let setXValue = (v)=>{
        if (v === xValue) return;
        valueRef.current = color.withChannelValue(channels.xChannel, v);
        setColor(valueRef.current);
    };
    let setYValue = (v)=>{
        if (v === yValue) return;
        valueRef.current = color.withChannelValue(channels.yChannel, v);
        setColor(valueRef.current);
    };
    return {
        channels: channels,
        xChannelStep: stepX,
        yChannelStep: stepY,
        xChannelPageStep: pageSizeX,
        yChannelPageStep: pageSizeY,
        value: color,
        setValue (value) {
            let c = $83fe1a57d631223b$export$4cde5df63f53f473(value);
            valueRef.current = c;
            setColor(c);
        },
        xValue: xValue,
        setXValue: setXValue,
        yValue: yValue,
        setYValue: setYValue,
        setColorFromPoint (x, y) {
            let newXValue = minValueX + $4tN2K$reactstatelyutils.clamp(x, 0, 1) * (maxValueX - minValueX);
            let newYValue = minValueY + (1 - $4tN2K$reactstatelyutils.clamp(y, 0, 1)) * (maxValueY - minValueY);
            let newColor;
            if (newXValue !== xValue) {
                // Round new value to multiple of step, clamp value between min and max
                newXValue = $4tN2K$reactstatelyutils.snapValueToStep(newXValue, minValueX, maxValueX, stepX);
                newColor = color.withChannelValue(channels.xChannel, newXValue);
            }
            if (newYValue !== yValue) {
                // Round new value to multiple of step, clamp value between min and max
                newYValue = $4tN2K$reactstatelyutils.snapValueToStep(newYValue, minValueY, maxValueY, stepY);
                newColor = (newColor || color).withChannelValue(channels.yChannel, newYValue);
            }
            if (newColor) setColor(newColor);
        },
        getThumbPosition () {
            let x = (xValue - minValueX) / (maxValueX - minValueX);
            let y = 1 - (yValue - minValueY) / (maxValueY - minValueY);
            return {
                x: x,
                y: y
            };
        },
        incrementX (stepSize) {
            setXValue(xValue + stepSize > maxValueX ? maxValueX : $4tN2K$reactstatelyutils.snapValueToStep(xValue + stepSize, minValueX, maxValueX, stepX));
        },
        incrementY (stepSize) {
            setYValue(yValue + stepSize > maxValueY ? maxValueY : $4tN2K$reactstatelyutils.snapValueToStep(yValue + stepSize, minValueY, maxValueY, stepY));
        },
        decrementX (stepSize) {
            setXValue($4tN2K$reactstatelyutils.snapValueToStep(xValue - stepSize, minValueX, maxValueX, stepX));
        },
        decrementY (stepSize) {
            setYValue($4tN2K$reactstatelyutils.snapValueToStep(yValue - stepSize, minValueY, maxValueY, stepY));
        },
        setDragging (isDragging) {
            let wasDragging = isDraggingRef;
            isDraggingRef = isDragging;
            if (onChangeEnd && !isDragging && wasDragging) onChangeEnd(valueRef.current);
            setDragging(isDragging);
        },
        isDragging: isDragging1,
        getDisplayColor () {
            return color.withChannelValue('alpha', 1);
        }
    };
}


var $5386a492cfd3234c$exports = {};

$parcel$export($5386a492cfd3234c$exports, "useColorSliderState", () => $5386a492cfd3234c$export$57bc203e1c9c6d44);



function $5386a492cfd3234c$export$57bc203e1c9c6d44(props) {
    let { channel: channel , value: value1 , defaultValue: defaultValue , onChange: onChange , locale: locale , ...otherProps } = props;
    if (value1 == null && defaultValue == null) throw new Error('useColorSliderState requires a value or defaultValue');
    let [color, setColor] = $4tN2K$reactstatelyutils.useControlledState(value1 && $83fe1a57d631223b$export$4cde5df63f53f473(value1), defaultValue && $83fe1a57d631223b$export$4cde5df63f53f473(defaultValue), onChange);
    let sliderState = $4tN2K$reactstatelyslider.useSliderState({
        ...color.getChannelRange(channel),
        ...otherProps,
        // Unused except in getThumbValueLabel, which is overridden below. null to appease TypeScript.
        numberFormatter: null,
        value: [
            color.getChannelValue(channel)
        ],
        onChange ([v]) {
            setColor(color.withChannelValue(channel, v));
        },
        onChangeEnd ([v]) {
            // onChange will have already been called with the right value, this is just to trigger onChangeEnd
            if (props.onChangeEnd) props.onChangeEnd(color.withChannelValue(channel, v));
        }
    });
    let { step: step , pageSize: pageSize  } = color.getChannelRange(channel);
    return {
        ...sliderState,
        value: color,
        setValue (value) {
            setColor($83fe1a57d631223b$export$4cde5df63f53f473(value));
        },
        getDisplayColor () {
            switch(channel){
                case 'hue':
                    return $83fe1a57d631223b$export$6e865ea70d7724f(`hsl(${color.getChannelValue('hue')}, 100%, 50%)`);
                case 'lightness':
                case 'brightness':
                case 'saturation':
                case 'red':
                case 'green':
                case 'blue':
                    return color.withChannelValue('alpha', 1);
                case 'alpha':
                    return color;
                default:
                    throw new Error('Unknown color channel: ' + channel);
            }
        },
        getThumbValueLabel () {
            return color.formatChannelValue(channel, locale);
        },
        step: step,
        pageSize: pageSize
    };
}


var $9d7d8736d45f74b8$exports = {};

$parcel$export($9d7d8736d45f74b8$exports, "useColorWheelState", () => $9d7d8736d45f74b8$export$f4301076d9336137);



const $9d7d8736d45f74b8$var$DEFAULT_COLOR = $83fe1a57d631223b$export$6e865ea70d7724f('hsl(0, 100%, 50%)');
function $9d7d8736d45f74b8$var$roundToStep(value, step) {
    return Math.round(value / step) * step;
}
function $9d7d8736d45f74b8$var$mod(n, m) {
    return (n % m + m) % m;
}
function $9d7d8736d45f74b8$var$roundDown(v) {
    let r = Math.floor(v);
    if (r === v) return v - 1;
    else return r;
}
function $9d7d8736d45f74b8$var$degToRad(deg) {
    return deg * Math.PI / 180;
}
function $9d7d8736d45f74b8$var$radToDeg(rad) {
    return rad * 180 / Math.PI;
}
// 0deg = 3 o'clock. increases clockwise
function $9d7d8736d45f74b8$var$angleToCartesian(angle, radius) {
    let rad = $9d7d8736d45f74b8$var$degToRad(360 - angle + 90);
    let x = Math.sin(rad) * radius;
    let y = Math.cos(rad) * radius;
    return {
        x: x,
        y: y
    };
}
function $9d7d8736d45f74b8$var$cartesianToAngle(x, y, radius) {
    let deg = $9d7d8736d45f74b8$var$radToDeg(Math.atan2(y / radius, x / radius));
    return (deg + 360) % 360;
}
function $9d7d8736d45f74b8$export$f4301076d9336137(props) {
    let { defaultValue: defaultValue , onChange: onChange , onChangeEnd: onChangeEnd  } = props;
    if (!props.value && !defaultValue) defaultValue = $9d7d8736d45f74b8$var$DEFAULT_COLOR;
    let [value, setValue] = $4tN2K$reactstatelyutils.useControlledState($83fe1a57d631223b$export$4cde5df63f53f473(props.value), $83fe1a57d631223b$export$4cde5df63f53f473(defaultValue), onChange);
    let valueRef = $4tN2K$react.useRef(value);
    valueRef.current = value;
    let channelRange = value.getChannelRange('hue');
    let { minValue: minValueX , maxValue: maxValueX , step: step , pageSize: pageStep  } = channelRange;
    let [isDragging1, setDragging] = $4tN2K$react.useState(false);
    let isDraggingRef = $4tN2K$react.useRef(false).current;
    let hue = value.getChannelValue('hue');
    function setHue(v) {
        if (v > 360) // Make sure you can always get back to 0.
        v = 0;
        v = $9d7d8736d45f74b8$var$roundToStep($9d7d8736d45f74b8$var$mod(v, 360), step);
        if (hue !== v) {
            let color = value.withChannelValue('hue', v);
            valueRef.current = color;
            setValue(color);
        }
    }
    return {
        value: value,
        step: step,
        pageStep: pageStep,
        setValue (v) {
            let color = $83fe1a57d631223b$export$4cde5df63f53f473(v);
            valueRef.current = color;
            setValue(color);
        },
        hue: hue,
        setHue: setHue,
        setHueFromPoint (x, y, radius) {
            setHue($9d7d8736d45f74b8$var$cartesianToAngle(x, y, radius));
        },
        getThumbPosition (radius) {
            return $9d7d8736d45f74b8$var$angleToCartesian(value.getChannelValue('hue'), radius);
        },
        increment (stepSize = 1) {
            let s = Math.max(stepSize, step);
            let newValue = hue + s;
            if (newValue >= maxValueX) // Make sure you can always get back to 0.
            newValue = minValueX;
            setHue($9d7d8736d45f74b8$var$roundToStep($9d7d8736d45f74b8$var$mod(newValue, 360), s));
        },
        decrement (stepSize = 1) {
            let s = Math.max(stepSize, step);
            if (hue === 0) // We can't just subtract step because this might be the case:
            // |(previous step) - 0| < step size
            setHue($9d7d8736d45f74b8$var$roundDown(360 / s) * s);
            else setHue($9d7d8736d45f74b8$var$roundToStep($9d7d8736d45f74b8$var$mod(hue - s, 360), s));
        },
        setDragging (isDragging) {
            let wasDragging = isDraggingRef;
            isDraggingRef = isDragging;
            if (onChangeEnd && !isDragging && wasDragging) onChangeEnd(valueRef.current);
            setDragging(isDragging);
        },
        isDragging: isDragging1,
        getDisplayColor () {
            return value.toFormat('hsl').withChannelValue('saturation', 100).withChannelValue('lightness', 50);
        }
    };
}


var $d59d0c2b2ce1568f$exports = {};

$parcel$export($d59d0c2b2ce1568f$exports, "useColorFieldState", () => $d59d0c2b2ce1568f$export$d52a01683abdfcd6);



function $f8b3be23ba4462b1$export$5aadd9c0606af5c2(value) {
    return $4tN2K$react.useMemo(()=>{
        if (typeof value === 'string') try {
            return $83fe1a57d631223b$export$6e865ea70d7724f(value);
        } catch (err) {
            return undefined;
        }
        return value;
    }, [
        value
    ]);
}




const $d59d0c2b2ce1568f$var$MIN_COLOR = $83fe1a57d631223b$export$6e865ea70d7724f('#000000');
const $d59d0c2b2ce1568f$var$MAX_COLOR = $83fe1a57d631223b$export$6e865ea70d7724f('#FFFFFF');
const $d59d0c2b2ce1568f$var$MIN_COLOR_INT = $d59d0c2b2ce1568f$var$MIN_COLOR.toHexInt();
const $d59d0c2b2ce1568f$var$MAX_COLOR_INT = $d59d0c2b2ce1568f$var$MAX_COLOR.toHexInt();
function $d59d0c2b2ce1568f$export$d52a01683abdfcd6(props) {
    let { value: value1 , defaultValue: defaultValue , onChange: onChange  } = props;
    let { step: step  } = $d59d0c2b2ce1568f$var$MIN_COLOR.getChannelRange('red');
    let initialValue = $f8b3be23ba4462b1$export$5aadd9c0606af5c2(value1);
    let initialDefaultValue = $f8b3be23ba4462b1$export$5aadd9c0606af5c2(defaultValue);
    let [colorValue, setColorValue] = $4tN2K$reactstatelyutils.useControlledState(initialValue, initialDefaultValue, onChange);
    let [inputValue, setInputValue] = $4tN2K$react.useState(()=>(value1 || defaultValue) && colorValue ? colorValue.toString('hex') : ''
    );
    let safelySetColorValue = (newColor)=>{
        if (!colorValue || !newColor) {
            setColorValue(newColor);
            return;
        }
        if (newColor.toHexInt() !== colorValue.toHexInt()) {
            setColorValue(newColor);
            return;
        }
    };
    let prevValue = $4tN2K$react.useRef(colorValue);
    if (prevValue.current !== colorValue) {
        setInputValue(colorValue ? colorValue.toString('hex') : '');
        prevValue.current = colorValue;
    }
    let parsedValue = $4tN2K$react.useMemo(()=>{
        let color;
        try {
            color = $83fe1a57d631223b$export$6e865ea70d7724f(inputValue.startsWith('#') ? inputValue : `#${inputValue}`);
        } catch (err) {
            color = null;
        }
        return color;
    }, [
        $83fe1a57d631223b$export$6e865ea70d7724f,
        inputValue
    ]);
    let parsed = $4tN2K$react.useRef(null);
    parsed.current = parsedValue;
    let commit = ()=>{
        // Set to empty state if input value is empty
        if (!inputValue.length) {
            safelySetColorValue(null);
            setInputValue(value1 === undefined ? '' : colorValue.toString('hex'));
            return;
        }
        // if it failed to parse, then reset input to formatted version of current number
        if (parsed.current == null) {
            setInputValue(colorValue ? colorValue.toString('hex') : '');
            return;
        }
        safelySetColorValue(parsed.current);
        // in a controlled state, the numberValue won't change, so we won't go back to our old input without help
        let newColorValue = '';
        if (colorValue) newColorValue = colorValue.toString('hex');
        setInputValue(newColorValue);
    };
    let increment = ()=>{
        let newValue = $d59d0c2b2ce1568f$var$addColorValue(parsed.current, step);
        // if we've arrived at the same value that was previously in the state, the
        // input value should be updated to match
        // ex type 4, press increment, highlight the number in the input, type 4 again, press increment
        // you'd be at 5, then incrementing to 5 again, so no re-render would happen and 4 would be left in the input
        if (newValue === colorValue) setInputValue(newValue.toString('hex'));
        safelySetColorValue(newValue);
    };
    let decrement = ()=>{
        let newValue = $d59d0c2b2ce1568f$var$addColorValue(parsed.current, -step);
        // if we've arrived at the same value that was previously in the state, the
        // input value should be updated to match
        // ex type 4, press increment, highlight the number in the input, type 4 again, press increment
        // you'd be at 5, then incrementing to 5 again, so no re-render would happen and 4 would be left in the input
        if (newValue === colorValue) setInputValue(newValue.toString('hex'));
        safelySetColorValue(newValue);
    };
    let incrementToMax = ()=>safelySetColorValue($d59d0c2b2ce1568f$var$MAX_COLOR)
    ;
    let decrementToMin = ()=>safelySetColorValue($d59d0c2b2ce1568f$var$MIN_COLOR)
    ;
    let validate = (value)=>{
        var ref;
        return value === '' || !!((ref = value.match(/^#?[0-9a-f]{0,6}$/i)) === null || ref === void 0 ? void 0 : ref[0]);
    };
    return {
        validate: validate,
        colorValue: colorValue,
        inputValue: inputValue,
        setInputValue: setInputValue,
        commit: commit,
        increment: increment,
        incrementToMax: incrementToMax,
        decrement: decrement,
        decrementToMin: decrementToMin
    };
}
function $d59d0c2b2ce1568f$var$addColorValue(color, step) {
    let newColor = color ? color : $d59d0c2b2ce1568f$var$MIN_COLOR;
    let colorInt = newColor.toHexInt();
    let clampInt = Math.min(Math.max(colorInt + step, $d59d0c2b2ce1568f$var$MIN_COLOR_INT), $d59d0c2b2ce1568f$var$MAX_COLOR_INT);
    if (clampInt !== colorInt) {
        let newColorString = `#${clampInt.toString(16).padStart(6, '0').toUpperCase()}`;
        newColor = $83fe1a57d631223b$export$6e865ea70d7724f(newColorString);
    }
    return newColor;
}


$parcel$exportWildcard(module.exports, $af2d7ac9990cfee2$exports);
$parcel$exportWildcard(module.exports, $5386a492cfd3234c$exports);
$parcel$exportWildcard(module.exports, $9d7d8736d45f74b8$exports);
$parcel$exportWildcard(module.exports, $d59d0c2b2ce1568f$exports);


//# sourceMappingURL=main.js.map
