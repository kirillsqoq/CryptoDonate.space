import {useGlobalListeners as $7KHxM$useGlobalListeners, focusWithoutScrolling as $7KHxM$focusWithoutScrolling, mergeProps as $7KHxM$mergeProps, isIOS as $7KHxM$isIOS, isAndroid as $7KHxM$isAndroid, useLabels as $7KHxM$useLabels, useId as $7KHxM$useId} from "@react-aria/utils";
import {useRef as $7KHxM$useRef, useCallback as $7KHxM$useCallback, useMemo as $7KHxM$useMemo, useState as $7KHxM$useState} from "react";
import {useKeyboard as $7KHxM$useKeyboard, useMove as $7KHxM$useMove, useFocusWithin as $7KHxM$useFocusWithin, useScrollWheel as $7KHxM$useScrollWheel} from "@react-aria/interactions";
import {useMessageFormatter as $7KHxM$useMessageFormatter, useLocale as $7KHxM$useLocale} from "@react-aria/i18n";
import {useVisuallyHidden as $7KHxM$useVisuallyHidden} from "@react-aria/visually-hidden";
import {useSlider as $7KHxM$useSlider, useSliderThumb as $7KHxM$useSliderThumb} from "@react-aria/slider";
import {useFormattedTextField as $7KHxM$useFormattedTextField} from "@react-aria/textfield";
import {useSpinButton as $7KHxM$useSpinButton} from "@react-aria/spinbutton";

function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}
function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}
var $60bd7d6e45dcddfa$exports = {};

$parcel$export($60bd7d6e45dcddfa$exports, "useColorArea", () => $60bd7d6e45dcddfa$export$2f92a7a615a014f6);

var $052cfdf4c32eb7c3$exports = {};
var $eccab2b0118aef08$exports = {};
$eccab2b0118aef08$exports = JSON.parse("{\"twoDimensionalSlider\":\"شريط تمرير ثنائي الأبعاد\",\"colorNameAndValue\":\"{name}: {value}\",\"x/y\":\"{x} / {y}\"}");


var $bf2b4507594e3d45$exports = {};
$bf2b4507594e3d45$exports = JSON.parse("{\"twoDimensionalSlider\":\"2D плъзгач\",\"colorNameAndValue\":\"{name}: {value}\",\"x/y\":\"{x} / {y}\"}");


var $01c08487af7ecd14$exports = {};
$01c08487af7ecd14$exports = JSON.parse("{\"twoDimensionalSlider\":\"2D posuvník\",\"colorNameAndValue\":\"{name}: {value}\",\"x/y\":\"{x} / {y}\"}");


var $5e997db6ea0d10f6$exports = {};
$5e997db6ea0d10f6$exports = JSON.parse("{\"twoDimensionalSlider\":\"2D-skyder\",\"colorNameAndValue\":\"{name}: {value}\",\"x/y\":\"{x} / {y}\"}");


var $fe5998f640a79fd2$exports = {};
$fe5998f640a79fd2$exports = JSON.parse("{\"twoDimensionalSlider\":\"2D-Schieberegler\",\"colorNameAndValue\":\"{name}: {value}\",\"x/y\":\"{x} / {y}\"}");


var $18e4d1d5b500a9ee$exports = {};
$18e4d1d5b500a9ee$exports = JSON.parse("{\"twoDimensionalSlider\":\"Ρυθμιστικό 2D\",\"colorNameAndValue\":\"{name}: {value}\",\"x/y\":\"{x} / {y}\"}");


var $bf90a11a7a42a0f7$exports = {};
$bf90a11a7a42a0f7$exports = JSON.parse("{\"twoDimensionalSlider\":\"2D slider\",\"colorNameAndValue\":\"{name}: {value}\",\"x/y\":\"{x} / {y}\"}");


var $dd0d25f885b5c5f3$exports = {};
$dd0d25f885b5c5f3$exports = JSON.parse("{\"twoDimensionalSlider\":\"Control deslizante en 2D\",\"colorNameAndValue\":\"{name}: {value}\",\"x/y\":\"{x} / {y}\"}");


var $d950967017e3485b$exports = {};
$d950967017e3485b$exports = JSON.parse("{\"twoDimensionalSlider\":\"2D-liugur\",\"colorNameAndValue\":\"{name}: {value}\",\"x/y\":\"{x} / {y}\"}");


var $00a415a3f0ab315a$exports = {};
$00a415a3f0ab315a$exports = JSON.parse("{\"twoDimensionalSlider\":\"2D-liukusäädin\",\"colorNameAndValue\":\"{name}: {value}\",\"x/y\":\"{x} / {y}\"}");


var $d80f30fe86c95741$exports = {};
$d80f30fe86c95741$exports = JSON.parse("{\"twoDimensionalSlider\":\"Curseur 2D\",\"colorNameAndValue\":\"{name}: {value}\",\"x/y\":\"{x} / {y}\"}");


var $6912afb584340a2e$exports = {};
$6912afb584340a2e$exports = JSON.parse("{\"twoDimensionalSlider\":\"מחוון דו-ממדי\",\"colorNameAndValue\":\"{name}: {value}\",\"x/y\":\"{x} / {y}\"}");


var $7b97fcacd84ec90f$exports = {};
$7b97fcacd84ec90f$exports = JSON.parse("{\"twoDimensionalSlider\":\"2D kliznik\",\"colorNameAndValue\":\"{name}: {value}\",\"x/y\":\"{x} / {y}\"}");


var $da9b443e89eebc6b$exports = {};
$da9b443e89eebc6b$exports = JSON.parse("{\"twoDimensionalSlider\":\"2D csúszka\",\"colorNameAndValue\":\"{name}: {value}\",\"x/y\":\"{x} / {y}\"}");


var $35f135b45eb4d95b$exports = {};
$35f135b45eb4d95b$exports = JSON.parse("{\"twoDimensionalSlider\":\"Dispositivo di scorrimento 2D\",\"colorNameAndValue\":\"{name}: {value}\",\"x/y\":\"{x} / {y}\"}");


var $760b09448e39c6cd$exports = {};
$760b09448e39c6cd$exports = JSON.parse("{\"twoDimensionalSlider\":\"2D スライダー\",\"colorNameAndValue\":\"{name}: {value}\",\"x/y\":\"{x} / {y}\"}");


var $fc7b7d43be9703ec$exports = {};
$fc7b7d43be9703ec$exports = JSON.parse("{\"twoDimensionalSlider\":\"2D 슬라이더\",\"colorNameAndValue\":\"{name}: {value}\",\"x/y\":\"{x} / {y}\"}");


var $74918a1664156912$exports = {};
$74918a1664156912$exports = JSON.parse("{\"twoDimensionalSlider\":\"2D slankiklis\",\"colorNameAndValue\":\"{name}: {value}\",\"x/y\":\"{x} / {y}\"}");


var $4e6cde11c2bc9840$exports = {};
$4e6cde11c2bc9840$exports = JSON.parse("{\"twoDimensionalSlider\":\"Plaknes slīdnis\",\"colorNameAndValue\":\"{name}: {value}\",\"x/y\":\"{x} / {y}\"}");


var $6faa3defebc3eb72$exports = {};
$6faa3defebc3eb72$exports = JSON.parse("{\"twoDimensionalSlider\":\"2D-glidebryter\",\"colorNameAndValue\":\"{name}: {value}\",\"x/y\":\"{x} / {y}\"}");


var $6ac9b6b1b7e3ca12$exports = {};
$6ac9b6b1b7e3ca12$exports = JSON.parse("{\"twoDimensionalSlider\":\"2D-schuifregelaar\",\"colorNameAndValue\":\"{name}: {value}\",\"x/y\":\"{x} / {y}\"}");


var $1be8b0ee8841f1e7$exports = {};
$1be8b0ee8841f1e7$exports = JSON.parse("{\"twoDimensionalSlider\":\"Suwak 2D\",\"colorNameAndValue\":\"{name}: {value}\",\"x/y\":\"{x} / {y}\"}");


var $f9507c2d404ed689$exports = {};
$f9507c2d404ed689$exports = JSON.parse("{\"twoDimensionalSlider\":\"Controle deslizante 2D\",\"colorNameAndValue\":\"{name}: {value}\",\"x/y\":\"{x} / {y}\"}");


var $8f872ea59c02d67e$exports = {};
$8f872ea59c02d67e$exports = JSON.parse("{\"twoDimensionalSlider\":\"Controlo de deslize 2D\",\"colorNameAndValue\":\"{name}: {value}\",\"x/y\":\"{x} / {y}\"}");


var $b03b45b62a7ccae4$exports = {};
$b03b45b62a7ccae4$exports = JSON.parse("{\"twoDimensionalSlider\":\"Cursor 2D\",\"colorNameAndValue\":\"{name}: {value}\",\"x/y\":\"{x} / {y}\"}");


var $f1107d94c09df9b8$exports = {};
$f1107d94c09df9b8$exports = JSON.parse("{\"twoDimensionalSlider\":\"Двумерный ползунок\",\"colorNameAndValue\":\"{name}: {value}\",\"x/y\":\"{x} / {y}\"}");


var $b61325f242fafc7c$exports = {};
$b61325f242fafc7c$exports = JSON.parse("{\"twoDimensionalSlider\":\"2D jazdec\",\"colorNameAndValue\":\"{name}: {value}\",\"x/y\":\"{x} / {y}\"}");


var $f44b7cf39ac8f315$exports = {};
$f44b7cf39ac8f315$exports = JSON.parse("{\"twoDimensionalSlider\":\"2D-drsnik\",\"colorNameAndValue\":\"{name}: {value}\",\"x/y\":\"{x} / {y}\"}");


var $aa8cd83fc8d4982b$exports = {};
$aa8cd83fc8d4982b$exports = JSON.parse("{\"twoDimensionalSlider\":\"2D клизач\",\"colorNameAndValue\":\"{name}: {value}\",\"x/y\":\"{x} / {y}\"}");


var $7c4f4e5bb7c06f1e$exports = {};
$7c4f4e5bb7c06f1e$exports = JSON.parse("{\"twoDimensionalSlider\":\"2D-reglage\",\"colorNameAndValue\":\"{name}: {value}\",\"x/y\":\"{x} / {y}\"}");


var $8045cf930ef745aa$exports = {};
$8045cf930ef745aa$exports = JSON.parse("{\"twoDimensionalSlider\":\"2B slayt gösterisi\",\"colorNameAndValue\":\"{name}: {value}\",\"x/y\":\"{x} / {y}\"}");


var $ee2044a77f24b118$exports = {};
$ee2044a77f24b118$exports = JSON.parse("{\"twoDimensionalSlider\":\"Повзунок 2D\",\"colorNameAndValue\":\"{name}: {value}\",\"x/y\":\"{x} / {y}\"}");


var $4e1dbc65a687dd93$exports = {};
$4e1dbc65a687dd93$exports = JSON.parse("{\"twoDimensionalSlider\":\"2D 滑块\",\"colorNameAndValue\":\"{name}: {value}\",\"x/y\":\"{x} / {y}\"}");


var $b0fef28529309aa6$exports = {};
$b0fef28529309aa6$exports = JSON.parse("{\"twoDimensionalSlider\":\"2D 滑桿\",\"colorNameAndValue\":\"{name}: {value}\",\"x/y\":\"{x} / {y}\"}");


$052cfdf4c32eb7c3$exports = {
    "ar-AE": $eccab2b0118aef08$exports,
    "bg-BG": $bf2b4507594e3d45$exports,
    "cs-CZ": $01c08487af7ecd14$exports,
    "da-DK": $5e997db6ea0d10f6$exports,
    "de-DE": $fe5998f640a79fd2$exports,
    "el-GR": $18e4d1d5b500a9ee$exports,
    "en-US": $bf90a11a7a42a0f7$exports,
    "es-ES": $dd0d25f885b5c5f3$exports,
    "et-EE": $d950967017e3485b$exports,
    "fi-FI": $00a415a3f0ab315a$exports,
    "fr-FR": $d80f30fe86c95741$exports,
    "he-IL": $6912afb584340a2e$exports,
    "hr-HR": $7b97fcacd84ec90f$exports,
    "hu-HU": $da9b443e89eebc6b$exports,
    "it-IT": $35f135b45eb4d95b$exports,
    "ja-JP": $760b09448e39c6cd$exports,
    "ko-KR": $fc7b7d43be9703ec$exports,
    "lt-LT": $74918a1664156912$exports,
    "lv-LV": $4e6cde11c2bc9840$exports,
    "nb-NO": $6faa3defebc3eb72$exports,
    "nl-NL": $6ac9b6b1b7e3ca12$exports,
    "pl-PL": $1be8b0ee8841f1e7$exports,
    "pt-BR": $f9507c2d404ed689$exports,
    "pt-PT": $8f872ea59c02d67e$exports,
    "ro-RO": $b03b45b62a7ccae4$exports,
    "ru-RU": $f1107d94c09df9b8$exports,
    "sk-SK": $b61325f242fafc7c$exports,
    "sl-SI": $f44b7cf39ac8f315$exports,
    "sr-SP": $aa8cd83fc8d4982b$exports,
    "sv-SE": $7c4f4e5bb7c06f1e$exports,
    "tr-TR": $8045cf930ef745aa$exports,
    "uk-UA": $ee2044a77f24b118$exports,
    "zh-CN": $4e1dbc65a687dd93$exports,
    "zh-TW": $b0fef28529309aa6$exports
};




const $40297c24c53588e6$var$generateRGB_R = (orientation, dir, zValue)=>{
    let maskImage = `linear-gradient(to ${orientation[Number(!dir)]}, transparent, #000)`;
    let result = {
        colorAreaStyles: {
            backgroundImage: `linear-gradient(to ${orientation[Number(dir)]},rgb(${zValue},0,0),rgb(${zValue},255,0))`
        },
        gradientStyles: {
            backgroundImage: `linear-gradient(to ${orientation[Number(dir)]},rgb(${zValue},0,255),rgb(${zValue},255,255))`,
            'WebkitMaskImage': maskImage,
            maskImage: maskImage
        }
    };
    return result;
};
const $40297c24c53588e6$var$generateRGB_G = (orientation, dir, zValue)=>{
    let maskImage = `linear-gradient(to ${orientation[Number(!dir)]}, transparent, #000)`;
    let result = {
        colorAreaStyles: {
            backgroundImage: `linear-gradient(to ${orientation[Number(dir)]},rgb(0,${zValue},0),rgb(255,${zValue},0))`
        },
        gradientStyles: {
            backgroundImage: `linear-gradient(to ${orientation[Number(dir)]},rgb(0,${zValue},255),rgb(255,${zValue},255))`,
            'WebkitMaskImage': maskImage,
            maskImage: maskImage
        }
    };
    return result;
};
const $40297c24c53588e6$var$generateRGB_B = (orientation, dir, zValue)=>{
    let maskImage = `linear-gradient(to ${orientation[Number(!dir)]}, transparent, #000)`;
    let result = {
        colorAreaStyles: {
            backgroundImage: `linear-gradient(to ${orientation[Number(dir)]},rgb(0,0,${zValue}),rgb(255,0,${zValue}))`
        },
        gradientStyles: {
            backgroundImage: `linear-gradient(to ${orientation[Number(dir)]},rgb(0,255,${zValue}),rgb(255,255,${zValue}))`,
            'WebkitMaskImage': maskImage,
            maskImage: maskImage
        }
    };
    return result;
};
const $40297c24c53588e6$var$generateHSL_H = (orientation, dir, zValue)=>{
    let result = {
        colorAreaStyles: {
        },
        gradientStyles: {
            background: [
                `linear-gradient(to ${orientation[Number(dir)]}, hsla(0,0%,0%,1) 0%, hsla(0,0%,0%,0) 50%, hsla(0,0%,100%,0) 50%, hsla(0,0%,100%,1) 100%)`,
                `linear-gradient(to ${orientation[Number(!dir)]},hsl(0,0%,50%),hsla(0,0%,50%,0))`,
                `hsl(${zValue}, 100%, 50%)`
            ].join(',')
        }
    };
    return result;
};
const $40297c24c53588e6$var$generateHSL_S = (orientation, dir, alphaValue)=>{
    let result = {
        colorAreaStyles: {
        },
        gradientStyles: {
            background: [
                `linear-gradient(to ${orientation[Number(!dir)]}, hsla(0,0%,0%,${alphaValue}) 0%, hsla(0,0%,0%,0) 50%, hsla(0,0%,100%,0) 50%, hsla(0,0%,100%,${alphaValue}) 100%)`,
                `linear-gradient(to ${orientation[Number(dir)]},hsla(0,100%,50%,${alphaValue}),hsla(60,100%,50%,${alphaValue}),hsla(120,100%,50%,${alphaValue}),hsla(180,100%,50%,${alphaValue}),hsla(240,100%,50%,${alphaValue}),hsla(300,100%,50%,${alphaValue}),hsla(359,100%,50%,${alphaValue}))`,
                'hsl(0, 0%, 50%)'
            ].join(',')
        }
    };
    return result;
};
const $40297c24c53588e6$var$generateHSL_L = (orientation, dir, zValue)=>{
    let result = {
        colorAreaStyles: {
        },
        gradientStyles: {
            backgroundImage: [
                `linear-gradient(to ${orientation[Number(!dir)]},hsl(0,0%,${zValue}%),hsla(0,0%,${zValue}%,0))`,
                `linear-gradient(to ${orientation[Number(dir)]},hsl(0,100%,${zValue}%),hsl(60,100%,${zValue}%),hsl(120,100%,${zValue}%),hsl(180,100%,${zValue}%),hsl(240,100%,${zValue}%),hsl(300,100%,${zValue}%),hsl(360,100%,${zValue}%))`
            ].join(',')
        }
    };
    return result;
};
const $40297c24c53588e6$var$generateHSB_H = (orientation, dir, zValue)=>{
    let result = {
        colorAreaStyles: {
        },
        gradientStyles: {
            background: [
                `linear-gradient(to ${orientation[Number(dir)]},hsl(0,0%,0%),hsla(0,0%,0%,0))`,
                `linear-gradient(to ${orientation[Number(!dir)]},hsl(0,0%,100%),hsla(0,0%,100%,0))`,
                `hsl(${zValue}, 100%, 50%)`
            ].join(',')
        }
    };
    return result;
};
const $40297c24c53588e6$var$generateHSB_S = (orientation, dir, alphaValue)=>{
    let result = {
        colorAreaStyles: {
        },
        gradientStyles: {
            background: [
                `linear-gradient(to ${orientation[Number(!dir)]},hsla(0,0%,0%,${alphaValue}),hsla(0,0%,0%,0))`,
                `linear-gradient(to ${orientation[Number(dir)]},hsla(0,100%,50%,${alphaValue}),hsla(60,100%,50%,${alphaValue}),hsla(120,100%,50%,${alphaValue}),hsla(180,100%,50%,${alphaValue}),hsla(240,100%,50%,${alphaValue}),hsla(300,100%,50%,${alphaValue}),hsla(359,100%,50%,${alphaValue}))`,
                `linear-gradient(to ${orientation[Number(!dir)]},hsl(0,0%,0%),hsl(0,0%,100%))`
            ].join(',')
        }
    };
    return result;
};
const $40297c24c53588e6$var$generateHSB_B = (orientation, dir, alphaValue)=>{
    let result = {
        colorAreaStyles: {
        },
        gradientStyles: {
            background: [
                `linear-gradient(to ${orientation[Number(!dir)]},hsla(0,0%,100%,${alphaValue}),hsla(0,0%,100%,0))`,
                `linear-gradient(to ${orientation[Number(dir)]},hsla(0,100%,50%,${alphaValue}),hsla(60,100%,50%,${alphaValue}),hsla(120,100%,50%,${alphaValue}),hsla(180,100%,50%,${alphaValue}),hsla(240,100%,50%,${alphaValue}),hsla(300,100%,50%,${alphaValue}),hsla(359,100%,50%,${alphaValue}))`,
                '#000'
            ].join(',')
        }
    };
    return result;
};
function $40297c24c53588e6$export$dd62420467d245ca({ direction: direction , state: state , zChannel: zChannel , xChannel: xChannel , isDisabled: isDisabled  }) {
    let returnVal = $7KHxM$useMemo(()=>{
        let orientation = [
            'top',
            direction === 'rtl' ? 'left' : 'right'
        ];
        let dir = false;
        let background = {
            colorAreaStyles: {
            },
            gradientStyles: {
            }
        };
        let zValue = state.value.getChannelValue(zChannel);
        let { minValue: zMin , maxValue: zMax  } = state.value.getChannelRange(zChannel);
        let alphaValue = (zValue - zMin) / (zMax - zMin);
        let isHSL = state.value.getColorSpace() === 'hsl';
        if (!isDisabled) switch(zChannel){
            case 'red':
                dir = xChannel === 'green';
                background = $40297c24c53588e6$var$generateRGB_R(orientation, dir, zValue);
                break;
            case 'green':
                dir = xChannel === 'red';
                background = $40297c24c53588e6$var$generateRGB_G(orientation, dir, zValue);
                break;
            case 'blue':
                dir = xChannel === 'red';
                background = $40297c24c53588e6$var$generateRGB_B(orientation, dir, zValue);
                break;
            case 'hue':
                dir = xChannel !== 'saturation';
                if (isHSL) background = $40297c24c53588e6$var$generateHSL_H(orientation, dir, zValue);
                else background = $40297c24c53588e6$var$generateHSB_H(orientation, dir, zValue);
                break;
            case 'saturation':
                dir = xChannel === 'hue';
                if (isHSL) background = $40297c24c53588e6$var$generateHSL_S(orientation, dir, alphaValue);
                else background = $40297c24c53588e6$var$generateHSB_S(orientation, dir, alphaValue);
                break;
            case 'brightness':
                dir = xChannel === 'hue';
                background = $40297c24c53588e6$var$generateHSB_B(orientation, dir, alphaValue);
                break;
            case 'lightness':
                dir = xChannel === 'hue';
                background = $40297c24c53588e6$var$generateHSL_L(orientation, dir, zValue);
                break;
        }
        let { x: x , y: y  } = state.getThumbPosition();
        if (direction === 'rtl') x = 1 - x;
        return {
            colorAreaStyleProps: {
                style: {
                    position: 'relative',
                    touchAction: 'none',
                    ...background.colorAreaStyles
                }
            },
            gradientStyleProps: {
                style: {
                    touchAction: 'none',
                    ...background.gradientStyles
                }
            },
            thumbStyleProps: {
                style: {
                    position: 'absolute',
                    left: `${x * 100}%`,
                    top: `${y * 100}%`,
                    transform: 'translate(0%, 0%)',
                    touchAction: 'none'
                }
            }
        };
    }, [
        direction,
        state,
        zChannel,
        xChannel,
        isDisabled
    ]);
    return returnVal;
}





function $60bd7d6e45dcddfa$export$2f92a7a615a014f6(props, state) {
    let { isDisabled: isDisabled , inputXRef: inputXRef , inputYRef: inputYRef , containerRef: containerRef  } = props;
    let formatMessage = $7KHxM$useMessageFormatter((/*@__PURE__*/$parcel$interopDefault($052cfdf4c32eb7c3$exports)));
    let { addGlobalListener: addGlobalListener , removeGlobalListener: removeGlobalListener  } = $7KHxM$useGlobalListeners();
    let { direction: direction , locale: locale  } = $7KHxM$useLocale();
    let focusedInputRef = $7KHxM$useRef(null);
    let focusInput = $7KHxM$useCallback((inputRef = inputXRef)=>{
        if (inputRef.current) $7KHxM$focusWithoutScrolling(inputRef.current);
    }, [
        inputXRef
    ]);
    let stateRef = $7KHxM$useRef(null);
    stateRef.current = state;
    let { xChannel: xChannel , yChannel: yChannel , zChannel: zChannel  } = stateRef.current.channels;
    let xChannelStep1 = stateRef.current.xChannelStep;
    let yChannelStep1 = stateRef.current.yChannelStep;
    let currentPosition = $7KHxM$useRef(null);
    let { keyboardProps: keyboardProps  } = $7KHxM$useKeyboard({
        onKeyDown (e) {
            // these are the cases that useMove doesn't handle
            if (!/^(PageUp|PageDown|Home|End)$/.test(e.key)) {
                e.continuePropagation();
                return;
            }
            // same handling as useMove, don't need to stop propagation, useKeyboard will do that for us
            e.preventDefault();
            // remember to set this and unset it so that onChangeEnd is fired
            stateRef.current.setDragging(true);
            switch(e.key){
                case 'PageUp':
                    stateRef.current.incrementY(stateRef.current.yChannelPageStep);
                    focusedInputRef.current = inputYRef.current;
                    break;
                case 'PageDown':
                    stateRef.current.decrementY(stateRef.current.yChannelPageStep);
                    focusedInputRef.current = inputYRef.current;
                    break;
                case 'Home':
                    direction === 'rtl' ? stateRef.current.incrementX(stateRef.current.xChannelPageStep) : stateRef.current.decrementX(stateRef.current.xChannelPageStep);
                    focusedInputRef.current = inputXRef.current;
                    break;
                case 'End':
                    direction === 'rtl' ? stateRef.current.decrementX(stateRef.current.xChannelPageStep) : stateRef.current.incrementX(stateRef.current.xChannelPageStep);
                    focusedInputRef.current = inputXRef.current;
                    break;
            }
            stateRef.current.setDragging(false);
            if (focusedInputRef.current) {
                focusInput(focusedInputRef.current ? focusedInputRef : inputXRef);
                focusedInputRef.current = undefined;
            }
        }
    });
    let moveHandler = {
        onMoveStart () {
            currentPosition.current = null;
            stateRef.current.setDragging(true);
        },
        onMove ({ deltaX: deltaX , deltaY: deltaY , pointerType: pointerType , shiftKey: shiftKey  }) {
            let { incrementX: incrementX , decrementX: decrementX , incrementY: incrementY , decrementY: decrementY , xChannelPageStep: xChannelPageStep , xChannelStep: xChannelStep , yChannelPageStep: yChannelPageStep , yChannelStep: yChannelStep , getThumbPosition: getThumbPosition , setColorFromPoint: setColorFromPoint  } = stateRef.current;
            if (currentPosition.current == null) currentPosition.current = getThumbPosition();
            let { width: width , height: height  } = containerRef.current.getBoundingClientRect();
            if (pointerType === 'keyboard') {
                let deltaXValue = shiftKey && xChannelPageStep > xChannelStep ? xChannelPageStep : xChannelStep;
                let deltaYValue = shiftKey && yChannelPageStep > yChannelStep ? yChannelPageStep : yChannelStep;
                if (deltaX > 0 && direction === 'ltr' || deltaX < 0 && direction === 'rtl') incrementX(deltaXValue);
                else if (deltaX < 0 && direction === 'ltr' || deltaX > 0 && direction === 'rtl') decrementX(deltaXValue);
                else if (deltaY > 0) decrementY(deltaYValue);
                else if (deltaY < 0) incrementY(deltaYValue);
                // set the focused input based on which axis has the greater delta
                focusedInputRef.current = (deltaX !== 0 || deltaY !== 0) && Math.abs(deltaY) > Math.abs(deltaX) ? inputYRef.current : inputXRef.current;
            } else {
                currentPosition.current.x += (direction === 'rtl' ? -1 : 1) * deltaX / width;
                currentPosition.current.y += deltaY / height;
                setColorFromPoint(currentPosition.current.x, currentPosition.current.y);
            }
        },
        onMoveEnd () {
            isOnColorArea.current = undefined;
            stateRef.current.setDragging(false);
            focusInput(focusedInputRef.current ? focusedInputRef : inputXRef);
            focusedInputRef.current = undefined;
        }
    };
    let { moveProps: movePropsThumb  } = $7KHxM$useMove(moveHandler);
    let currentPointer = $7KHxM$useRef(undefined);
    let isOnColorArea = $7KHxM$useRef(false);
    let { moveProps: movePropsContainer  } = $7KHxM$useMove({
        onMoveStart () {
            if (isOnColorArea.current) moveHandler.onMoveStart();
        },
        onMove (e) {
            if (isOnColorArea.current) moveHandler.onMove(e);
        },
        onMoveEnd () {
            if (isOnColorArea.current) moveHandler.onMoveEnd();
        }
    });
    let onThumbDown = (id)=>{
        if (!state.isDragging) {
            currentPointer.current = id;
            focusInput();
            state.setDragging(true);
            if (typeof PointerEvent !== 'undefined') addGlobalListener(window, 'pointerup', onThumbUp, false);
            else {
                addGlobalListener(window, 'mouseup', onThumbUp, false);
                addGlobalListener(window, 'touchend', onThumbUp, false);
            }
        }
    };
    let onThumbUp = (e)=>{
        var ref;
        var _pointerId;
        let id = (_pointerId = e.pointerId) !== null && _pointerId !== void 0 ? _pointerId : (ref = e.changedTouches) === null || ref === void 0 ? void 0 : ref[0].identifier;
        if (id === currentPointer.current) {
            focusInput();
            state.setDragging(false);
            currentPointer.current = undefined;
            isOnColorArea.current = false;
            if (typeof PointerEvent !== 'undefined') removeGlobalListener(window, 'pointerup', onThumbUp, false);
            else {
                removeGlobalListener(window, 'mouseup', onThumbUp, false);
                removeGlobalListener(window, 'touchend', onThumbUp, false);
            }
        }
    };
    let onColorAreaDown = (colorArea, id, clientX, clientY)=>{
        let rect = colorArea.getBoundingClientRect();
        let { width: width , height: height  } = rect;
        let x = (clientX - rect.x) / width;
        let y = (clientY - rect.y) / height;
        if (direction === 'rtl') x = 1 - x;
        if (x >= 0 && x <= 1 && y >= 0 && y <= 1 && !state.isDragging && currentPointer.current === undefined) {
            isOnColorArea.current = true;
            currentPointer.current = id;
            state.setColorFromPoint(x, y);
            focusInput();
            state.setDragging(true);
            if (typeof PointerEvent !== 'undefined') addGlobalListener(window, 'pointerup', onColorAreaUp, false);
            else {
                addGlobalListener(window, 'mouseup', onColorAreaUp, false);
                addGlobalListener(window, 'touchend', onColorAreaUp, false);
            }
        }
    };
    let onColorAreaUp = (e)=>{
        var ref;
        var _pointerId;
        let id = (_pointerId = e.pointerId) !== null && _pointerId !== void 0 ? _pointerId : (ref = e.changedTouches) === null || ref === void 0 ? void 0 : ref[0].identifier;
        if (isOnColorArea.current && id === currentPointer.current) {
            isOnColorArea.current = false;
            currentPointer.current = undefined;
            state.setDragging(false);
            focusInput();
            if (typeof PointerEvent !== 'undefined') removeGlobalListener(window, 'pointerup', onColorAreaUp, false);
            else {
                removeGlobalListener(window, 'mouseup', onColorAreaUp, false);
                removeGlobalListener(window, 'touchend', onColorAreaUp, false);
            }
        }
    };
    let colorAreaInteractions = isDisabled ? {
    } : $7KHxM$mergeProps({
        ...typeof PointerEvent !== 'undefined' ? {
            onPointerDown: (e)=>{
                if (e.pointerType === 'mouse' && (e.button !== 0 || e.altKey || e.ctrlKey || e.metaKey)) return;
                onColorAreaDown(e.currentTarget, e.pointerId, e.clientX, e.clientY);
            }
        } : {
            onMouseDown: (e)=>{
                if (e.button !== 0 || e.altKey || e.ctrlKey || e.metaKey) return;
                onColorAreaDown(e.currentTarget, undefined, e.clientX, e.clientY);
            },
            onTouchStart: (e)=>{
                onColorAreaDown(e.currentTarget, e.changedTouches[0].identifier, e.changedTouches[0].clientX, e.changedTouches[0].clientY);
            }
        }
    }, movePropsContainer);
    let thumbInteractions = isDisabled ? {
    } : $7KHxM$mergeProps({
        ...typeof PointerEvent !== 'undefined' ? {
            onPointerDown: (e)=>{
                if (e.pointerType === 'mouse' && (e.button !== 0 || e.altKey || e.ctrlKey || e.metaKey)) return;
                onThumbDown(e.pointerId);
            }
        } : {
            onMouseDown: (e)=>{
                if (e.button !== 0 || e.altKey || e.ctrlKey || e.metaKey) return;
                onThumbDown(undefined);
            },
            onTouchStart: (e)=>{
                onThumbDown(e.changedTouches[0].identifier);
            }
        }
    }, keyboardProps, movePropsThumb);
    let isMobile = $7KHxM$isIOS() || $7KHxM$isAndroid();
    let xInputLabellingProps = $7KHxM$useLabels({
        ...props,
        'aria-label': isMobile ? state.value.getChannelName(xChannel, locale) : formatMessage('x/y', {
            x: state.value.getChannelName(xChannel, locale),
            y: state.value.getChannelName(yChannel, locale)
        })
    });
    let yInputLabellingProps = $7KHxM$useLabels({
        ...props,
        'aria-label': isMobile ? state.value.getChannelName(yChannel, locale) : formatMessage('x/y', {
            x: state.value.getChannelName(xChannel, locale),
            y: state.value.getChannelName(yChannel, locale)
        })
    });
    let colorAriaLabellingProps = $7KHxM$useLabels(props);
    let getValueTitle = ()=>{
        const channels = state.value.getColorChannels();
        const colorNamesAndValues = [];
        channels.forEach((channel)=>colorNamesAndValues.push(formatMessage('colorNameAndValue', {
                name: state.value.getChannelName(channel, locale),
                value: state.value.formatChannelValue(channel, locale)
            }))
        );
        return colorNamesAndValues.length ? colorNamesAndValues.join(', ') : null;
    };
    let ariaRoleDescription = isMobile ? null : formatMessage('twoDimensionalSlider');
    let { visuallyHiddenProps: visuallyHiddenProps  } = $7KHxM$useVisuallyHidden({
        style: {
            opacity: '0.0001',
            width: '100%',
            height: '100%',
            pointerEvents: 'none'
        }
    });
    let { colorAreaStyleProps: colorAreaStyleProps , gradientStyleProps: gradientStyleProps , thumbStyleProps: thumbStyleProps  } = $40297c24c53588e6$export$dd62420467d245ca({
        direction: direction,
        state: state,
        xChannel: xChannel,
        zChannel: zChannel,
        isDisabled: props.isDisabled
    });
    return {
        colorAreaProps: {
            ...colorAriaLabellingProps,
            ...colorAreaInteractions,
            ...colorAreaStyleProps,
            role: 'group'
        },
        gradientProps: {
            ...gradientStyleProps,
            role: 'presentation'
        },
        thumbProps: {
            ...thumbInteractions,
            ...thumbStyleProps,
            role: 'presentation'
        },
        xInputProps: {
            ...xInputLabellingProps,
            ...visuallyHiddenProps,
            type: 'range',
            min: state.value.getChannelRange(xChannel).minValue,
            max: state.value.getChannelRange(xChannel).maxValue,
            step: xChannelStep1,
            'aria-roledescription': ariaRoleDescription,
            'aria-valuetext': isMobile ? formatMessage('colorNameAndValue', {
                name: state.value.getChannelName(xChannel, locale),
                value: state.value.formatChannelValue(xChannel, locale)
            }) : [
                formatMessage('colorNameAndValue', {
                    name: state.value.getChannelName(xChannel, locale),
                    value: state.value.formatChannelValue(xChannel, locale)
                }),
                formatMessage('colorNameAndValue', {
                    name: state.value.getChannelName(yChannel, locale),
                    value: state.value.formatChannelValue(yChannel, locale)
                })
            ].join(', '),
            title: getValueTitle(),
            disabled: isDisabled,
            value: state.value.getChannelValue(xChannel),
            tabIndex: 0,
            onChange: (e)=>{
                state.setXValue(parseFloat(e.target.value));
            }
        },
        yInputProps: {
            ...yInputLabellingProps,
            ...visuallyHiddenProps,
            type: 'range',
            min: state.value.getChannelRange(yChannel).minValue,
            max: state.value.getChannelRange(yChannel).maxValue,
            step: yChannelStep1,
            'aria-roledescription': ariaRoleDescription,
            'aria-valuetext': isMobile ? formatMessage('colorNameAndValue', {
                name: state.value.getChannelName(yChannel, locale),
                value: state.value.formatChannelValue(yChannel, locale)
            }) : [
                formatMessage('colorNameAndValue', {
                    name: state.value.getChannelName(yChannel, locale),
                    value: state.value.formatChannelValue(yChannel, locale)
                }),
                formatMessage('colorNameAndValue', {
                    name: state.value.getChannelName(xChannel, locale),
                    value: state.value.formatChannelValue(xChannel, locale)
                })
            ].join(', '),
            'aria-orientation': 'vertical',
            title: getValueTitle(),
            disabled: isDisabled,
            value: state.value.getChannelValue(yChannel),
            tabIndex: -1,
            onChange: (e)=>{
                state.setYValue(parseFloat(e.target.value));
            }
        }
    };
}


var $40af666d6c251e36$exports = {};

$parcel$export($40af666d6c251e36$exports, "useColorSlider", () => $40af666d6c251e36$export$106b7a4e66508f66);



function $40af666d6c251e36$export$106b7a4e66508f66(props, state) {
    let { trackRef: trackRef , inputRef: inputRef , orientation: orientation , channel: channel , 'aria-label': ariaLabel  } = props;
    let { locale: locale , direction: direction  } = $7KHxM$useLocale();
    // Provide a default aria-label if there is no other label provided.
    if (!props.label && !ariaLabel && !props['aria-labelledby']) ariaLabel = state.value.getChannelName(channel, locale);
    // @ts-ignore - ignore unused incompatible props
    let { groupProps: groupProps , trackProps: trackProps , labelProps: labelProps , outputProps: outputProps  } = $7KHxM$useSlider({
        ...props,
        'aria-label': ariaLabel
    }, state, trackRef);
    let { inputProps: inputProps , thumbProps: thumbProps  } = $7KHxM$useSliderThumb({
        index: 0,
        orientation: orientation,
        isDisabled: props.isDisabled,
        trackRef: trackRef,
        inputRef: inputRef
    }, state);
    let generateBackground = ()=>{
        let value = state.getDisplayColor();
        let to;
        if (orientation === 'vertical') to = 'top';
        else if (direction === 'ltr') to = 'right';
        else to = 'left';
        switch(channel){
            case 'hue':
                return `linear-gradient(to ${to}, rgb(255, 0, 0) 0%, rgb(255, 255, 0) 17%, rgb(0, 255, 0) 33%, rgb(0, 255, 255) 50%, rgb(0, 0, 255) 67%, rgb(255, 0, 255) 83%, rgb(255, 0, 0) 100%)`;
            case 'lightness':
                {
                    // We have to add an extra color stop in the middle so that the hue shows up at all.
                    // Otherwise it will always just be black to white.
                    let min = state.getThumbMinValue(0);
                    let max = state.getThumbMaxValue(0);
                    let start = value.withChannelValue(channel, min).toString('css');
                    let middle = value.withChannelValue(channel, (max - min) / 2).toString('css');
                    let end = value.withChannelValue(channel, max).toString('css');
                    return `linear-gradient(to ${to}, ${start}, ${middle}, ${end})`;
                }
            case 'saturation':
            case 'brightness':
            case 'red':
            case 'green':
            case 'blue':
            case 'alpha':
                {
                    let start = value.withChannelValue(channel, state.getThumbMinValue(0)).toString('css');
                    let end = value.withChannelValue(channel, state.getThumbMaxValue(0)).toString('css');
                    return `linear-gradient(to ${to}, ${start}, ${end})`;
                }
            default:
                throw new Error('Unknown color channel: ' + channel);
        }
    };
    let thumbPosition = state.getThumbPercent(0);
    if (orientation === 'vertical' || direction === 'rtl') thumbPosition = 1 - thumbPosition;
    return {
        trackProps: {
            ...$7KHxM$mergeProps(groupProps, trackProps),
            style: {
                position: 'relative',
                touchAction: 'none',
                background: generateBackground()
            }
        },
        inputProps: inputProps,
        thumbProps: {
            ...thumbProps,
            style: {
                touchAction: 'none',
                position: 'absolute',
                [orientation === 'vertical' ? 'top' : 'left']: `${thumbPosition * 100}%`,
                transform: 'translate(-50%, -50%)'
            }
        },
        labelProps: labelProps,
        outputProps: outputProps
    };
}


var $b4a0a4fdc900495e$exports = {};

$parcel$export($b4a0a4fdc900495e$exports, "useColorWheel", () => $b4a0a4fdc900495e$export$9064ff4e44b3729a);




function $b4a0a4fdc900495e$export$9064ff4e44b3729a(props, state, inputRef) {
    let { isDisabled: isDisabled , innerRadius: innerRadius , outerRadius: outerRadius , 'aria-label': ariaLabel  } = props;
    let { addGlobalListener: addGlobalListener , removeGlobalListener: removeGlobalListener  } = $7KHxM$useGlobalListeners();
    let thumbRadius = (innerRadius + outerRadius) / 2;
    let focusInput = $7KHxM$useCallback(()=>{
        if (inputRef.current) $7KHxM$focusWithoutScrolling(inputRef.current);
    }, [
        inputRef
    ]);
    let stateRef = $7KHxM$useRef(null);
    stateRef.current = state;
    let currentPosition = $7KHxM$useRef(null);
    let { keyboardProps: keyboardProps  } = $7KHxM$useKeyboard({
        onKeyDown (e) {
            // these are the cases that useMove doesn't handle
            if (!/^(PageUp|PageDown)$/.test(e.key)) {
                e.continuePropagation();
                return;
            }
            // same handling as useMove, don't need to stop propagation, useKeyboard will do that for us
            e.preventDefault();
            // remember to set this and unset it so that onChangeEnd is fired
            stateRef.current.setDragging(true);
            switch(e.key){
                case 'PageUp':
                    e.preventDefault();
                    state.increment(stateRef.current.pageStep);
                    break;
                case 'PageDown':
                    e.preventDefault();
                    state.decrement(stateRef.current.pageStep);
                    break;
            }
            stateRef.current.setDragging(false);
        }
    });
    let moveHandler = {
        onMoveStart () {
            currentPosition.current = null;
            state.setDragging(true);
        },
        onMove ({ deltaX: deltaX , deltaY: deltaY , pointerType: pointerType , shiftKey: shiftKey  }) {
            if (currentPosition.current == null) currentPosition.current = stateRef.current.getThumbPosition(thumbRadius);
            currentPosition.current.x += deltaX;
            currentPosition.current.y += deltaY;
            if (pointerType === 'keyboard') {
                if (deltaX > 0 || deltaY < 0) state.increment(shiftKey ? stateRef.current.pageStep : stateRef.current.step);
                else if (deltaX < 0 || deltaY > 0) state.decrement(shiftKey ? stateRef.current.pageStep : stateRef.current.step);
            } else stateRef.current.setHueFromPoint(currentPosition.current.x, currentPosition.current.y, thumbRadius);
        },
        onMoveEnd () {
            isOnTrack.current = undefined;
            state.setDragging(false);
            focusInput();
        }
    };
    let { moveProps: movePropsThumb  } = $7KHxM$useMove(moveHandler);
    let currentPointer = $7KHxM$useRef(undefined);
    let isOnTrack = $7KHxM$useRef(false);
    let { moveProps: movePropsContainer  } = $7KHxM$useMove({
        onMoveStart () {
            if (isOnTrack.current) moveHandler.onMoveStart();
        },
        onMove (e) {
            if (isOnTrack.current) moveHandler.onMove(e);
        },
        onMoveEnd () {
            if (isOnTrack.current) moveHandler.onMoveEnd();
        }
    });
    let onThumbDown = (id)=>{
        if (!state.isDragging) {
            currentPointer.current = id;
            focusInput();
            state.setDragging(true);
            if (typeof PointerEvent !== 'undefined') addGlobalListener(window, 'pointerup', onThumbUp, false);
            else {
                addGlobalListener(window, 'mouseup', onThumbUp, false);
                addGlobalListener(window, 'touchend', onThumbUp, false);
            }
        }
    };
    let onThumbUp = (e)=>{
        var ref;
        var _pointerId;
        let id = (_pointerId = e.pointerId) !== null && _pointerId !== void 0 ? _pointerId : (ref = e.changedTouches) === null || ref === void 0 ? void 0 : ref[0].identifier;
        if (id === currentPointer.current) {
            focusInput();
            state.setDragging(false);
            currentPointer.current = undefined;
            isOnTrack.current = false;
            if (typeof PointerEvent !== 'undefined') removeGlobalListener(window, 'pointerup', onThumbUp, false);
            else {
                removeGlobalListener(window, 'mouseup', onThumbUp, false);
                removeGlobalListener(window, 'touchend', onThumbUp, false);
            }
        }
    };
    let onTrackDown = (track, id, pageX, pageY)=>{
        let rect = track.getBoundingClientRect();
        let x = pageX - rect.x - rect.width / 2;
        let y = pageY - rect.y - rect.height / 2;
        let radius = Math.sqrt(x * x + y * y);
        if (innerRadius < radius && radius < outerRadius && !state.isDragging && currentPointer.current === undefined) {
            isOnTrack.current = true;
            currentPointer.current = id;
            stateRef.current.setHueFromPoint(x, y, radius);
            focusInput();
            state.setDragging(true);
            if (typeof PointerEvent !== 'undefined') addGlobalListener(window, 'pointerup', onTrackUp, false);
            else {
                addGlobalListener(window, 'mouseup', onTrackUp, false);
                addGlobalListener(window, 'touchend', onTrackUp, false);
            }
        }
    };
    let onTrackUp = (e)=>{
        var ref;
        var _pointerId;
        let id = (_pointerId = e.pointerId) !== null && _pointerId !== void 0 ? _pointerId : (ref = e.changedTouches) === null || ref === void 0 ? void 0 : ref[0].identifier;
        if (isOnTrack.current && id === currentPointer.current) {
            isOnTrack.current = false;
            currentPointer.current = undefined;
            state.setDragging(false);
            focusInput();
            if (typeof PointerEvent !== 'undefined') removeGlobalListener(window, 'pointerup', onTrackUp, false);
            else {
                removeGlobalListener(window, 'mouseup', onTrackUp, false);
                removeGlobalListener(window, 'touchend', onTrackUp, false);
            }
        }
    };
    let trackInteractions = isDisabled ? {
    } : $7KHxM$mergeProps({
        ...typeof PointerEvent !== 'undefined' ? {
            onPointerDown: (e)=>{
                if (e.pointerType === 'mouse' && (e.button !== 0 || e.altKey || e.ctrlKey || e.metaKey)) return;
                onTrackDown(e.currentTarget, e.pointerId, e.clientX, e.clientY);
            }
        } : {
            onMouseDown: (e)=>{
                if (e.button !== 0 || e.altKey || e.ctrlKey || e.metaKey) return;
                onTrackDown(e.currentTarget, undefined, e.clientX, e.clientY);
            },
            onTouchStart: (e)=>{
                onTrackDown(e.currentTarget, e.changedTouches[0].identifier, e.changedTouches[0].clientX, e.changedTouches[0].clientY);
            }
        }
    }, movePropsContainer);
    let thumbInteractions = isDisabled ? {
    } : $7KHxM$mergeProps({
        onMouseDown: (e)=>{
            if (e.button !== 0 || e.altKey || e.ctrlKey || e.metaKey) return;
            onThumbDown(undefined);
        },
        onPointerDown: (e)=>{
            if (e.pointerType === 'mouse' && (e.button !== 0 || e.altKey || e.ctrlKey || e.metaKey)) return;
            onThumbDown(e.pointerId);
        },
        onTouchStart: (e)=>{
            onThumbDown(e.changedTouches[0].identifier);
        }
    }, keyboardProps, movePropsThumb);
    let { x: x1 , y: y1  } = state.getThumbPosition(thumbRadius);
    // Provide a default aria-label if none is given
    let { locale: locale  } = $7KHxM$useLocale();
    if (ariaLabel == null && props['aria-labelledby'] == null) ariaLabel = state.value.getChannelName('hue', locale);
    let inputLabellingProps = $7KHxM$useLabels({
        ...props,
        'aria-label': ariaLabel
    });
    let { minValue: minValue , maxValue: maxValue , step: step  } = state.value.getChannelRange('hue');
    return {
        trackProps: {
            ...trackInteractions,
            style: {
                position: 'relative',
                touchAction: 'none',
                width: outerRadius * 2,
                height: outerRadius * 2,
                background: `
          conic-gradient(
            from 90deg,
            hsl(0, 100%, 50%),
            hsl(30, 100%, 50%),
            hsl(60, 100%, 50%),
            hsl(90, 100%, 50%),
            hsl(120, 100%, 50%),
            hsl(150, 100%, 50%),
            hsl(180, 100%, 50%),
            hsl(210, 100%, 50%),
            hsl(240, 100%, 50%),
            hsl(270, 100%, 50%),
            hsl(300, 100%, 50%),
            hsl(330, 100%, 50%),
            hsl(360, 100%, 50%)
          )
        `,
                clipPath: `path(evenodd, "${$b4a0a4fdc900495e$var$circlePath(outerRadius, outerRadius, outerRadius)} ${$b4a0a4fdc900495e$var$circlePath(outerRadius, outerRadius, innerRadius)}")`
            }
        },
        thumbProps: {
            ...thumbInteractions,
            style: {
                position: 'absolute',
                left: '50%',
                top: '50%',
                transform: `translate(calc(${x1}px - 50%), calc(${y1}px - 50%))`,
                touchAction: 'none'
            }
        },
        inputProps: $7KHxM$mergeProps(inputLabellingProps, {
            type: 'range',
            min: String(minValue),
            max: String(maxValue),
            step: String(step),
            'aria-valuetext': state.value.formatChannelValue('hue', locale),
            disabled: isDisabled,
            value: `${state.value.getChannelValue('hue')}`,
            onChange: (e)=>{
                state.setHue(parseFloat(e.target.value));
            }
        })
    };
}
// Creates an SVG path string for a circle.
function $b4a0a4fdc900495e$var$circlePath(cx, cy, r) {
    return `M ${cx}, ${cy} m ${-r}, 0 a ${r}, ${r}, 0, 1, 0, ${r * 2}, 0 a ${r}, ${r}, 0, 1, 0 ${-r * 2}, 0`;
}


var $f6896b05b2ecad12$exports = {};

$parcel$export($f6896b05b2ecad12$exports, "useColorField", () => $f6896b05b2ecad12$export$77e32ca575a28fdf);





function $f6896b05b2ecad12$export$77e32ca575a28fdf(props, state, ref) {
    let { isDisabled: isDisabled , isReadOnly: isReadOnly , isRequired: isRequired  } = props;
    let { colorValue: colorValue , inputValue: inputValue , commit: commit , increment: increment , decrement: decrement , incrementToMax: incrementToMax , decrementToMin: decrementToMin  } = state;
    let inputId = $7KHxM$useId();
    let { spinButtonProps: spinButtonProps  } = $7KHxM$useSpinButton({
        isDisabled: isDisabled,
        isReadOnly: isReadOnly,
        isRequired: isRequired,
        maxValue: 16777215,
        minValue: 0,
        onIncrement: increment,
        onIncrementToMax: incrementToMax,
        onDecrement: decrement,
        onDecrementToMin: decrementToMin,
        value: colorValue ? colorValue.toHexInt() : undefined,
        textValue: colorValue ? colorValue.toString('hex') : undefined
    });
    let [focusWithin, setFocusWithin] = $7KHxM$useState(false);
    let { focusWithinProps: focusWithinProps  } = $7KHxM$useFocusWithin({
        isDisabled: isDisabled,
        onFocusWithinChange: setFocusWithin
    });
    let onWheel = $7KHxM$useCallback((e)=>{
        if (Math.abs(e.deltaY) <= Math.abs(e.deltaX)) return;
        if (e.deltaY > 0) increment();
        else if (e.deltaY < 0) decrement();
    }, [
        decrement,
        increment
    ]);
    // If the input isn't supposed to receive input, disable scrolling.
    let scrollingDisabled = isDisabled || isReadOnly || !focusWithin;
    $7KHxM$useScrollWheel({
        onScroll: onWheel,
        isDisabled: scrollingDisabled
    }, ref);
    let onChange = (value)=>{
        state.setInputValue(value);
    };
    let { labelProps: labelProps , inputProps: inputProps  } = $7KHxM$useFormattedTextField($7KHxM$mergeProps(props, {
        id: inputId,
        value: inputValue,
        defaultValue: undefined,
        type: 'text',
        autoComplete: 'off',
        onChange: onChange
    }), state, ref);
    return {
        labelProps: labelProps,
        inputProps: $7KHxM$mergeProps(inputProps, spinButtonProps, focusWithinProps, {
            role: 'textbox',
            'aria-valuemax': null,
            'aria-valuemin': null,
            'aria-valuenow': null,
            'aria-valuetext': null,
            autoCorrect: 'off',
            spellCheck: 'false',
            onBlur: commit
        })
    };
}




export {$60bd7d6e45dcddfa$export$2f92a7a615a014f6 as useColorArea, $40af666d6c251e36$export$106b7a4e66508f66 as useColorSlider, $b4a0a4fdc900495e$export$9064ff4e44b3729a as useColorWheel, $f6896b05b2ecad12$export$77e32ca575a28fdf as useColorField};
//# sourceMappingURL=module.js.map
