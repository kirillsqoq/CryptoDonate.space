import {
  Component,
  FirebaseError,
  LogLevel,
  Logger,
  SDK_VERSION,
  _getProvider,
  _registerComponent,
  _removeServiceInstance,
  createMockUserToken,
  deepEqual,
  getApp,
  getModularInstance,
  getUA,
  isBrowserExtension,
  isElectron,
  isIE,
  isIndexedDBAvailable,
  isMobileCordova,
  isReactNative,
  isSafari,
  isUWP,
  registerVersion
} from "./chunk-A5O3PWYO.js";

// node_modules/@firebase/webchannel-wrapper/dist/index.esm2017.js
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
var esm = {};
var k;
var goog = goog || {};
var l = commonjsGlobal || self;
function aa() {
}
function ba(a) {
  var b = typeof a;
  b = b != "object" ? b : a ? Array.isArray(a) ? "array" : b : "null";
  return b == "array" || b == "object" && typeof a.length == "number";
}
function p(a) {
  var b = typeof a;
  return b == "object" && a != null || b == "function";
}
function da(a) {
  return Object.prototype.hasOwnProperty.call(a, ea) && a[ea] || (a[ea] = ++fa);
}
var ea = "closure_uid_" + (1e9 * Math.random() >>> 0);
var fa = 0;
function ha(a, b, c) {
  return a.call.apply(a.bind, arguments);
}
function ia(a, b, c) {
  if (!a)
    throw Error();
  if (2 < arguments.length) {
    var d = Array.prototype.slice.call(arguments, 2);
    return function() {
      var e = Array.prototype.slice.call(arguments);
      Array.prototype.unshift.apply(e, d);
      return a.apply(b, e);
    };
  }
  return function() {
    return a.apply(b, arguments);
  };
}
function q(a, b, c) {
  Function.prototype.bind && Function.prototype.bind.toString().indexOf("native code") != -1 ? q = ha : q = ia;
  return q.apply(null, arguments);
}
function ja(a, b) {
  var c = Array.prototype.slice.call(arguments, 1);
  return function() {
    var d = c.slice();
    d.push.apply(d, arguments);
    return a.apply(this, d);
  };
}
function t(a, b) {
  function c() {
  }
  c.prototype = b.prototype;
  a.Z = b.prototype;
  a.prototype = new c();
  a.prototype.constructor = a;
  a.Vb = function(d, e, f) {
    for (var h = Array(arguments.length - 2), n = 2; n < arguments.length; n++)
      h[n - 2] = arguments[n];
    return b.prototype[e].apply(d, h);
  };
}
function v() {
  this.s = this.s;
  this.o = this.o;
}
var ka = 0;
var la = {};
v.prototype.s = false;
v.prototype.na = function() {
  if (!this.s && (this.s = true, this.M(), ka != 0)) {
    var a = da(this);
    delete la[a];
  }
};
v.prototype.M = function() {
  if (this.o)
    for (; this.o.length; )
      this.o.shift()();
};
var ma = Array.prototype.indexOf ? function(a, b) {
  return Array.prototype.indexOf.call(a, b, void 0);
} : function(a, b) {
  if (typeof a === "string")
    return typeof b !== "string" || b.length != 1 ? -1 : a.indexOf(b, 0);
  for (let c = 0; c < a.length; c++)
    if (c in a && a[c] === b)
      return c;
  return -1;
};
var na = Array.prototype.forEach ? function(a, b, c) {
  Array.prototype.forEach.call(a, b, c);
} : function(a, b, c) {
  const d = a.length, e = typeof a === "string" ? a.split("") : a;
  for (let f = 0; f < d; f++)
    f in e && b.call(c, e[f], f, a);
};
function oa(a) {
  a: {
    var b = pa;
    const c = a.length, d = typeof a === "string" ? a.split("") : a;
    for (let e = 0; e < c; e++)
      if (e in d && b.call(void 0, d[e], e, a)) {
        b = e;
        break a;
      }
    b = -1;
  }
  return 0 > b ? null : typeof a === "string" ? a.charAt(b) : a[b];
}
function qa(a) {
  return Array.prototype.concat.apply([], arguments);
}
function ra(a) {
  const b = a.length;
  if (0 < b) {
    const c = Array(b);
    for (let d = 0; d < b; d++)
      c[d] = a[d];
    return c;
  }
  return [];
}
function sa(a) {
  return /^[\s\xa0]*$/.test(a);
}
var ta = String.prototype.trim ? function(a) {
  return a.trim();
} : function(a) {
  return /^[\s\xa0]*([\s\S]*?)[\s\xa0]*$/.exec(a)[1];
};
function w(a, b) {
  return a.indexOf(b) != -1;
}
function ua(a, b) {
  return a < b ? -1 : a > b ? 1 : 0;
}
var x;
a: {
  va2 = l.navigator;
  if (va2) {
    wa2 = va2.userAgent;
    if (wa2) {
      x = wa2;
      break a;
    }
  }
  x = "";
}
var va2;
var wa2;
function xa(a, b, c) {
  for (const d in a)
    b.call(c, a[d], d, a);
}
function ya(a) {
  const b = {};
  for (const c in a)
    b[c] = a[c];
  return b;
}
var za = "constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" ");
function Aa(a, b) {
  let c, d;
  for (let e = 1; e < arguments.length; e++) {
    d = arguments[e];
    for (c in d)
      a[c] = d[c];
    for (let f = 0; f < za.length; f++)
      c = za[f], Object.prototype.hasOwnProperty.call(d, c) && (a[c] = d[c]);
  }
}
function Ca(a) {
  Ca[" "](a);
  return a;
}
Ca[" "] = aa;
function Fa(a) {
  var b = Ga;
  return Object.prototype.hasOwnProperty.call(b, 9) ? b[9] : b[9] = a(9);
}
var Ha = w(x, "Opera");
var y = w(x, "Trident") || w(x, "MSIE");
var Ia = w(x, "Edge");
var Ja = Ia || y;
var Ka = w(x, "Gecko") && !(w(x.toLowerCase(), "webkit") && !w(x, "Edge")) && !(w(x, "Trident") || w(x, "MSIE")) && !w(x, "Edge");
var La = w(x.toLowerCase(), "webkit") && !w(x, "Edge");
function Ma() {
  var a = l.document;
  return a ? a.documentMode : void 0;
}
var Na;
a: {
  Oa2 = "", Pa2 = function() {
    var a = x;
    if (Ka)
      return /rv:([^\);]+)(\)|;)/.exec(a);
    if (Ia)
      return /Edge\/([\d\.]+)/.exec(a);
    if (y)
      return /\b(?:MSIE|rv)[: ]([^\);]+)(\)|;)/.exec(a);
    if (La)
      return /WebKit\/(\S+)/.exec(a);
    if (Ha)
      return /(?:Version)[ \/]?(\S+)/.exec(a);
  }();
  Pa2 && (Oa2 = Pa2 ? Pa2[1] : "");
  if (y) {
    Qa2 = Ma();
    if (Qa2 != null && Qa2 > parseFloat(Oa2)) {
      Na = String(Qa2);
      break a;
    }
  }
  Na = Oa2;
}
var Oa2;
var Pa2;
var Qa2;
var Ga = {};
function Ra() {
  return Fa(function() {
    let a = 0;
    const b = ta(String(Na)).split("."), c = ta("9").split("."), d = Math.max(b.length, c.length);
    for (let h = 0; a == 0 && h < d; h++) {
      var e = b[h] || "", f = c[h] || "";
      do {
        e = /(\d*)(\D*)(.*)/.exec(e) || ["", "", "", ""];
        f = /(\d*)(\D*)(.*)/.exec(f) || ["", "", "", ""];
        if (e[0].length == 0 && f[0].length == 0)
          break;
        a = ua(e[1].length == 0 ? 0 : parseInt(e[1], 10), f[1].length == 0 ? 0 : parseInt(f[1], 10)) || ua(e[2].length == 0, f[2].length == 0) || ua(e[2], f[2]);
        e = e[3];
        f = f[3];
      } while (a == 0);
    }
    return 0 <= a;
  });
}
var Sa;
if (l.document && y) {
  Ta2 = Ma();
  Sa = Ta2 ? Ta2 : parseInt(Na, 10) || void 0;
} else
  Sa = void 0;
var Ta2;
var Ua = Sa;
var Va = function() {
  if (!l.addEventListener || !Object.defineProperty)
    return false;
  var a = false, b = Object.defineProperty({}, "passive", { get: function() {
    a = true;
  } });
  try {
    l.addEventListener("test", aa, b), l.removeEventListener("test", aa, b);
  } catch (c) {
  }
  return a;
}();
function z(a, b) {
  this.type = a;
  this.g = this.target = b;
  this.defaultPrevented = false;
}
z.prototype.h = function() {
  this.defaultPrevented = true;
};
function A(a, b) {
  z.call(this, a ? a.type : "");
  this.relatedTarget = this.g = this.target = null;
  this.button = this.screenY = this.screenX = this.clientY = this.clientX = 0;
  this.key = "";
  this.metaKey = this.shiftKey = this.altKey = this.ctrlKey = false;
  this.state = null;
  this.pointerId = 0;
  this.pointerType = "";
  this.i = null;
  if (a) {
    var c = this.type = a.type, d = a.changedTouches && a.changedTouches.length ? a.changedTouches[0] : null;
    this.target = a.target || a.srcElement;
    this.g = b;
    if (b = a.relatedTarget) {
      if (Ka) {
        a: {
          try {
            Ca(b.nodeName);
            var e = true;
            break a;
          } catch (f) {
          }
          e = false;
        }
        e || (b = null);
      }
    } else
      c == "mouseover" ? b = a.fromElement : c == "mouseout" && (b = a.toElement);
    this.relatedTarget = b;
    d ? (this.clientX = d.clientX !== void 0 ? d.clientX : d.pageX, this.clientY = d.clientY !== void 0 ? d.clientY : d.pageY, this.screenX = d.screenX || 0, this.screenY = d.screenY || 0) : (this.clientX = a.clientX !== void 0 ? a.clientX : a.pageX, this.clientY = a.clientY !== void 0 ? a.clientY : a.pageY, this.screenX = a.screenX || 0, this.screenY = a.screenY || 0);
    this.button = a.button;
    this.key = a.key || "";
    this.ctrlKey = a.ctrlKey;
    this.altKey = a.altKey;
    this.shiftKey = a.shiftKey;
    this.metaKey = a.metaKey;
    this.pointerId = a.pointerId || 0;
    this.pointerType = typeof a.pointerType === "string" ? a.pointerType : Wa[a.pointerType] || "";
    this.state = a.state;
    this.i = a;
    a.defaultPrevented && A.Z.h.call(this);
  }
}
t(A, z);
var Wa = { 2: "touch", 3: "pen", 4: "mouse" };
A.prototype.h = function() {
  A.Z.h.call(this);
  var a = this.i;
  a.preventDefault ? a.preventDefault() : a.returnValue = false;
};
var B = "closure_listenable_" + (1e6 * Math.random() | 0);
var Xa = 0;
function Ya(a, b, c, d, e) {
  this.listener = a;
  this.proxy = null;
  this.src = b;
  this.type = c;
  this.capture = !!d;
  this.ia = e;
  this.key = ++Xa;
  this.ca = this.fa = false;
}
function Za(a) {
  a.ca = true;
  a.listener = null;
  a.proxy = null;
  a.src = null;
  a.ia = null;
}
function $a(a) {
  this.src = a;
  this.g = {};
  this.h = 0;
}
$a.prototype.add = function(a, b, c, d, e) {
  var f = a.toString();
  a = this.g[f];
  a || (a = this.g[f] = [], this.h++);
  var h = ab(a, b, d, e);
  -1 < h ? (b = a[h], c || (b.fa = false)) : (b = new Ya(b, this.src, f, !!d, e), b.fa = c, a.push(b));
  return b;
};
function bb(a, b) {
  var c = b.type;
  if (c in a.g) {
    var d = a.g[c], e = ma(d, b), f;
    (f = 0 <= e) && Array.prototype.splice.call(d, e, 1);
    f && (Za(b), a.g[c].length == 0 && (delete a.g[c], a.h--));
  }
}
function ab(a, b, c, d) {
  for (var e = 0; e < a.length; ++e) {
    var f = a[e];
    if (!f.ca && f.listener == b && f.capture == !!c && f.ia == d)
      return e;
  }
  return -1;
}
var cb = "closure_lm_" + (1e6 * Math.random() | 0);
var db = {};
function fb(a, b, c, d, e) {
  if (d && d.once)
    return gb(a, b, c, d, e);
  if (Array.isArray(b)) {
    for (var f = 0; f < b.length; f++)
      fb(a, b[f], c, d, e);
    return null;
  }
  c = hb(c);
  return a && a[B] ? a.N(b, c, p(d) ? !!d.capture : !!d, e) : ib(a, b, c, false, d, e);
}
function ib(a, b, c, d, e, f) {
  if (!b)
    throw Error("Invalid event type");
  var h = p(e) ? !!e.capture : !!e, n = jb(a);
  n || (a[cb] = n = new $a(a));
  c = n.add(b, c, d, h, f);
  if (c.proxy)
    return c;
  d = kb();
  c.proxy = d;
  d.src = a;
  d.listener = c;
  if (a.addEventListener)
    Va || (e = h), e === void 0 && (e = false), a.addEventListener(b.toString(), d, e);
  else if (a.attachEvent)
    a.attachEvent(lb(b.toString()), d);
  else if (a.addListener && a.removeListener)
    a.addListener(d);
  else
    throw Error("addEventListener and attachEvent are unavailable.");
  return c;
}
function kb() {
  function a(c) {
    return b.call(a.src, a.listener, c);
  }
  var b = mb;
  return a;
}
function gb(a, b, c, d, e) {
  if (Array.isArray(b)) {
    for (var f = 0; f < b.length; f++)
      gb(a, b[f], c, d, e);
    return null;
  }
  c = hb(c);
  return a && a[B] ? a.O(b, c, p(d) ? !!d.capture : !!d, e) : ib(a, b, c, true, d, e);
}
function nb(a, b, c, d, e) {
  if (Array.isArray(b))
    for (var f = 0; f < b.length; f++)
      nb(a, b[f], c, d, e);
  else
    (d = p(d) ? !!d.capture : !!d, c = hb(c), a && a[B]) ? (a = a.i, b = String(b).toString(), b in a.g && (f = a.g[b], c = ab(f, c, d, e), -1 < c && (Za(f[c]), Array.prototype.splice.call(f, c, 1), f.length == 0 && (delete a.g[b], a.h--)))) : a && (a = jb(a)) && (b = a.g[b.toString()], a = -1, b && (a = ab(b, c, d, e)), (c = -1 < a ? b[a] : null) && ob(c));
}
function ob(a) {
  if (typeof a !== "number" && a && !a.ca) {
    var b = a.src;
    if (b && b[B])
      bb(b.i, a);
    else {
      var c = a.type, d = a.proxy;
      b.removeEventListener ? b.removeEventListener(c, d, a.capture) : b.detachEvent ? b.detachEvent(lb(c), d) : b.addListener && b.removeListener && b.removeListener(d);
      (c = jb(b)) ? (bb(c, a), c.h == 0 && (c.src = null, b[cb] = null)) : Za(a);
    }
  }
}
function lb(a) {
  return a in db ? db[a] : db[a] = "on" + a;
}
function mb(a, b) {
  if (a.ca)
    a = true;
  else {
    b = new A(b, this);
    var c = a.listener, d = a.ia || a.src;
    a.fa && ob(a);
    a = c.call(d, b);
  }
  return a;
}
function jb(a) {
  a = a[cb];
  return a instanceof $a ? a : null;
}
var pb = "__closure_events_fn_" + (1e9 * Math.random() >>> 0);
function hb(a) {
  if (typeof a === "function")
    return a;
  a[pb] || (a[pb] = function(b) {
    return a.handleEvent(b);
  });
  return a[pb];
}
function C() {
  v.call(this);
  this.i = new $a(this);
  this.P = this;
  this.I = null;
}
t(C, v);
C.prototype[B] = true;
C.prototype.removeEventListener = function(a, b, c, d) {
  nb(this, a, b, c, d);
};
function D(a, b) {
  var c, d = a.I;
  if (d)
    for (c = []; d; d = d.I)
      c.push(d);
  a = a.P;
  d = b.type || b;
  if (typeof b === "string")
    b = new z(b, a);
  else if (b instanceof z)
    b.target = b.target || a;
  else {
    var e = b;
    b = new z(d, a);
    Aa(b, e);
  }
  e = true;
  if (c)
    for (var f = c.length - 1; 0 <= f; f--) {
      var h = b.g = c[f];
      e = qb(h, d, true, b) && e;
    }
  h = b.g = a;
  e = qb(h, d, true, b) && e;
  e = qb(h, d, false, b) && e;
  if (c)
    for (f = 0; f < c.length; f++)
      h = b.g = c[f], e = qb(h, d, false, b) && e;
}
C.prototype.M = function() {
  C.Z.M.call(this);
  if (this.i) {
    var a = this.i, c;
    for (c in a.g) {
      for (var d = a.g[c], e = 0; e < d.length; e++)
        Za(d[e]);
      delete a.g[c];
      a.h--;
    }
  }
  this.I = null;
};
C.prototype.N = function(a, b, c, d) {
  return this.i.add(String(a), b, false, c, d);
};
C.prototype.O = function(a, b, c, d) {
  return this.i.add(String(a), b, true, c, d);
};
function qb(a, b, c, d) {
  b = a.i.g[String(b)];
  if (!b)
    return true;
  b = b.concat();
  for (var e = true, f = 0; f < b.length; ++f) {
    var h = b[f];
    if (h && !h.ca && h.capture == c) {
      var n = h.listener, u = h.ia || h.src;
      h.fa && bb(a.i, h);
      e = n.call(u, d) !== false && e;
    }
  }
  return e && !d.defaultPrevented;
}
var rb = l.JSON.stringify;
function sb() {
  var a = tb;
  let b = null;
  a.g && (b = a.g, a.g = a.g.next, a.g || (a.h = null), b.next = null);
  return b;
}
var ub = class {
  constructor() {
    this.h = this.g = null;
  }
  add(a, b) {
    const c = vb.get();
    c.set(a, b);
    this.h ? this.h.next = c : this.g = c;
    this.h = c;
  }
};
var vb = new class {
  constructor(a, b) {
    this.i = a;
    this.j = b;
    this.h = 0;
    this.g = null;
  }
  get() {
    let a;
    0 < this.h ? (this.h--, a = this.g, this.g = a.next, a.next = null) : a = this.i();
    return a;
  }
}(() => new wb(), (a) => a.reset());
var wb = class {
  constructor() {
    this.next = this.g = this.h = null;
  }
  set(a, b) {
    this.h = a;
    this.g = b;
    this.next = null;
  }
  reset() {
    this.next = this.g = this.h = null;
  }
};
function yb(a) {
  l.setTimeout(() => {
    throw a;
  }, 0);
}
function zb(a, b) {
  Ab || Bb();
  Cb || (Ab(), Cb = true);
  tb.add(a, b);
}
var Ab;
function Bb() {
  var a = l.Promise.resolve(void 0);
  Ab = function() {
    a.then(Db);
  };
}
var Cb = false;
var tb = new ub();
function Db() {
  for (var a; a = sb(); ) {
    try {
      a.h.call(a.g);
    } catch (c) {
      yb(c);
    }
    var b = vb;
    b.j(a);
    100 > b.h && (b.h++, a.next = b.g, b.g = a);
  }
  Cb = false;
}
function Eb(a, b) {
  C.call(this);
  this.h = a || 1;
  this.g = b || l;
  this.j = q(this.kb, this);
  this.l = Date.now();
}
t(Eb, C);
k = Eb.prototype;
k.da = false;
k.S = null;
k.kb = function() {
  if (this.da) {
    var a = Date.now() - this.l;
    0 < a && a < 0.8 * this.h ? this.S = this.g.setTimeout(this.j, this.h - a) : (this.S && (this.g.clearTimeout(this.S), this.S = null), D(this, "tick"), this.da && (Fb(this), this.start()));
  }
};
k.start = function() {
  this.da = true;
  this.S || (this.S = this.g.setTimeout(this.j, this.h), this.l = Date.now());
};
function Fb(a) {
  a.da = false;
  a.S && (a.g.clearTimeout(a.S), a.S = null);
}
k.M = function() {
  Eb.Z.M.call(this);
  Fb(this);
  delete this.g;
};
function Gb(a, b, c) {
  if (typeof a === "function")
    c && (a = q(a, c));
  else if (a && typeof a.handleEvent == "function")
    a = q(a.handleEvent, a);
  else
    throw Error("Invalid listener argument");
  return 2147483647 < Number(b) ? -1 : l.setTimeout(a, b || 0);
}
function Hb(a) {
  a.g = Gb(() => {
    a.g = null;
    a.i && (a.i = false, Hb(a));
  }, a.j);
  const b = a.h;
  a.h = null;
  a.m.apply(null, b);
}
var Ib = class extends v {
  constructor(a, b) {
    super();
    this.m = a;
    this.j = b;
    this.h = null;
    this.i = false;
    this.g = null;
  }
  l(a) {
    this.h = arguments;
    this.g ? this.i = true : Hb(this);
  }
  M() {
    super.M();
    this.g && (l.clearTimeout(this.g), this.g = null, this.i = false, this.h = null);
  }
};
function E(a) {
  v.call(this);
  this.h = a;
  this.g = {};
}
t(E, v);
var Jb = [];
function Kb(a, b, c, d) {
  Array.isArray(c) || (c && (Jb[0] = c.toString()), c = Jb);
  for (var e = 0; e < c.length; e++) {
    var f = fb(b, c[e], d || a.handleEvent, false, a.h || a);
    if (!f)
      break;
    a.g[f.key] = f;
  }
}
function Lb(a) {
  xa(a.g, function(b, c) {
    this.g.hasOwnProperty(c) && ob(b);
  }, a);
  a.g = {};
}
E.prototype.M = function() {
  E.Z.M.call(this);
  Lb(this);
};
E.prototype.handleEvent = function() {
  throw Error("EventHandler.handleEvent not implemented");
};
function Mb() {
  this.g = true;
}
Mb.prototype.Aa = function() {
  this.g = false;
};
function Nb(a, b, c, d, e, f) {
  a.info(function() {
    if (a.g)
      if (f) {
        var h = "";
        for (var n = f.split("&"), u = 0; u < n.length; u++) {
          var m = n[u].split("=");
          if (1 < m.length) {
            var r = m[0];
            m = m[1];
            var G2 = r.split("_");
            h = 2 <= G2.length && G2[1] == "type" ? h + (r + "=" + m + "&") : h + (r + "=redacted&");
          }
        }
      } else
        h = null;
    else
      h = f;
    return "XMLHTTP REQ (" + d + ") [attempt " + e + "]: " + b + "\n" + c + "\n" + h;
  });
}
function Ob(a, b, c, d, e, f, h) {
  a.info(function() {
    return "XMLHTTP RESP (" + d + ") [ attempt " + e + "]: " + b + "\n" + c + "\n" + f + " " + h;
  });
}
function F(a, b, c, d) {
  a.info(function() {
    return "XMLHTTP TEXT (" + b + "): " + Pb(a, c) + (d ? " " + d : "");
  });
}
function Qb(a, b) {
  a.info(function() {
    return "TIMEOUT: " + b;
  });
}
Mb.prototype.info = function() {
};
function Pb(a, b) {
  if (!a.g)
    return b;
  if (!b)
    return null;
  try {
    var c = JSON.parse(b);
    if (c) {
      for (a = 0; a < c.length; a++)
        if (Array.isArray(c[a])) {
          var d = c[a];
          if (!(2 > d.length)) {
            var e = d[1];
            if (Array.isArray(e) && !(1 > e.length)) {
              var f = e[0];
              if (f != "noop" && f != "stop" && f != "close")
                for (var h = 1; h < e.length; h++)
                  e[h] = "";
            }
          }
        }
    }
    return rb(c);
  } catch (n) {
    return b;
  }
}
var H = {};
var Rb = null;
function Sb() {
  return Rb = Rb || new C();
}
H.Ma = "serverreachability";
function Tb(a) {
  z.call(this, H.Ma, a);
}
t(Tb, z);
function I(a) {
  const b = Sb();
  D(b, new Tb(b, a));
}
H.STAT_EVENT = "statevent";
function Ub(a, b) {
  z.call(this, H.STAT_EVENT, a);
  this.stat = b;
}
t(Ub, z);
function J(a) {
  const b = Sb();
  D(b, new Ub(b, a));
}
H.Na = "timingevent";
function Vb(a, b) {
  z.call(this, H.Na, a);
  this.size = b;
}
t(Vb, z);
function K(a, b) {
  if (typeof a !== "function")
    throw Error("Fn must not be null and must be a function");
  return l.setTimeout(function() {
    a();
  }, b);
}
var Wb = { NO_ERROR: 0, lb: 1, yb: 2, xb: 3, sb: 4, wb: 5, zb: 6, Ja: 7, TIMEOUT: 8, Cb: 9 };
var Xb = { qb: "complete", Mb: "success", Ka: "error", Ja: "abort", Eb: "ready", Fb: "readystatechange", TIMEOUT: "timeout", Ab: "incrementaldata", Db: "progress", tb: "downloadprogress", Ub: "uploadprogress" };
function Yb() {
}
Yb.prototype.h = null;
function Zb(a) {
  return a.h || (a.h = a.i());
}
function $b() {
}
var L = { OPEN: "a", pb: "b", Ka: "c", Bb: "d" };
function ac() {
  z.call(this, "d");
}
t(ac, z);
function bc() {
  z.call(this, "c");
}
t(bc, z);
var cc;
function dc() {
}
t(dc, Yb);
dc.prototype.g = function() {
  return new XMLHttpRequest();
};
dc.prototype.i = function() {
  return {};
};
cc = new dc();
function M(a, b, c, d) {
  this.l = a;
  this.j = b;
  this.m = c;
  this.X = d || 1;
  this.V = new E(this);
  this.P = ec;
  a = Ja ? 125 : void 0;
  this.W = new Eb(a);
  this.H = null;
  this.i = false;
  this.s = this.A = this.v = this.K = this.F = this.Y = this.B = null;
  this.D = [];
  this.g = null;
  this.C = 0;
  this.o = this.u = null;
  this.N = -1;
  this.I = false;
  this.O = 0;
  this.L = null;
  this.aa = this.J = this.$ = this.U = false;
  this.h = new fc();
}
function fc() {
  this.i = null;
  this.g = "";
  this.h = false;
}
var ec = 45e3;
var gc = {};
var hc = {};
k = M.prototype;
k.setTimeout = function(a) {
  this.P = a;
};
function ic(a, b, c) {
  a.K = 1;
  a.v = jc(N(b));
  a.s = c;
  a.U = true;
  kc(a, null);
}
function kc(a, b) {
  a.F = Date.now();
  lc(a);
  a.A = N(a.v);
  var c = a.A, d = a.X;
  Array.isArray(d) || (d = [String(d)]);
  mc(c.h, "t", d);
  a.C = 0;
  c = a.l.H;
  a.h = new fc();
  a.g = nc(a.l, c ? b : null, !a.s);
  0 < a.O && (a.L = new Ib(q(a.Ia, a, a.g), a.O));
  Kb(a.V, a.g, "readystatechange", a.gb);
  b = a.H ? ya(a.H) : {};
  a.s ? (a.u || (a.u = "POST"), b["Content-Type"] = "application/x-www-form-urlencoded", a.g.ea(a.A, a.u, a.s, b)) : (a.u = "GET", a.g.ea(a.A, a.u, null, b));
  I(1);
  Nb(a.j, a.u, a.A, a.m, a.X, a.s);
}
k.gb = function(a) {
  a = a.target;
  const b = this.L;
  b && O(a) == 3 ? b.l() : this.Ia(a);
};
k.Ia = function(a) {
  try {
    if (a == this.g)
      a: {
        const r = O(this.g);
        var b = this.g.Da();
        const G2 = this.g.ba();
        if (!(3 > r) && (r != 3 || Ja || this.g && (this.h.h || this.g.ga() || oc(this.g)))) {
          this.I || r != 4 || b == 7 || (b == 8 || 0 >= G2 ? I(3) : I(2));
          pc(this);
          var c = this.g.ba();
          this.N = c;
          b:
            if (qc(this)) {
              var d = oc(this.g);
              a = "";
              var e = d.length, f = O(this.g) == 4;
              if (!this.h.i) {
                if (typeof TextDecoder === "undefined") {
                  P(this);
                  rc(this);
                  var h = "";
                  break b;
                }
                this.h.i = new l.TextDecoder();
              }
              for (b = 0; b < e; b++)
                this.h.h = true, a += this.h.i.decode(d[b], { stream: f && b == e - 1 });
              d.splice(0, e);
              this.h.g += a;
              this.C = 0;
              h = this.h.g;
            } else
              h = this.g.ga();
          this.i = c == 200;
          Ob(this.j, this.u, this.A, this.m, this.X, r, c);
          if (this.i) {
            if (this.$ && !this.J) {
              b: {
                if (this.g) {
                  var n, u = this.g;
                  if ((n = u.g ? u.g.getResponseHeader("X-HTTP-Initial-Response") : null) && !sa(n)) {
                    var m = n;
                    break b;
                  }
                }
                m = null;
              }
              if (c = m)
                F(this.j, this.m, c, "Initial handshake response via X-HTTP-Initial-Response"), this.J = true, sc(this, c);
              else {
                this.i = false;
                this.o = 3;
                J(12);
                P(this);
                rc(this);
                break a;
              }
            }
            this.U ? (tc(this, r, h), Ja && this.i && r == 3 && (Kb(this.V, this.W, "tick", this.fb), this.W.start())) : (F(this.j, this.m, h, null), sc(this, h));
            r == 4 && P(this);
            this.i && !this.I && (r == 4 ? uc(this.l, this) : (this.i = false, lc(this)));
          } else
            c == 400 && 0 < h.indexOf("Unknown SID") ? (this.o = 3, J(12)) : (this.o = 0, J(13)), P(this), rc(this);
        }
      }
  } catch (r) {
  } finally {
  }
};
function qc(a) {
  return a.g ? a.u == "GET" && a.K != 2 && a.l.Ba : false;
}
function tc(a, b, c) {
  let d = true, e;
  for (; !a.I && a.C < c.length; )
    if (e = vc(a, c), e == hc) {
      b == 4 && (a.o = 4, J(14), d = false);
      F(a.j, a.m, null, "[Incomplete Response]");
      break;
    } else if (e == gc) {
      a.o = 4;
      J(15);
      F(a.j, a.m, c, "[Invalid Chunk]");
      d = false;
      break;
    } else
      F(a.j, a.m, e, null), sc(a, e);
  qc(a) && e != hc && e != gc && (a.h.g = "", a.C = 0);
  b != 4 || c.length != 0 || a.h.h || (a.o = 1, J(16), d = false);
  a.i = a.i && d;
  d ? 0 < c.length && !a.aa && (a.aa = true, b = a.l, b.g == a && b.$ && !b.L && (b.h.info("Great, no buffering proxy detected. Bytes received: " + c.length), wc(b), b.L = true, J(11))) : (F(a.j, a.m, c, "[Invalid Chunked Response]"), P(a), rc(a));
}
k.fb = function() {
  if (this.g) {
    var a = O(this.g), b = this.g.ga();
    this.C < b.length && (pc(this), tc(this, a, b), this.i && a != 4 && lc(this));
  }
};
function vc(a, b) {
  var c = a.C, d = b.indexOf("\n", c);
  if (d == -1)
    return hc;
  c = Number(b.substring(c, d));
  if (isNaN(c))
    return gc;
  d += 1;
  if (d + c > b.length)
    return hc;
  b = b.substr(d, c);
  a.C = d + c;
  return b;
}
k.cancel = function() {
  this.I = true;
  P(this);
};
function lc(a) {
  a.Y = Date.now() + a.P;
  xc(a, a.P);
}
function xc(a, b) {
  if (a.B != null)
    throw Error("WatchDog timer not null");
  a.B = K(q(a.eb, a), b);
}
function pc(a) {
  a.B && (l.clearTimeout(a.B), a.B = null);
}
k.eb = function() {
  this.B = null;
  const a = Date.now();
  0 <= a - this.Y ? (Qb(this.j, this.A), this.K != 2 && (I(3), J(17)), P(this), this.o = 2, rc(this)) : xc(this, this.Y - a);
};
function rc(a) {
  a.l.G == 0 || a.I || uc(a.l, a);
}
function P(a) {
  pc(a);
  var b = a.L;
  b && typeof b.na == "function" && b.na();
  a.L = null;
  Fb(a.W);
  Lb(a.V);
  a.g && (b = a.g, a.g = null, b.abort(), b.na());
}
function sc(a, b) {
  try {
    var c = a.l;
    if (c.G != 0 && (c.g == a || yc(c.i, a))) {
      if (c.I = a.N, !a.J && yc(c.i, a) && c.G == 3) {
        try {
          var d = c.Ca.g.parse(b);
        } catch (m) {
          d = null;
        }
        if (Array.isArray(d) && d.length == 3) {
          var e = d;
          if (e[0] == 0)
            a: {
              if (!c.u) {
                if (c.g)
                  if (c.g.F + 3e3 < a.F)
                    zc(c), Ac(c);
                  else
                    break a;
                Bc(c);
                J(18);
              }
            }
          else
            c.ta = e[1], 0 < c.ta - c.U && 37500 > e[2] && c.N && c.A == 0 && !c.v && (c.v = K(q(c.ab, c), 6e3));
          if (1 >= Cc(c.i) && c.ka) {
            try {
              c.ka();
            } catch (m) {
            }
            c.ka = void 0;
          }
        } else
          Q(c, 11);
      } else if ((a.J || c.g == a) && zc(c), !sa(b))
        for (e = c.Ca.g.parse(b), b = 0; b < e.length; b++) {
          let m = e[b];
          c.U = m[0];
          m = m[1];
          if (c.G == 2)
            if (m[0] == "c") {
              c.J = m[1];
              c.la = m[2];
              const r = m[3];
              r != null && (c.ma = r, c.h.info("VER=" + c.ma));
              const G2 = m[4];
              G2 != null && (c.za = G2, c.h.info("SVER=" + c.za));
              const Da2 = m[5];
              Da2 != null && typeof Da2 === "number" && 0 < Da2 && (d = 1.5 * Da2, c.K = d, c.h.info("backChannelRequestTimeoutMs_=" + d));
              d = c;
              const ca2 = a.g;
              if (ca2) {
                const Ea2 = ca2.g ? ca2.g.getResponseHeader("X-Client-Wire-Protocol") : null;
                if (Ea2) {
                  var f = d.i;
                  !f.g && (w(Ea2, "spdy") || w(Ea2, "quic") || w(Ea2, "h2")) && (f.j = f.l, f.g = /* @__PURE__ */ new Set(), f.h && (Dc(f, f.h), f.h = null));
                }
                if (d.D) {
                  const xb = ca2.g ? ca2.g.getResponseHeader("X-HTTP-Session-Id") : null;
                  xb && (d.sa = xb, R(d.F, d.D, xb));
                }
              }
              c.G = 3;
              c.j && c.j.xa();
              c.$ && (c.O = Date.now() - a.F, c.h.info("Handshake RTT: " + c.O + "ms"));
              d = c;
              var h = a;
              d.oa = Ec(d, d.H ? d.la : null, d.W);
              if (h.J) {
                Fc(d.i, h);
                var n = h, u = d.K;
                u && n.setTimeout(u);
                n.B && (pc(n), lc(n));
                d.g = h;
              } else
                Gc(d);
              0 < c.l.length && Hc(c);
            } else
              m[0] != "stop" && m[0] != "close" || Q(c, 7);
          else
            c.G == 3 && (m[0] == "stop" || m[0] == "close" ? m[0] == "stop" ? Q(c, 7) : Ic(c) : m[0] != "noop" && c.j && c.j.wa(m), c.A = 0);
        }
    }
    I(4);
  } catch (m) {
  }
}
function Jc(a) {
  if (a.R && typeof a.R == "function")
    return a.R();
  if (typeof a === "string")
    return a.split("");
  if (ba(a)) {
    for (var b = [], c = a.length, d = 0; d < c; d++)
      b.push(a[d]);
    return b;
  }
  b = [];
  c = 0;
  for (d in a)
    b[c++] = a[d];
  return b;
}
function Kc(a, b) {
  if (a.forEach && typeof a.forEach == "function")
    a.forEach(b, void 0);
  else if (ba(a) || typeof a === "string")
    na(a, b, void 0);
  else {
    if (a.T && typeof a.T == "function")
      var c = a.T();
    else if (a.R && typeof a.R == "function")
      c = void 0;
    else if (ba(a) || typeof a === "string") {
      c = [];
      for (var d = a.length, e = 0; e < d; e++)
        c.push(e);
    } else
      for (e in c = [], d = 0, a)
        c[d++] = e;
    d = Jc(a);
    e = d.length;
    for (var f = 0; f < e; f++)
      b.call(void 0, d[f], c && c[f], a);
  }
}
function S(a, b) {
  this.h = {};
  this.g = [];
  this.i = 0;
  var c = arguments.length;
  if (1 < c) {
    if (c % 2)
      throw Error("Uneven number of arguments");
    for (var d = 0; d < c; d += 2)
      this.set(arguments[d], arguments[d + 1]);
  } else if (a)
    if (a instanceof S)
      for (c = a.T(), d = 0; d < c.length; d++)
        this.set(c[d], a.get(c[d]));
    else
      for (d in a)
        this.set(d, a[d]);
}
k = S.prototype;
k.R = function() {
  Lc(this);
  for (var a = [], b = 0; b < this.g.length; b++)
    a.push(this.h[this.g[b]]);
  return a;
};
k.T = function() {
  Lc(this);
  return this.g.concat();
};
function Lc(a) {
  if (a.i != a.g.length) {
    for (var b = 0, c = 0; b < a.g.length; ) {
      var d = a.g[b];
      T(a.h, d) && (a.g[c++] = d);
      b++;
    }
    a.g.length = c;
  }
  if (a.i != a.g.length) {
    var e = {};
    for (c = b = 0; b < a.g.length; )
      d = a.g[b], T(e, d) || (a.g[c++] = d, e[d] = 1), b++;
    a.g.length = c;
  }
}
k.get = function(a, b) {
  return T(this.h, a) ? this.h[a] : b;
};
k.set = function(a, b) {
  T(this.h, a) || (this.i++, this.g.push(a));
  this.h[a] = b;
};
k.forEach = function(a, b) {
  for (var c = this.T(), d = 0; d < c.length; d++) {
    var e = c[d], f = this.get(e);
    a.call(b, f, e, this);
  }
};
function T(a, b) {
  return Object.prototype.hasOwnProperty.call(a, b);
}
var Mc = /^(?:([^:/?#.]+):)?(?:\/\/(?:([^\\/?#]*)@)?([^\\/?#]*?)(?::([0-9]+))?(?=[\\/?#]|$))?([^?#]+)?(?:\?([^#]*))?(?:#([\s\S]*))?$/;
function Nc(a, b) {
  if (a) {
    a = a.split("&");
    for (var c = 0; c < a.length; c++) {
      var d = a[c].indexOf("="), e = null;
      if (0 <= d) {
        var f = a[c].substring(0, d);
        e = a[c].substring(d + 1);
      } else
        f = a[c];
      b(f, e ? decodeURIComponent(e.replace(/\+/g, " ")) : "");
    }
  }
}
function U(a, b) {
  this.i = this.s = this.j = "";
  this.m = null;
  this.o = this.l = "";
  this.g = false;
  if (a instanceof U) {
    this.g = b !== void 0 ? b : a.g;
    Oc(this, a.j);
    this.s = a.s;
    Pc(this, a.i);
    Qc(this, a.m);
    this.l = a.l;
    b = a.h;
    var c = new Rc();
    c.i = b.i;
    b.g && (c.g = new S(b.g), c.h = b.h);
    Sc(this, c);
    this.o = a.o;
  } else
    a && (c = String(a).match(Mc)) ? (this.g = !!b, Oc(this, c[1] || "", true), this.s = Tc(c[2] || ""), Pc(this, c[3] || "", true), Qc(this, c[4]), this.l = Tc(c[5] || "", true), Sc(this, c[6] || "", true), this.o = Tc(c[7] || "")) : (this.g = !!b, this.h = new Rc(null, this.g));
}
U.prototype.toString = function() {
  var a = [], b = this.j;
  b && a.push(Uc(b, Vc, true), ":");
  var c = this.i;
  if (c || b == "file")
    a.push("//"), (b = this.s) && a.push(Uc(b, Vc, true), "@"), a.push(encodeURIComponent(String(c)).replace(/%25([0-9a-fA-F]{2})/g, "%$1")), c = this.m, c != null && a.push(":", String(c));
  if (c = this.l)
    this.i && c.charAt(0) != "/" && a.push("/"), a.push(Uc(c, c.charAt(0) == "/" ? Wc : Xc, true));
  (c = this.h.toString()) && a.push("?", c);
  (c = this.o) && a.push("#", Uc(c, Yc));
  return a.join("");
};
function N(a) {
  return new U(a);
}
function Oc(a, b, c) {
  a.j = c ? Tc(b, true) : b;
  a.j && (a.j = a.j.replace(/:$/, ""));
}
function Pc(a, b, c) {
  a.i = c ? Tc(b, true) : b;
}
function Qc(a, b) {
  if (b) {
    b = Number(b);
    if (isNaN(b) || 0 > b)
      throw Error("Bad port number " + b);
    a.m = b;
  } else
    a.m = null;
}
function Sc(a, b, c) {
  b instanceof Rc ? (a.h = b, Zc(a.h, a.g)) : (c || (b = Uc(b, $c)), a.h = new Rc(b, a.g));
}
function R(a, b, c) {
  a.h.set(b, c);
}
function jc(a) {
  R(a, "zx", Math.floor(2147483648 * Math.random()).toString(36) + Math.abs(Math.floor(2147483648 * Math.random()) ^ Date.now()).toString(36));
  return a;
}
function ad(a) {
  return a instanceof U ? N(a) : new U(a, void 0);
}
function bd(a, b, c, d) {
  var e = new U(null, void 0);
  a && Oc(e, a);
  b && Pc(e, b);
  c && Qc(e, c);
  d && (e.l = d);
  return e;
}
function Tc(a, b) {
  return a ? b ? decodeURI(a.replace(/%25/g, "%2525")) : decodeURIComponent(a) : "";
}
function Uc(a, b, c) {
  return typeof a === "string" ? (a = encodeURI(a).replace(b, cd), c && (a = a.replace(/%25([0-9a-fA-F]{2})/g, "%$1")), a) : null;
}
function cd(a) {
  a = a.charCodeAt(0);
  return "%" + (a >> 4 & 15).toString(16) + (a & 15).toString(16);
}
var Vc = /[#\/\?@]/g;
var Xc = /[#\?:]/g;
var Wc = /[#\?]/g;
var $c = /[#\?@]/g;
var Yc = /#/g;
function Rc(a, b) {
  this.h = this.g = null;
  this.i = a || null;
  this.j = !!b;
}
function V(a) {
  a.g || (a.g = new S(), a.h = 0, a.i && Nc(a.i, function(b, c) {
    a.add(decodeURIComponent(b.replace(/\+/g, " ")), c);
  }));
}
k = Rc.prototype;
k.add = function(a, b) {
  V(this);
  this.i = null;
  a = W(this, a);
  var c = this.g.get(a);
  c || this.g.set(a, c = []);
  c.push(b);
  this.h += 1;
  return this;
};
function dd(a, b) {
  V(a);
  b = W(a, b);
  T(a.g.h, b) && (a.i = null, a.h -= a.g.get(b).length, a = a.g, T(a.h, b) && (delete a.h[b], a.i--, a.g.length > 2 * a.i && Lc(a)));
}
function ed(a, b) {
  V(a);
  b = W(a, b);
  return T(a.g.h, b);
}
k.forEach = function(a, b) {
  V(this);
  this.g.forEach(function(c, d) {
    na(c, function(e) {
      a.call(b, e, d, this);
    }, this);
  }, this);
};
k.T = function() {
  V(this);
  for (var a = this.g.R(), b = this.g.T(), c = [], d = 0; d < b.length; d++)
    for (var e = a[d], f = 0; f < e.length; f++)
      c.push(b[d]);
  return c;
};
k.R = function(a) {
  V(this);
  var b = [];
  if (typeof a === "string")
    ed(this, a) && (b = qa(b, this.g.get(W(this, a))));
  else {
    a = this.g.R();
    for (var c = 0; c < a.length; c++)
      b = qa(b, a[c]);
  }
  return b;
};
k.set = function(a, b) {
  V(this);
  this.i = null;
  a = W(this, a);
  ed(this, a) && (this.h -= this.g.get(a).length);
  this.g.set(a, [b]);
  this.h += 1;
  return this;
};
k.get = function(a, b) {
  if (!a)
    return b;
  a = this.R(a);
  return 0 < a.length ? String(a[0]) : b;
};
function mc(a, b, c) {
  dd(a, b);
  0 < c.length && (a.i = null, a.g.set(W(a, b), ra(c)), a.h += c.length);
}
k.toString = function() {
  if (this.i)
    return this.i;
  if (!this.g)
    return "";
  for (var a = [], b = this.g.T(), c = 0; c < b.length; c++) {
    var d = b[c], e = encodeURIComponent(String(d));
    d = this.R(d);
    for (var f = 0; f < d.length; f++) {
      var h = e;
      d[f] !== "" && (h += "=" + encodeURIComponent(String(d[f])));
      a.push(h);
    }
  }
  return this.i = a.join("&");
};
function W(a, b) {
  b = String(b);
  a.j && (b = b.toLowerCase());
  return b;
}
function Zc(a, b) {
  b && !a.j && (V(a), a.i = null, a.g.forEach(function(c, d) {
    var e = d.toLowerCase();
    d != e && (dd(this, d), mc(this, e, c));
  }, a));
  a.j = b;
}
var fd = class {
  constructor(a, b) {
    this.h = a;
    this.g = b;
  }
};
function gd(a) {
  this.l = a || hd;
  l.PerformanceNavigationTiming ? (a = l.performance.getEntriesByType("navigation"), a = 0 < a.length && (a[0].nextHopProtocol == "hq" || a[0].nextHopProtocol == "h2")) : a = !!(l.g && l.g.Ea && l.g.Ea() && l.g.Ea().Zb);
  this.j = a ? this.l : 1;
  this.g = null;
  1 < this.j && (this.g = /* @__PURE__ */ new Set());
  this.h = null;
  this.i = [];
}
var hd = 10;
function id(a) {
  return a.h ? true : a.g ? a.g.size >= a.j : false;
}
function Cc(a) {
  return a.h ? 1 : a.g ? a.g.size : 0;
}
function yc(a, b) {
  return a.h ? a.h == b : a.g ? a.g.has(b) : false;
}
function Dc(a, b) {
  a.g ? a.g.add(b) : a.h = b;
}
function Fc(a, b) {
  a.h && a.h == b ? a.h = null : a.g && a.g.has(b) && a.g.delete(b);
}
gd.prototype.cancel = function() {
  this.i = jd(this);
  if (this.h)
    this.h.cancel(), this.h = null;
  else if (this.g && this.g.size !== 0) {
    for (const a of this.g.values())
      a.cancel();
    this.g.clear();
  }
};
function jd(a) {
  if (a.h != null)
    return a.i.concat(a.h.D);
  if (a.g != null && a.g.size !== 0) {
    let b = a.i;
    for (const c of a.g.values())
      b = b.concat(c.D);
    return b;
  }
  return ra(a.i);
}
function kd() {
}
kd.prototype.stringify = function(a) {
  return l.JSON.stringify(a, void 0);
};
kd.prototype.parse = function(a) {
  return l.JSON.parse(a, void 0);
};
function ld() {
  this.g = new kd();
}
function md(a, b, c) {
  const d = c || "";
  try {
    Kc(a, function(e, f) {
      let h = e;
      p(e) && (h = rb(e));
      b.push(d + f + "=" + encodeURIComponent(h));
    });
  } catch (e) {
    throw b.push(d + "type=" + encodeURIComponent("_badmap")), e;
  }
}
function nd(a, b) {
  const c = new Mb();
  if (l.Image) {
    const d = new Image();
    d.onload = ja(od, c, d, "TestLoadImage: loaded", true, b);
    d.onerror = ja(od, c, d, "TestLoadImage: error", false, b);
    d.onabort = ja(od, c, d, "TestLoadImage: abort", false, b);
    d.ontimeout = ja(od, c, d, "TestLoadImage: timeout", false, b);
    l.setTimeout(function() {
      if (d.ontimeout)
        d.ontimeout();
    }, 1e4);
    d.src = a;
  } else
    b(false);
}
function od(a, b, c, d, e) {
  try {
    b.onload = null, b.onerror = null, b.onabort = null, b.ontimeout = null, e(d);
  } catch (f) {
  }
}
function pd(a) {
  this.l = a.$b || null;
  this.j = a.ib || false;
}
t(pd, Yb);
pd.prototype.g = function() {
  return new qd(this.l, this.j);
};
pd.prototype.i = function(a) {
  return function() {
    return a;
  };
}({});
function qd(a, b) {
  C.call(this);
  this.D = a;
  this.u = b;
  this.m = void 0;
  this.readyState = rd;
  this.status = 0;
  this.responseType = this.responseText = this.response = this.statusText = "";
  this.onreadystatechange = null;
  this.v = new Headers();
  this.h = null;
  this.C = "GET";
  this.B = "";
  this.g = false;
  this.A = this.j = this.l = null;
}
t(qd, C);
var rd = 0;
k = qd.prototype;
k.open = function(a, b) {
  if (this.readyState != rd)
    throw this.abort(), Error("Error reopening a connection");
  this.C = a;
  this.B = b;
  this.readyState = 1;
  sd(this);
};
k.send = function(a) {
  if (this.readyState != 1)
    throw this.abort(), Error("need to call open() first. ");
  this.g = true;
  const b = { headers: this.v, method: this.C, credentials: this.m, cache: void 0 };
  a && (b.body = a);
  (this.D || l).fetch(new Request(this.B, b)).then(this.Va.bind(this), this.ha.bind(this));
};
k.abort = function() {
  this.response = this.responseText = "";
  this.v = new Headers();
  this.status = 0;
  this.j && this.j.cancel("Request was aborted.");
  1 <= this.readyState && this.g && this.readyState != 4 && (this.g = false, td(this));
  this.readyState = rd;
};
k.Va = function(a) {
  if (this.g && (this.l = a, this.h || (this.status = this.l.status, this.statusText = this.l.statusText, this.h = a.headers, this.readyState = 2, sd(this)), this.g && (this.readyState = 3, sd(this), this.g)))
    if (this.responseType === "arraybuffer")
      a.arrayBuffer().then(this.Ta.bind(this), this.ha.bind(this));
    else if (typeof l.ReadableStream !== "undefined" && "body" in a) {
      this.j = a.body.getReader();
      if (this.u) {
        if (this.responseType)
          throw Error('responseType must be empty for "streamBinaryChunks" mode responses.');
        this.response = [];
      } else
        this.response = this.responseText = "", this.A = new TextDecoder();
      ud(this);
    } else
      a.text().then(this.Ua.bind(this), this.ha.bind(this));
};
function ud(a) {
  a.j.read().then(a.Sa.bind(a)).catch(a.ha.bind(a));
}
k.Sa = function(a) {
  if (this.g) {
    if (this.u && a.value)
      this.response.push(a.value);
    else if (!this.u) {
      var b = a.value ? a.value : new Uint8Array(0);
      if (b = this.A.decode(b, { stream: !a.done }))
        this.response = this.responseText += b;
    }
    a.done ? td(this) : sd(this);
    this.readyState == 3 && ud(this);
  }
};
k.Ua = function(a) {
  this.g && (this.response = this.responseText = a, td(this));
};
k.Ta = function(a) {
  this.g && (this.response = a, td(this));
};
k.ha = function() {
  this.g && td(this);
};
function td(a) {
  a.readyState = 4;
  a.l = null;
  a.j = null;
  a.A = null;
  sd(a);
}
k.setRequestHeader = function(a, b) {
  this.v.append(a, b);
};
k.getResponseHeader = function(a) {
  return this.h ? this.h.get(a.toLowerCase()) || "" : "";
};
k.getAllResponseHeaders = function() {
  if (!this.h)
    return "";
  const a = [], b = this.h.entries();
  for (var c = b.next(); !c.done; )
    c = c.value, a.push(c[0] + ": " + c[1]), c = b.next();
  return a.join("\r\n");
};
function sd(a) {
  a.onreadystatechange && a.onreadystatechange.call(a);
}
Object.defineProperty(qd.prototype, "withCredentials", { get: function() {
  return this.m === "include";
}, set: function(a) {
  this.m = a ? "include" : "same-origin";
} });
var vd = l.JSON.parse;
function X(a) {
  C.call(this);
  this.headers = new S();
  this.u = a || null;
  this.h = false;
  this.C = this.g = null;
  this.H = "";
  this.m = 0;
  this.j = "";
  this.l = this.F = this.v = this.D = false;
  this.B = 0;
  this.A = null;
  this.J = wd;
  this.K = this.L = false;
}
t(X, C);
var wd = "";
var xd = /^https?$/i;
var yd = ["POST", "PUT"];
k = X.prototype;
k.ea = function(a, b, c, d) {
  if (this.g)
    throw Error("[goog.net.XhrIo] Object is active with another request=" + this.H + "; newUri=" + a);
  b = b ? b.toUpperCase() : "GET";
  this.H = a;
  this.j = "";
  this.m = 0;
  this.D = false;
  this.h = true;
  this.g = this.u ? this.u.g() : cc.g();
  this.C = this.u ? Zb(this.u) : Zb(cc);
  this.g.onreadystatechange = q(this.Fa, this);
  try {
    this.F = true, this.g.open(b, String(a), true), this.F = false;
  } catch (f) {
    zd(this, f);
    return;
  }
  a = c || "";
  const e = new S(this.headers);
  d && Kc(d, function(f, h) {
    e.set(h, f);
  });
  d = oa(e.T());
  c = l.FormData && a instanceof l.FormData;
  !(0 <= ma(yd, b)) || d || c || e.set("Content-Type", "application/x-www-form-urlencoded;charset=utf-8");
  e.forEach(function(f, h) {
    this.g.setRequestHeader(h, f);
  }, this);
  this.J && (this.g.responseType = this.J);
  "withCredentials" in this.g && this.g.withCredentials !== this.L && (this.g.withCredentials = this.L);
  try {
    Ad(this), 0 < this.B && ((this.K = Bd(this.g)) ? (this.g.timeout = this.B, this.g.ontimeout = q(this.pa, this)) : this.A = Gb(this.pa, this.B, this)), this.v = true, this.g.send(a), this.v = false;
  } catch (f) {
    zd(this, f);
  }
};
function Bd(a) {
  return y && Ra() && typeof a.timeout === "number" && a.ontimeout !== void 0;
}
function pa(a) {
  return a.toLowerCase() == "content-type";
}
k.pa = function() {
  typeof goog != "undefined" && this.g && (this.j = "Timed out after " + this.B + "ms, aborting", this.m = 8, D(this, "timeout"), this.abort(8));
};
function zd(a, b) {
  a.h = false;
  a.g && (a.l = true, a.g.abort(), a.l = false);
  a.j = b;
  a.m = 5;
  Cd(a);
  Dd(a);
}
function Cd(a) {
  a.D || (a.D = true, D(a, "complete"), D(a, "error"));
}
k.abort = function(a) {
  this.g && this.h && (this.h = false, this.l = true, this.g.abort(), this.l = false, this.m = a || 7, D(this, "complete"), D(this, "abort"), Dd(this));
};
k.M = function() {
  this.g && (this.h && (this.h = false, this.l = true, this.g.abort(), this.l = false), Dd(this, true));
  X.Z.M.call(this);
};
k.Fa = function() {
  this.s || (this.F || this.v || this.l ? Ed(this) : this.cb());
};
k.cb = function() {
  Ed(this);
};
function Ed(a) {
  if (a.h && typeof goog != "undefined" && (!a.C[1] || O(a) != 4 || a.ba() != 2)) {
    if (a.v && O(a) == 4)
      Gb(a.Fa, 0, a);
    else if (D(a, "readystatechange"), O(a) == 4) {
      a.h = false;
      try {
        const n = a.ba();
        a:
          switch (n) {
            case 200:
            case 201:
            case 202:
            case 204:
            case 206:
            case 304:
            case 1223:
              var b = true;
              break a;
            default:
              b = false;
          }
        var c;
        if (!(c = b)) {
          var d;
          if (d = n === 0) {
            var e = String(a.H).match(Mc)[1] || null;
            if (!e && l.self && l.self.location) {
              var f = l.self.location.protocol;
              e = f.substr(0, f.length - 1);
            }
            d = !xd.test(e ? e.toLowerCase() : "");
          }
          c = d;
        }
        if (c)
          D(a, "complete"), D(a, "success");
        else {
          a.m = 6;
          try {
            var h = 2 < O(a) ? a.g.statusText : "";
          } catch (u) {
            h = "";
          }
          a.j = h + " [" + a.ba() + "]";
          Cd(a);
        }
      } finally {
        Dd(a);
      }
    }
  }
}
function Dd(a, b) {
  if (a.g) {
    Ad(a);
    const c = a.g, d = a.C[0] ? aa : null;
    a.g = null;
    a.C = null;
    b || D(a, "ready");
    try {
      c.onreadystatechange = d;
    } catch (e) {
    }
  }
}
function Ad(a) {
  a.g && a.K && (a.g.ontimeout = null);
  a.A && (l.clearTimeout(a.A), a.A = null);
}
function O(a) {
  return a.g ? a.g.readyState : 0;
}
k.ba = function() {
  try {
    return 2 < O(this) ? this.g.status : -1;
  } catch (a) {
    return -1;
  }
};
k.ga = function() {
  try {
    return this.g ? this.g.responseText : "";
  } catch (a) {
    return "";
  }
};
k.Qa = function(a) {
  if (this.g) {
    var b = this.g.responseText;
    a && b.indexOf(a) == 0 && (b = b.substring(a.length));
    return vd(b);
  }
};
function oc(a) {
  try {
    if (!a.g)
      return null;
    if ("response" in a.g)
      return a.g.response;
    switch (a.J) {
      case wd:
      case "text":
        return a.g.responseText;
      case "arraybuffer":
        if ("mozResponseArrayBuffer" in a.g)
          return a.g.mozResponseArrayBuffer;
    }
    return null;
  } catch (b) {
    return null;
  }
}
k.Da = function() {
  return this.m;
};
k.La = function() {
  return typeof this.j === "string" ? this.j : String(this.j);
};
function Fd(a) {
  let b = "";
  xa(a, function(c, d) {
    b += d;
    b += ":";
    b += c;
    b += "\r\n";
  });
  return b;
}
function Gd(a, b, c) {
  a: {
    for (d in c) {
      var d = false;
      break a;
    }
    d = true;
  }
  d || (c = Fd(c), typeof a === "string" ? c != null && encodeURIComponent(String(c)) : R(a, b, c));
}
function Hd(a, b, c) {
  return c && c.internalChannelParams ? c.internalChannelParams[a] || b : b;
}
function Id(a) {
  this.za = 0;
  this.l = [];
  this.h = new Mb();
  this.la = this.oa = this.F = this.W = this.g = this.sa = this.D = this.aa = this.o = this.P = this.s = null;
  this.Za = this.V = 0;
  this.Xa = Hd("failFast", false, a);
  this.N = this.v = this.u = this.m = this.j = null;
  this.X = true;
  this.I = this.ta = this.U = -1;
  this.Y = this.A = this.C = 0;
  this.Pa = Hd("baseRetryDelayMs", 5e3, a);
  this.$a = Hd("retryDelaySeedMs", 1e4, a);
  this.Ya = Hd("forwardChannelMaxRetries", 2, a);
  this.ra = Hd("forwardChannelRequestTimeoutMs", 2e4, a);
  this.qa = a && a.xmlHttpFactory || void 0;
  this.Ba = a && a.Yb || false;
  this.K = void 0;
  this.H = a && a.supportsCrossDomainXhr || false;
  this.J = "";
  this.i = new gd(a && a.concurrentRequestLimit);
  this.Ca = new ld();
  this.ja = a && a.fastHandshake || false;
  this.Ra = a && a.Wb || false;
  a && a.Aa && this.h.Aa();
  a && a.forceLongPolling && (this.X = false);
  this.$ = !this.ja && this.X && a && a.detectBufferingProxy || false;
  this.ka = void 0;
  this.O = 0;
  this.L = false;
  this.B = null;
  this.Wa = !a || a.Xb !== false;
}
k = Id.prototype;
k.ma = 8;
k.G = 1;
function Ic(a) {
  Jd(a);
  if (a.G == 3) {
    var b = a.V++, c = N(a.F);
    R(c, "SID", a.J);
    R(c, "RID", b);
    R(c, "TYPE", "terminate");
    Kd(a, c);
    b = new M(a, a.h, b, void 0);
    b.K = 2;
    b.v = jc(N(c));
    c = false;
    l.navigator && l.navigator.sendBeacon && (c = l.navigator.sendBeacon(b.v.toString(), ""));
    !c && l.Image && (new Image().src = b.v, c = true);
    c || (b.g = nc(b.l, null), b.g.ea(b.v));
    b.F = Date.now();
    lc(b);
  }
  Ld(a);
}
k.hb = function(a) {
  try {
    this.h.info("Origin Trials invoked: " + a);
  } catch (b) {
  }
};
function Ac(a) {
  a.g && (wc(a), a.g.cancel(), a.g = null);
}
function Jd(a) {
  Ac(a);
  a.u && (l.clearTimeout(a.u), a.u = null);
  zc(a);
  a.i.cancel();
  a.m && (typeof a.m === "number" && l.clearTimeout(a.m), a.m = null);
}
function Md(a, b) {
  a.l.push(new fd(a.Za++, b));
  a.G == 3 && Hc(a);
}
function Hc(a) {
  id(a.i) || a.m || (a.m = true, zb(a.Ha, a), a.C = 0);
}
function Nd(a, b) {
  if (Cc(a.i) >= a.i.j - (a.m ? 1 : 0))
    return false;
  if (a.m)
    return a.l = b.D.concat(a.l), true;
  if (a.G == 1 || a.G == 2 || a.C >= (a.Xa ? 0 : a.Ya))
    return false;
  a.m = K(q(a.Ha, a, b), Od(a, a.C));
  a.C++;
  return true;
}
k.Ha = function(a) {
  if (this.m)
    if (this.m = null, this.G == 1) {
      if (!a) {
        this.V = Math.floor(1e5 * Math.random());
        a = this.V++;
        const e = new M(this, this.h, a, void 0);
        let f = this.s;
        this.P && (f ? (f = ya(f), Aa(f, this.P)) : f = this.P);
        this.o === null && (e.H = f);
        if (this.ja)
          a: {
            var b = 0;
            for (var c = 0; c < this.l.length; c++) {
              b: {
                var d = this.l[c];
                if ("__data__" in d.g && (d = d.g.__data__, typeof d === "string")) {
                  d = d.length;
                  break b;
                }
                d = void 0;
              }
              if (d === void 0)
                break;
              b += d;
              if (4096 < b) {
                b = c;
                break a;
              }
              if (b === 4096 || c === this.l.length - 1) {
                b = c + 1;
                break a;
              }
            }
            b = 1e3;
          }
        else
          b = 1e3;
        b = Pd(this, e, b);
        c = N(this.F);
        R(c, "RID", a);
        R(c, "CVER", 22);
        this.D && R(c, "X-HTTP-Session-Id", this.D);
        Kd(this, c);
        this.o && f && Gd(c, this.o, f);
        Dc(this.i, e);
        this.Ra && R(c, "TYPE", "init");
        this.ja ? (R(c, "$req", b), R(c, "SID", "null"), e.$ = true, ic(e, c, null)) : ic(e, c, b);
        this.G = 2;
      }
    } else
      this.G == 3 && (a ? Qd(this, a) : this.l.length == 0 || id(this.i) || Qd(this));
};
function Qd(a, b) {
  var c;
  b ? c = b.m : c = a.V++;
  const d = N(a.F);
  R(d, "SID", a.J);
  R(d, "RID", c);
  R(d, "AID", a.U);
  Kd(a, d);
  a.o && a.s && Gd(d, a.o, a.s);
  c = new M(a, a.h, c, a.C + 1);
  a.o === null && (c.H = a.s);
  b && (a.l = b.D.concat(a.l));
  b = Pd(a, c, 1e3);
  c.setTimeout(Math.round(0.5 * a.ra) + Math.round(0.5 * a.ra * Math.random()));
  Dc(a.i, c);
  ic(c, d, b);
}
function Kd(a, b) {
  a.j && Kc({}, function(c, d) {
    R(b, d, c);
  });
}
function Pd(a, b, c) {
  c = Math.min(a.l.length, c);
  var d = a.j ? q(a.j.Oa, a.j, a) : null;
  a: {
    var e = a.l;
    let f = -1;
    for (; ; ) {
      const h = ["count=" + c];
      f == -1 ? 0 < c ? (f = e[0].h, h.push("ofs=" + f)) : f = 0 : h.push("ofs=" + f);
      let n = true;
      for (let u = 0; u < c; u++) {
        let m = e[u].h;
        const r = e[u].g;
        m -= f;
        if (0 > m)
          f = Math.max(0, e[u].h - 100), n = false;
        else
          try {
            md(r, h, "req" + m + "_");
          } catch (G2) {
            d && d(r);
          }
      }
      if (n) {
        d = h.join("&");
        break a;
      }
    }
  }
  a = a.l.splice(0, c);
  b.D = a;
  return d;
}
function Gc(a) {
  a.g || a.u || (a.Y = 1, zb(a.Ga, a), a.A = 0);
}
function Bc(a) {
  if (a.g || a.u || 3 <= a.A)
    return false;
  a.Y++;
  a.u = K(q(a.Ga, a), Od(a, a.A));
  a.A++;
  return true;
}
k.Ga = function() {
  this.u = null;
  Rd(this);
  if (this.$ && !(this.L || this.g == null || 0 >= this.O)) {
    var a = 2 * this.O;
    this.h.info("BP detection timer enabled: " + a);
    this.B = K(q(this.bb, this), a);
  }
};
k.bb = function() {
  this.B && (this.B = null, this.h.info("BP detection timeout reached."), this.h.info("Buffering proxy detected and switch to long-polling!"), this.N = false, this.L = true, J(10), Ac(this), Rd(this));
};
function wc(a) {
  a.B != null && (l.clearTimeout(a.B), a.B = null);
}
function Rd(a) {
  a.g = new M(a, a.h, "rpc", a.Y);
  a.o === null && (a.g.H = a.s);
  a.g.O = 0;
  var b = N(a.oa);
  R(b, "RID", "rpc");
  R(b, "SID", a.J);
  R(b, "CI", a.N ? "0" : "1");
  R(b, "AID", a.U);
  Kd(a, b);
  R(b, "TYPE", "xmlhttp");
  a.o && a.s && Gd(b, a.o, a.s);
  a.K && a.g.setTimeout(a.K);
  var c = a.g;
  a = a.la;
  c.K = 1;
  c.v = jc(N(b));
  c.s = null;
  c.U = true;
  kc(c, a);
}
k.ab = function() {
  this.v != null && (this.v = null, Ac(this), Bc(this), J(19));
};
function zc(a) {
  a.v != null && (l.clearTimeout(a.v), a.v = null);
}
function uc(a, b) {
  var c = null;
  if (a.g == b) {
    zc(a);
    wc(a);
    a.g = null;
    var d = 2;
  } else if (yc(a.i, b))
    c = b.D, Fc(a.i, b), d = 1;
  else
    return;
  a.I = b.N;
  if (a.G != 0) {
    if (b.i)
      if (d == 1) {
        c = b.s ? b.s.length : 0;
        b = Date.now() - b.F;
        var e = a.C;
        d = Sb();
        D(d, new Vb(d, c, b, e));
        Hc(a);
      } else
        Gc(a);
    else if (e = b.o, e == 3 || e == 0 && 0 < a.I || !(d == 1 && Nd(a, b) || d == 2 && Bc(a)))
      switch (c && 0 < c.length && (b = a.i, b.i = b.i.concat(c)), e) {
        case 1:
          Q(a, 5);
          break;
        case 4:
          Q(a, 10);
          break;
        case 3:
          Q(a, 6);
          break;
        default:
          Q(a, 2);
      }
  }
}
function Od(a, b) {
  let c = a.Pa + Math.floor(Math.random() * a.$a);
  a.j || (c *= 2);
  return c * b;
}
function Q(a, b) {
  a.h.info("Error code " + b);
  if (b == 2) {
    var c = null;
    a.j && (c = null);
    var d = q(a.jb, a);
    c || (c = new U("//www.google.com/images/cleardot.gif"), l.location && l.location.protocol == "http" || Oc(c, "https"), jc(c));
    nd(c.toString(), d);
  } else
    J(2);
  a.G = 0;
  a.j && a.j.va(b);
  Ld(a);
  Jd(a);
}
k.jb = function(a) {
  a ? (this.h.info("Successfully pinged google.com"), J(2)) : (this.h.info("Failed to ping google.com"), J(1));
};
function Ld(a) {
  a.G = 0;
  a.I = -1;
  if (a.j) {
    if (jd(a.i).length != 0 || a.l.length != 0)
      a.i.i.length = 0, ra(a.l), a.l.length = 0;
    a.j.ua();
  }
}
function Ec(a, b, c) {
  let d = ad(c);
  if (d.i != "")
    b && Pc(d, b + "." + d.i), Qc(d, d.m);
  else {
    const e = l.location;
    d = bd(e.protocol, b ? b + "." + e.hostname : e.hostname, +e.port, c);
  }
  a.aa && xa(a.aa, function(e, f) {
    R(d, f, e);
  });
  b = a.D;
  c = a.sa;
  b && c && R(d, b, c);
  R(d, "VER", a.ma);
  Kd(a, d);
  return d;
}
function nc(a, b, c) {
  if (b && !a.H)
    throw Error("Can't create secondary domain capable XhrIo object.");
  b = c && a.Ba && !a.qa ? new X(new pd({ ib: true })) : new X(a.qa);
  b.L = a.H;
  return b;
}
function Sd() {
}
k = Sd.prototype;
k.xa = function() {
};
k.wa = function() {
};
k.va = function() {
};
k.ua = function() {
};
k.Oa = function() {
};
function Td() {
  if (y && !(10 <= Number(Ua)))
    throw Error("Environmental error: no available transport.");
}
Td.prototype.g = function(a, b) {
  return new Y(a, b);
};
function Y(a, b) {
  C.call(this);
  this.g = new Id(b);
  this.l = a;
  this.h = b && b.messageUrlParams || null;
  a = b && b.messageHeaders || null;
  b && b.clientProtocolHeaderRequired && (a ? a["X-Client-Protocol"] = "webchannel" : a = { "X-Client-Protocol": "webchannel" });
  this.g.s = a;
  a = b && b.initMessageHeaders || null;
  b && b.messageContentType && (a ? a["X-WebChannel-Content-Type"] = b.messageContentType : a = { "X-WebChannel-Content-Type": b.messageContentType });
  b && b.ya && (a ? a["X-WebChannel-Client-Profile"] = b.ya : a = { "X-WebChannel-Client-Profile": b.ya });
  this.g.P = a;
  (a = b && b.httpHeadersOverwriteParam) && !sa(a) && (this.g.o = a);
  this.A = b && b.supportsCrossDomainXhr || false;
  this.v = b && b.sendRawJson || false;
  (b = b && b.httpSessionIdParam) && !sa(b) && (this.g.D = b, a = this.h, a !== null && b in a && (a = this.h, b in a && delete a[b]));
  this.j = new Z(this);
}
t(Y, C);
Y.prototype.m = function() {
  this.g.j = this.j;
  this.A && (this.g.H = true);
  var a = this.g, b = this.l, c = this.h || void 0;
  a.Wa && (a.h.info("Origin Trials enabled."), zb(q(a.hb, a, b)));
  J(0);
  a.W = b;
  a.aa = c || {};
  a.N = a.X;
  a.F = Ec(a, null, a.W);
  Hc(a);
};
Y.prototype.close = function() {
  Ic(this.g);
};
Y.prototype.u = function(a) {
  if (typeof a === "string") {
    var b = {};
    b.__data__ = a;
    Md(this.g, b);
  } else
    this.v ? (b = {}, b.__data__ = rb(a), Md(this.g, b)) : Md(this.g, a);
};
Y.prototype.M = function() {
  this.g.j = null;
  delete this.j;
  Ic(this.g);
  delete this.g;
  Y.Z.M.call(this);
};
function Ud(a) {
  ac.call(this);
  var b = a.__sm__;
  if (b) {
    a: {
      for (const c in b) {
        a = c;
        break a;
      }
      a = void 0;
    }
    if (this.i = a)
      a = this.i, b = b !== null && a in b ? b[a] : void 0;
    this.data = b;
  } else
    this.data = a;
}
t(Ud, ac);
function Vd() {
  bc.call(this);
  this.status = 1;
}
t(Vd, bc);
function Z(a) {
  this.g = a;
}
t(Z, Sd);
Z.prototype.xa = function() {
  D(this.g, "a");
};
Z.prototype.wa = function(a) {
  D(this.g, new Ud(a));
};
Z.prototype.va = function(a) {
  D(this.g, new Vd(a));
};
Z.prototype.ua = function() {
  D(this.g, "b");
};
Td.prototype.createWebChannel = Td.prototype.g;
Y.prototype.send = Y.prototype.u;
Y.prototype.open = Y.prototype.m;
Y.prototype.close = Y.prototype.close;
Wb.NO_ERROR = 0;
Wb.TIMEOUT = 8;
Wb.HTTP_ERROR = 6;
Xb.COMPLETE = "complete";
$b.EventType = L;
L.OPEN = "a";
L.CLOSE = "b";
L.ERROR = "c";
L.MESSAGE = "d";
C.prototype.listen = C.prototype.N;
X.prototype.listenOnce = X.prototype.O;
X.prototype.getLastError = X.prototype.La;
X.prototype.getLastErrorCode = X.prototype.Da;
X.prototype.getStatus = X.prototype.ba;
X.prototype.getResponseJson = X.prototype.Qa;
X.prototype.getResponseText = X.prototype.ga;
X.prototype.send = X.prototype.ea;
var createWebChannelTransport = esm.createWebChannelTransport = function() {
  return new Td();
};
var getStatEventTarget = esm.getStatEventTarget = function() {
  return Sb();
};
var ErrorCode = esm.ErrorCode = Wb;
var EventType = esm.EventType = Xb;
var Event = esm.Event = H;
var Stat = esm.Stat = { rb: 0, ub: 1, vb: 2, Ob: 3, Tb: 4, Qb: 5, Rb: 6, Pb: 7, Nb: 8, Sb: 9, PROXY: 10, NOPROXY: 11, Lb: 12, Hb: 13, Ib: 14, Gb: 15, Jb: 16, Kb: 17, nb: 18, mb: 19, ob: 20 };
var FetchXmlHttpFactory = esm.FetchXmlHttpFactory = pd;
var WebChannel = esm.WebChannel = $b;
var XhrIo = esm.XhrIo = X;

// node_modules/@firebase/firestore/dist/index.esm2017.js
var D2 = "@firebase/firestore";
var C2 = class {
  constructor(t2) {
    this.uid = t2;
  }
  isAuthenticated() {
    return this.uid != null;
  }
  toKey() {
    return this.isAuthenticated() ? "uid:" + this.uid : "anonymous-user";
  }
  isEqual(t2) {
    return t2.uid === this.uid;
  }
};
C2.UNAUTHENTICATED = new C2(null), C2.GOOGLE_CREDENTIALS = new C2("google-credentials-uid"), C2.FIRST_PARTY = new C2("first-party-uid"), C2.MOCK_USER = new C2("mock-user");
var x2 = "9.6.10";
var N2 = new Logger("@firebase/firestore");
function k2() {
  return N2.logLevel;
}
function M2(t2) {
  N2.setLogLevel(t2);
}
function O2(t2, ...e) {
  if (N2.logLevel <= LogLevel.DEBUG) {
    const n = e.map(B2);
    N2.debug(`Firestore (${x2}): ${t2}`, ...n);
  }
}
function F2(t2, ...e) {
  if (N2.logLevel <= LogLevel.ERROR) {
    const n = e.map(B2);
    N2.error(`Firestore (${x2}): ${t2}`, ...n);
  }
}
function $(t2, ...e) {
  if (N2.logLevel <= LogLevel.WARN) {
    const n = e.map(B2);
    N2.warn(`Firestore (${x2}): ${t2}`, ...n);
  }
}
function B2(t2) {
  if (typeof t2 == "string")
    return t2;
  try {
    return e = t2, JSON.stringify(e);
  } catch (e2) {
    return t2;
  }
  var e;
}
function L2(t2 = "Unexpected state") {
  const e = `FIRESTORE (${x2}) INTERNAL ASSERTION FAILED: ` + t2;
  throw F2(e), new Error(e);
}
function U2(t2, e) {
  t2 || L2();
}
function q2(t2, e) {
  t2 || L2();
}
function G(t2, e) {
  return t2;
}
var K2 = {
  OK: "ok",
  CANCELLED: "cancelled",
  UNKNOWN: "unknown",
  INVALID_ARGUMENT: "invalid-argument",
  DEADLINE_EXCEEDED: "deadline-exceeded",
  NOT_FOUND: "not-found",
  ALREADY_EXISTS: "already-exists",
  PERMISSION_DENIED: "permission-denied",
  UNAUTHENTICATED: "unauthenticated",
  RESOURCE_EXHAUSTED: "resource-exhausted",
  FAILED_PRECONDITION: "failed-precondition",
  ABORTED: "aborted",
  OUT_OF_RANGE: "out-of-range",
  UNIMPLEMENTED: "unimplemented",
  INTERNAL: "internal",
  UNAVAILABLE: "unavailable",
  DATA_LOSS: "data-loss"
};
var Q2 = class extends FirebaseError {
  constructor(t2, e) {
    super(t2, e), this.code = t2, this.message = e, this.toString = () => `${this.name}: [code=${this.code}]: ${this.message}`;
  }
};
var j = class {
  constructor() {
    this.promise = new Promise((t2, e) => {
      this.resolve = t2, this.reject = e;
    });
  }
};
var W2 = class {
  constructor(t2, e) {
    this.user = e, this.type = "OAuth", this.headers = /* @__PURE__ */ new Map(), this.headers.set("Authorization", `Bearer ${t2}`);
  }
};
var z2 = class {
  getToken() {
    return Promise.resolve(null);
  }
  invalidateToken() {
  }
  start(t2, e) {
    t2.enqueueRetryable(() => e(C2.UNAUTHENTICATED));
  }
  shutdown() {
  }
};
var H2 = class {
  constructor(t2) {
    this.token = t2, this.changeListener = null;
  }
  getToken() {
    return Promise.resolve(this.token);
  }
  invalidateToken() {
  }
  start(t2, e) {
    this.changeListener = e, t2.enqueueRetryable(() => e(this.token.user));
  }
  shutdown() {
    this.changeListener = null;
  }
};
var J2 = class {
  constructor(t2) {
    this.t = t2, this.currentUser = C2.UNAUTHENTICATED, this.i = 0, this.forceRefresh = false, this.auth = null;
  }
  start(t2, e) {
    let n = this.i;
    const s = (t3) => this.i !== n ? (n = this.i, e(t3)) : Promise.resolve();
    let i = new j();
    this.o = () => {
      this.i++, this.currentUser = this.u(), i.resolve(), i = new j(), t2.enqueueRetryable(() => s(this.currentUser));
    };
    const r = () => {
      const e2 = i;
      t2.enqueueRetryable(async () => {
        await e2.promise, await s(this.currentUser);
      });
    }, o = (t3) => {
      O2("FirebaseAuthCredentialsProvider", "Auth detected"), this.auth = t3, this.auth.addAuthTokenListener(this.o), r();
    };
    this.t.onInit((t3) => o(t3)), setTimeout(() => {
      if (!this.auth) {
        const t3 = this.t.getImmediate({
          optional: true
        });
        t3 ? o(t3) : (O2("FirebaseAuthCredentialsProvider", "Auth not yet detected"), i.resolve(), i = new j());
      }
    }, 0), r();
  }
  getToken() {
    const t2 = this.i, e = this.forceRefresh;
    return this.forceRefresh = false, this.auth ? this.auth.getToken(e).then((e2) => this.i !== t2 ? (O2("FirebaseAuthCredentialsProvider", "getToken aborted due to token change."), this.getToken()) : e2 ? (U2(typeof e2.accessToken == "string"), new W2(e2.accessToken, this.currentUser)) : null) : Promise.resolve(null);
  }
  invalidateToken() {
    this.forceRefresh = true;
  }
  shutdown() {
    this.auth && this.auth.removeAuthTokenListener(this.o);
  }
  u() {
    const t2 = this.auth && this.auth.getUid();
    return U2(t2 === null || typeof t2 == "string"), new C2(t2);
  }
};
var Y2 = class {
  constructor(t2, e, n) {
    this.type = "FirstParty", this.user = C2.FIRST_PARTY, this.headers = /* @__PURE__ */ new Map(), this.headers.set("X-Goog-AuthUser", e);
    const s = t2.auth.getAuthHeaderValueForFirstParty([]);
    s && this.headers.set("Authorization", s), n && this.headers.set("X-Goog-Iam-Authorization-Token", n);
  }
};
var X2 = class {
  constructor(t2, e, n) {
    this.h = t2, this.l = e, this.m = n;
  }
  getToken() {
    return Promise.resolve(new Y2(this.h, this.l, this.m));
  }
  start(t2, e) {
    t2.enqueueRetryable(() => e(C2.FIRST_PARTY));
  }
  shutdown() {
  }
  invalidateToken() {
  }
};
var Z2 = class {
  constructor(t2) {
    this.value = t2, this.type = "AppCheck", this.headers = /* @__PURE__ */ new Map(), t2 && t2.length > 0 && this.headers.set("x-firebase-appcheck", this.value);
  }
};
var tt = class {
  constructor(t2) {
    this.g = t2, this.forceRefresh = false, this.appCheck = null, this.p = null;
  }
  start(t2, e) {
    const n = (t3) => {
      t3.error != null && O2("FirebaseAppCheckTokenProvider", `Error getting App Check token; using placeholder token instead. Error: ${t3.error.message}`);
      const n2 = t3.token !== this.p;
      return this.p = t3.token, O2("FirebaseAppCheckTokenProvider", `Received ${n2 ? "new" : "existing"} token.`), n2 ? e(t3.token) : Promise.resolve();
    };
    this.o = (e2) => {
      t2.enqueueRetryable(() => n(e2));
    };
    const s = (t3) => {
      O2("FirebaseAppCheckTokenProvider", "AppCheck detected"), this.appCheck = t3, this.appCheck.addTokenListener(this.o);
    };
    this.g.onInit((t3) => s(t3)), setTimeout(() => {
      if (!this.appCheck) {
        const t3 = this.g.getImmediate({
          optional: true
        });
        t3 ? s(t3) : O2("FirebaseAppCheckTokenProvider", "AppCheck not yet detected");
      }
    }, 0);
  }
  getToken() {
    const t2 = this.forceRefresh;
    return this.forceRefresh = false, this.appCheck ? this.appCheck.getToken(t2).then((t3) => t3 ? (U2(typeof t3.token == "string"), this.p = t3.token, new Z2(t3.token)) : null) : Promise.resolve(null);
  }
  invalidateToken() {
    this.forceRefresh = true;
  }
  shutdown() {
    this.appCheck && this.appCheck.removeTokenListener(this.o);
  }
};
var et = class {
  getToken() {
    return Promise.resolve(new Z2(""));
  }
  invalidateToken() {
  }
  start(t2, e) {
  }
  shutdown() {
  }
};
var nt = class {
  constructor(t2, e) {
    this.previousValue = t2, e && (e.sequenceNumberHandler = (t3) => this.I(t3), this.T = (t3) => e.writeSequenceNumber(t3));
  }
  I(t2) {
    return this.previousValue = Math.max(t2, this.previousValue), this.previousValue;
  }
  next() {
    const t2 = ++this.previousValue;
    return this.T && this.T(t2), t2;
  }
};
function st(t2) {
  const e = typeof self != "undefined" && (self.crypto || self.msCrypto), n = new Uint8Array(t2);
  if (e && typeof e.getRandomValues == "function")
    e.getRandomValues(n);
  else
    for (let e2 = 0; e2 < t2; e2++)
      n[e2] = Math.floor(256 * Math.random());
  return n;
}
nt.A = -1;
var it = class {
  static R() {
    const t2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", e = Math.floor(256 / t2.length) * t2.length;
    let n = "";
    for (; n.length < 20; ) {
      const s = st(40);
      for (let i = 0; i < s.length; ++i)
        n.length < 20 && s[i] < e && (n += t2.charAt(s[i] % t2.length));
    }
    return n;
  }
};
function rt(t2, e) {
  return t2 < e ? -1 : t2 > e ? 1 : 0;
}
function ot(t2, e, n) {
  return t2.length === e.length && t2.every((t3, s) => n(t3, e[s]));
}
function ut(t2) {
  return t2 + "\0";
}
var at = class {
  constructor(t2, e) {
    if (this.seconds = t2, this.nanoseconds = e, e < 0)
      throw new Q2(K2.INVALID_ARGUMENT, "Timestamp nanoseconds out of range: " + e);
    if (e >= 1e9)
      throw new Q2(K2.INVALID_ARGUMENT, "Timestamp nanoseconds out of range: " + e);
    if (t2 < -62135596800)
      throw new Q2(K2.INVALID_ARGUMENT, "Timestamp seconds out of range: " + t2);
    if (t2 >= 253402300800)
      throw new Q2(K2.INVALID_ARGUMENT, "Timestamp seconds out of range: " + t2);
  }
  static now() {
    return at.fromMillis(Date.now());
  }
  static fromDate(t2) {
    return at.fromMillis(t2.getTime());
  }
  static fromMillis(t2) {
    const e = Math.floor(t2 / 1e3), n = Math.floor(1e6 * (t2 - 1e3 * e));
    return new at(e, n);
  }
  toDate() {
    return new Date(this.toMillis());
  }
  toMillis() {
    return 1e3 * this.seconds + this.nanoseconds / 1e6;
  }
  _compareTo(t2) {
    return this.seconds === t2.seconds ? rt(this.nanoseconds, t2.nanoseconds) : rt(this.seconds, t2.seconds);
  }
  isEqual(t2) {
    return t2.seconds === this.seconds && t2.nanoseconds === this.nanoseconds;
  }
  toString() {
    return "Timestamp(seconds=" + this.seconds + ", nanoseconds=" + this.nanoseconds + ")";
  }
  toJSON() {
    return {
      seconds: this.seconds,
      nanoseconds: this.nanoseconds
    };
  }
  valueOf() {
    const t2 = this.seconds - -62135596800;
    return String(t2).padStart(12, "0") + "." + String(this.nanoseconds).padStart(9, "0");
  }
};
var ct = class {
  constructor(t2) {
    this.timestamp = t2;
  }
  static fromTimestamp(t2) {
    return new ct(t2);
  }
  static min() {
    return new ct(new at(0, 0));
  }
  static max() {
    return new ct(new at(253402300799, 999999999));
  }
  compareTo(t2) {
    return this.timestamp._compareTo(t2.timestamp);
  }
  isEqual(t2) {
    return this.timestamp.isEqual(t2.timestamp);
  }
  toMicroseconds() {
    return 1e6 * this.timestamp.seconds + this.timestamp.nanoseconds / 1e3;
  }
  toString() {
    return "SnapshotVersion(" + this.timestamp.toString() + ")";
  }
  toTimestamp() {
    return this.timestamp;
  }
};
function ht(t2) {
  let e = 0;
  for (const n in t2)
    Object.prototype.hasOwnProperty.call(t2, n) && e++;
  return e;
}
function lt(t2, e) {
  for (const n in t2)
    Object.prototype.hasOwnProperty.call(t2, n) && e(n, t2[n]);
}
function ft(t2) {
  for (const e in t2)
    if (Object.prototype.hasOwnProperty.call(t2, e))
      return false;
  return true;
}
var dt = class {
  constructor(t2, e, n) {
    e === void 0 ? e = 0 : e > t2.length && L2(), n === void 0 ? n = t2.length - e : n > t2.length - e && L2(), this.segments = t2, this.offset = e, this.len = n;
  }
  get length() {
    return this.len;
  }
  isEqual(t2) {
    return dt.comparator(this, t2) === 0;
  }
  child(t2) {
    const e = this.segments.slice(this.offset, this.limit());
    return t2 instanceof dt ? t2.forEach((t3) => {
      e.push(t3);
    }) : e.push(t2), this.construct(e);
  }
  limit() {
    return this.offset + this.length;
  }
  popFirst(t2) {
    return t2 = t2 === void 0 ? 1 : t2, this.construct(this.segments, this.offset + t2, this.length - t2);
  }
  popLast() {
    return this.construct(this.segments, this.offset, this.length - 1);
  }
  firstSegment() {
    return this.segments[this.offset];
  }
  lastSegment() {
    return this.get(this.length - 1);
  }
  get(t2) {
    return this.segments[this.offset + t2];
  }
  isEmpty() {
    return this.length === 0;
  }
  isPrefixOf(t2) {
    if (t2.length < this.length)
      return false;
    for (let e = 0; e < this.length; e++)
      if (this.get(e) !== t2.get(e))
        return false;
    return true;
  }
  isImmediateParentOf(t2) {
    if (this.length + 1 !== t2.length)
      return false;
    for (let e = 0; e < this.length; e++)
      if (this.get(e) !== t2.get(e))
        return false;
    return true;
  }
  forEach(t2) {
    for (let e = this.offset, n = this.limit(); e < n; e++)
      t2(this.segments[e]);
  }
  toArray() {
    return this.segments.slice(this.offset, this.limit());
  }
  static comparator(t2, e) {
    const n = Math.min(t2.length, e.length);
    for (let s = 0; s < n; s++) {
      const n2 = t2.get(s), i = e.get(s);
      if (n2 < i)
        return -1;
      if (n2 > i)
        return 1;
    }
    return t2.length < e.length ? -1 : t2.length > e.length ? 1 : 0;
  }
};
var _t = class extends dt {
  construct(t2, e, n) {
    return new _t(t2, e, n);
  }
  canonicalString() {
    return this.toArray().join("/");
  }
  toString() {
    return this.canonicalString();
  }
  static fromString(...t2) {
    const e = [];
    for (const n of t2) {
      if (n.indexOf("//") >= 0)
        throw new Q2(K2.INVALID_ARGUMENT, `Invalid segment (${n}). Paths must not contain // in them.`);
      e.push(...n.split("/").filter((t3) => t3.length > 0));
    }
    return new _t(e);
  }
  static emptyPath() {
    return new _t([]);
  }
};
var wt = /^[_a-zA-Z][_a-zA-Z0-9]*$/;
var mt = class extends dt {
  construct(t2, e, n) {
    return new mt(t2, e, n);
  }
  static isValidIdentifier(t2) {
    return wt.test(t2);
  }
  canonicalString() {
    return this.toArray().map((t2) => (t2 = t2.replace(/\\/g, "\\\\").replace(/`/g, "\\`"), mt.isValidIdentifier(t2) || (t2 = "`" + t2 + "`"), t2)).join(".");
  }
  toString() {
    return this.canonicalString();
  }
  isKeyField() {
    return this.length === 1 && this.get(0) === "__name__";
  }
  static keyField() {
    return new mt(["__name__"]);
  }
  static fromServerFormat(t2) {
    const e = [];
    let n = "", s = 0;
    const i = () => {
      if (n.length === 0)
        throw new Q2(K2.INVALID_ARGUMENT, `Invalid field path (${t2}). Paths must not be empty, begin with '.', end with '.', or contain '..'`);
      e.push(n), n = "";
    };
    let r = false;
    for (; s < t2.length; ) {
      const e2 = t2[s];
      if (e2 === "\\") {
        if (s + 1 === t2.length)
          throw new Q2(K2.INVALID_ARGUMENT, "Path has trailing escape character: " + t2);
        const e3 = t2[s + 1];
        if (e3 !== "\\" && e3 !== "." && e3 !== "`")
          throw new Q2(K2.INVALID_ARGUMENT, "Path has invalid escape sequence: " + t2);
        n += e3, s += 2;
      } else
        e2 === "`" ? (r = !r, s++) : e2 !== "." || r ? (n += e2, s++) : (i(), s++);
    }
    if (i(), r)
      throw new Q2(K2.INVALID_ARGUMENT, "Unterminated ` in path: " + t2);
    return new mt(e);
  }
  static emptyPath() {
    return new mt([]);
  }
};
var gt = class {
  constructor(t2) {
    this.fields = t2, t2.sort(mt.comparator);
  }
  covers(t2) {
    for (const e of this.fields)
      if (e.isPrefixOf(t2))
        return true;
    return false;
  }
  isEqual(t2) {
    return ot(this.fields, t2.fields, (t3, e) => t3.isEqual(e));
  }
};
function yt() {
  return typeof atob != "undefined";
}
var pt = class {
  constructor(t2) {
    this.binaryString = t2;
  }
  static fromBase64String(t2) {
    const e = atob(t2);
    return new pt(e);
  }
  static fromUint8Array(t2) {
    const e = function(t3) {
      let e2 = "";
      for (let n = 0; n < t3.length; ++n)
        e2 += String.fromCharCode(t3[n]);
      return e2;
    }(t2);
    return new pt(e);
  }
  [Symbol.iterator]() {
    let t2 = 0;
    return {
      next: () => t2 < this.binaryString.length ? {
        value: this.binaryString.charCodeAt(t2++),
        done: false
      } : {
        value: void 0,
        done: true
      }
    };
  }
  toBase64() {
    return t2 = this.binaryString, btoa(t2);
    var t2;
  }
  toUint8Array() {
    return function(t2) {
      const e = new Uint8Array(t2.length);
      for (let n = 0; n < t2.length; n++)
        e[n] = t2.charCodeAt(n);
      return e;
    }(this.binaryString);
  }
  approximateByteSize() {
    return 2 * this.binaryString.length;
  }
  compareTo(t2) {
    return rt(this.binaryString, t2.binaryString);
  }
  isEqual(t2) {
    return this.binaryString === t2.binaryString;
  }
};
pt.EMPTY_BYTE_STRING = new pt("");
var It = new RegExp(/^\d{4}-\d\d-\d\dT\d\d:\d\d:\d\d(?:\.(\d+))?Z$/);
function Tt(t2) {
  if (U2(!!t2), typeof t2 == "string") {
    let e = 0;
    const n = It.exec(t2);
    if (U2(!!n), n[1]) {
      let t3 = n[1];
      t3 = (t3 + "000000000").substr(0, 9), e = Number(t3);
    }
    const s = new Date(t2);
    return {
      seconds: Math.floor(s.getTime() / 1e3),
      nanos: e
    };
  }
  return {
    seconds: Et(t2.seconds),
    nanos: Et(t2.nanos)
  };
}
function Et(t2) {
  return typeof t2 == "number" ? t2 : typeof t2 == "string" ? Number(t2) : 0;
}
function At(t2) {
  return typeof t2 == "string" ? pt.fromBase64String(t2) : pt.fromUint8Array(t2);
}
function Rt(t2) {
  var e, n;
  return ((n = (((e = t2 == null ? void 0 : t2.mapValue) === null || e === void 0 ? void 0 : e.fields) || {}).__type__) === null || n === void 0 ? void 0 : n.stringValue) === "server_timestamp";
}
function bt(t2) {
  const e = t2.mapValue.fields.__previous_value__;
  return Rt(e) ? bt(e) : e;
}
function Pt(t2) {
  const e = Tt(t2.mapValue.fields.__local_write_time__.timestampValue);
  return new at(e.seconds, e.nanos);
}
var Vt = class {
  constructor(t2, e, n, s, i, r, o, u) {
    this.databaseId = t2, this.appId = e, this.persistenceKey = n, this.host = s, this.ssl = i, this.forceLongPolling = r, this.autoDetectLongPolling = o, this.useFetchStreams = u;
  }
};
var vt = class {
  constructor(t2, e) {
    this.projectId = t2, this.database = e || "(default)";
  }
  static empty() {
    return new vt("", "");
  }
  get isDefaultDatabase() {
    return this.database === "(default)";
  }
  isEqual(t2) {
    return t2 instanceof vt && t2.projectId === this.projectId && t2.database === this.database;
  }
};
function St(t2) {
  return t2 == null;
}
function Dt(t2) {
  return t2 === 0 && 1 / t2 == -1 / 0;
}
function Ct(t2) {
  return typeof t2 == "number" && Number.isInteger(t2) && !Dt(t2) && t2 <= Number.MAX_SAFE_INTEGER && t2 >= Number.MIN_SAFE_INTEGER;
}
var xt = class {
  constructor(t2) {
    this.path = t2;
  }
  static fromPath(t2) {
    return new xt(_t.fromString(t2));
  }
  static fromName(t2) {
    return new xt(_t.fromString(t2).popFirst(5));
  }
  static empty() {
    return new xt(_t.emptyPath());
  }
  get collectionGroup() {
    return this.path.popLast().lastSegment();
  }
  hasCollectionId(t2) {
    return this.path.length >= 2 && this.path.get(this.path.length - 2) === t2;
  }
  getCollectionGroup() {
    return this.path.get(this.path.length - 2);
  }
  getCollectionPath() {
    return this.path.popLast();
  }
  isEqual(t2) {
    return t2 !== null && _t.comparator(this.path, t2.path) === 0;
  }
  toString() {
    return this.path.toString();
  }
  static comparator(t2, e) {
    return _t.comparator(t2.path, e.path);
  }
  static isDocumentKey(t2) {
    return t2.length % 2 == 0;
  }
  static fromSegments(t2) {
    return new xt(new _t(t2.slice()));
  }
};
var Nt = {
  mapValue: {
    fields: {
      __type__: {
        stringValue: "__max__"
      }
    }
  }
};
var kt = {
  nullValue: "NULL_VALUE"
};
function Mt(t2) {
  return "nullValue" in t2 ? 0 : "booleanValue" in t2 ? 1 : "integerValue" in t2 || "doubleValue" in t2 ? 2 : "timestampValue" in t2 ? 3 : "stringValue" in t2 ? 5 : "bytesValue" in t2 ? 6 : "referenceValue" in t2 ? 7 : "geoPointValue" in t2 ? 8 : "arrayValue" in t2 ? 9 : "mapValue" in t2 ? Rt(t2) ? 4 : Ht(t2) ? 9 : 10 : L2();
}
function Ot(t2, e) {
  if (t2 === e)
    return true;
  const n = Mt(t2);
  if (n !== Mt(e))
    return false;
  switch (n) {
    case 0:
    case 9007199254740991:
      return true;
    case 1:
      return t2.booleanValue === e.booleanValue;
    case 4:
      return Pt(t2).isEqual(Pt(e));
    case 3:
      return function(t3, e2) {
        if (typeof t3.timestampValue == "string" && typeof e2.timestampValue == "string" && t3.timestampValue.length === e2.timestampValue.length)
          return t3.timestampValue === e2.timestampValue;
        const n2 = Tt(t3.timestampValue), s = Tt(e2.timestampValue);
        return n2.seconds === s.seconds && n2.nanos === s.nanos;
      }(t2, e);
    case 5:
      return t2.stringValue === e.stringValue;
    case 6:
      return function(t3, e2) {
        return At(t3.bytesValue).isEqual(At(e2.bytesValue));
      }(t2, e);
    case 7:
      return t2.referenceValue === e.referenceValue;
    case 8:
      return function(t3, e2) {
        return Et(t3.geoPointValue.latitude) === Et(e2.geoPointValue.latitude) && Et(t3.geoPointValue.longitude) === Et(e2.geoPointValue.longitude);
      }(t2, e);
    case 2:
      return function(t3, e2) {
        if ("integerValue" in t3 && "integerValue" in e2)
          return Et(t3.integerValue) === Et(e2.integerValue);
        if ("doubleValue" in t3 && "doubleValue" in e2) {
          const n2 = Et(t3.doubleValue), s = Et(e2.doubleValue);
          return n2 === s ? Dt(n2) === Dt(s) : isNaN(n2) && isNaN(s);
        }
        return false;
      }(t2, e);
    case 9:
      return ot(t2.arrayValue.values || [], e.arrayValue.values || [], Ot);
    case 10:
      return function(t3, e2) {
        const n2 = t3.mapValue.fields || {}, s = e2.mapValue.fields || {};
        if (ht(n2) !== ht(s))
          return false;
        for (const t4 in n2)
          if (n2.hasOwnProperty(t4) && (s[t4] === void 0 || !Ot(n2[t4], s[t4])))
            return false;
        return true;
      }(t2, e);
    default:
      return L2();
  }
}
function Ft(t2, e) {
  return (t2.values || []).find((t3) => Ot(t3, e)) !== void 0;
}
function $t(t2, e) {
  if (t2 === e)
    return 0;
  const n = Mt(t2), s = Mt(e);
  if (n !== s)
    return rt(n, s);
  switch (n) {
    case 0:
    case 9007199254740991:
      return 0;
    case 1:
      return rt(t2.booleanValue, e.booleanValue);
    case 2:
      return function(t3, e2) {
        const n2 = Et(t3.integerValue || t3.doubleValue), s2 = Et(e2.integerValue || e2.doubleValue);
        return n2 < s2 ? -1 : n2 > s2 ? 1 : n2 === s2 ? 0 : isNaN(n2) ? isNaN(s2) ? 0 : -1 : 1;
      }(t2, e);
    case 3:
      return Bt(t2.timestampValue, e.timestampValue);
    case 4:
      return Bt(Pt(t2), Pt(e));
    case 5:
      return rt(t2.stringValue, e.stringValue);
    case 6:
      return function(t3, e2) {
        const n2 = At(t3), s2 = At(e2);
        return n2.compareTo(s2);
      }(t2.bytesValue, e.bytesValue);
    case 7:
      return function(t3, e2) {
        const n2 = t3.split("/"), s2 = e2.split("/");
        for (let t4 = 0; t4 < n2.length && t4 < s2.length; t4++) {
          const e3 = rt(n2[t4], s2[t4]);
          if (e3 !== 0)
            return e3;
        }
        return rt(n2.length, s2.length);
      }(t2.referenceValue, e.referenceValue);
    case 8:
      return function(t3, e2) {
        const n2 = rt(Et(t3.latitude), Et(e2.latitude));
        if (n2 !== 0)
          return n2;
        return rt(Et(t3.longitude), Et(e2.longitude));
      }(t2.geoPointValue, e.geoPointValue);
    case 9:
      return function(t3, e2) {
        const n2 = t3.values || [], s2 = e2.values || [];
        for (let t4 = 0; t4 < n2.length && t4 < s2.length; ++t4) {
          const e3 = $t(n2[t4], s2[t4]);
          if (e3)
            return e3;
        }
        return rt(n2.length, s2.length);
      }(t2.arrayValue, e.arrayValue);
    case 10:
      return function(t3, e2) {
        const n2 = t3.fields || {}, s2 = Object.keys(n2), i = e2.fields || {}, r = Object.keys(i);
        s2.sort(), r.sort();
        for (let t4 = 0; t4 < s2.length && t4 < r.length; ++t4) {
          const e3 = rt(s2[t4], r[t4]);
          if (e3 !== 0)
            return e3;
          const o = $t(n2[s2[t4]], i[r[t4]]);
          if (o !== 0)
            return o;
        }
        return rt(s2.length, r.length);
      }(t2.mapValue, e.mapValue);
    default:
      throw L2();
  }
}
function Bt(t2, e) {
  if (typeof t2 == "string" && typeof e == "string" && t2.length === e.length)
    return rt(t2, e);
  const n = Tt(t2), s = Tt(e), i = rt(n.seconds, s.seconds);
  return i !== 0 ? i : rt(n.nanos, s.nanos);
}
function Lt(t2) {
  return Ut(t2);
}
function Ut(t2) {
  return "nullValue" in t2 ? "null" : "booleanValue" in t2 ? "" + t2.booleanValue : "integerValue" in t2 ? "" + t2.integerValue : "doubleValue" in t2 ? "" + t2.doubleValue : "timestampValue" in t2 ? function(t3) {
    const e2 = Tt(t3);
    return `time(${e2.seconds},${e2.nanos})`;
  }(t2.timestampValue) : "stringValue" in t2 ? t2.stringValue : "bytesValue" in t2 ? At(t2.bytesValue).toBase64() : "referenceValue" in t2 ? (n = t2.referenceValue, xt.fromName(n).toString()) : "geoPointValue" in t2 ? `geo(${(e = t2.geoPointValue).latitude},${e.longitude})` : "arrayValue" in t2 ? function(t3) {
    let e2 = "[", n2 = true;
    for (const s of t3.values || [])
      n2 ? n2 = false : e2 += ",", e2 += Ut(s);
    return e2 + "]";
  }(t2.arrayValue) : "mapValue" in t2 ? function(t3) {
    const e2 = Object.keys(t3.fields || {}).sort();
    let n2 = "{", s = true;
    for (const i of e2)
      s ? s = false : n2 += ",", n2 += `${i}:${Ut(t3.fields[i])}`;
    return n2 + "}";
  }(t2.mapValue) : L2();
  var e, n;
}
function qt(t2, e) {
  return {
    referenceValue: `projects/${t2.projectId}/databases/${t2.database}/documents/${e.path.canonicalString()}`
  };
}
function Gt(t2) {
  return !!t2 && "integerValue" in t2;
}
function Kt(t2) {
  return !!t2 && "arrayValue" in t2;
}
function Qt(t2) {
  return !!t2 && "nullValue" in t2;
}
function jt(t2) {
  return !!t2 && "doubleValue" in t2 && isNaN(Number(t2.doubleValue));
}
function Wt(t2) {
  return !!t2 && "mapValue" in t2;
}
function zt(t2) {
  if (t2.geoPointValue)
    return {
      geoPointValue: Object.assign({}, t2.geoPointValue)
    };
  if (t2.timestampValue && typeof t2.timestampValue == "object")
    return {
      timestampValue: Object.assign({}, t2.timestampValue)
    };
  if (t2.mapValue) {
    const e = {
      mapValue: {
        fields: {}
      }
    };
    return lt(t2.mapValue.fields, (t3, n) => e.mapValue.fields[t3] = zt(n)), e;
  }
  if (t2.arrayValue) {
    const e = {
      arrayValue: {
        values: []
      }
    };
    for (let n = 0; n < (t2.arrayValue.values || []).length; ++n)
      e.arrayValue.values[n] = zt(t2.arrayValue.values[n]);
    return e;
  }
  return Object.assign({}, t2);
}
function Ht(t2) {
  return (((t2.mapValue || {}).fields || {}).__type__ || {}).stringValue === "__max__";
}
function Jt(t2, e) {
  return t2 === void 0 ? e : e === void 0 || $t(t2, e) > 0 ? t2 : e;
}
function Yt(t2, e) {
  return t2 === void 0 ? e : e === void 0 || $t(t2, e) < 0 ? t2 : e;
}
var Xt = class {
  constructor(t2) {
    this.value = t2;
  }
  static empty() {
    return new Xt({
      mapValue: {}
    });
  }
  field(t2) {
    if (t2.isEmpty())
      return this.value;
    {
      let e = this.value;
      for (let n = 0; n < t2.length - 1; ++n)
        if (e = (e.mapValue.fields || {})[t2.get(n)], !Wt(e))
          return null;
      return e = (e.mapValue.fields || {})[t2.lastSegment()], e || null;
    }
  }
  set(t2, e) {
    this.getFieldsMap(t2.popLast())[t2.lastSegment()] = zt(e);
  }
  setAll(t2) {
    let e = mt.emptyPath(), n = {}, s = [];
    t2.forEach((t3, i2) => {
      if (!e.isImmediateParentOf(i2)) {
        const t4 = this.getFieldsMap(e);
        this.applyChanges(t4, n, s), n = {}, s = [], e = i2.popLast();
      }
      t3 ? n[i2.lastSegment()] = zt(t3) : s.push(i2.lastSegment());
    });
    const i = this.getFieldsMap(e);
    this.applyChanges(i, n, s);
  }
  delete(t2) {
    const e = this.field(t2.popLast());
    Wt(e) && e.mapValue.fields && delete e.mapValue.fields[t2.lastSegment()];
  }
  isEqual(t2) {
    return Ot(this.value, t2.value);
  }
  getFieldsMap(t2) {
    let e = this.value;
    e.mapValue.fields || (e.mapValue = {
      fields: {}
    });
    for (let n = 0; n < t2.length; ++n) {
      let s = e.mapValue.fields[t2.get(n)];
      Wt(s) && s.mapValue.fields || (s = {
        mapValue: {
          fields: {}
        }
      }, e.mapValue.fields[t2.get(n)] = s), e = s;
    }
    return e.mapValue.fields;
  }
  applyChanges(t2, e, n) {
    lt(e, (e2, n2) => t2[e2] = n2);
    for (const e2 of n)
      delete t2[e2];
  }
  clone() {
    return new Xt(zt(this.value));
  }
};
function Zt(t2) {
  const e = [];
  return lt(t2.fields, (t3, n) => {
    const s = new mt([t3]);
    if (Wt(n)) {
      const t4 = Zt(n.mapValue).fields;
      if (t4.length === 0)
        e.push(s);
      else
        for (const n2 of t4)
          e.push(s.child(n2));
    } else
      e.push(s);
  }), new gt(e);
}
var te = class {
  constructor(t2, e, n, s, i, r) {
    this.key = t2, this.documentType = e, this.version = n, this.readTime = s, this.data = i, this.documentState = r;
  }
  static newInvalidDocument(t2) {
    return new te(t2, 0, ct.min(), ct.min(), Xt.empty(), 0);
  }
  static newFoundDocument(t2, e, n) {
    return new te(t2, 1, e, ct.min(), n, 0);
  }
  static newNoDocument(t2, e) {
    return new te(t2, 2, e, ct.min(), Xt.empty(), 0);
  }
  static newUnknownDocument(t2, e) {
    return new te(t2, 3, e, ct.min(), Xt.empty(), 2);
  }
  convertToFoundDocument(t2, e) {
    return this.version = t2, this.documentType = 1, this.data = e, this.documentState = 0, this;
  }
  convertToNoDocument(t2) {
    return this.version = t2, this.documentType = 2, this.data = Xt.empty(), this.documentState = 0, this;
  }
  convertToUnknownDocument(t2) {
    return this.version = t2, this.documentType = 3, this.data = Xt.empty(), this.documentState = 2, this;
  }
  setHasCommittedMutations() {
    return this.documentState = 2, this;
  }
  setHasLocalMutations() {
    return this.documentState = 1, this;
  }
  setReadTime(t2) {
    return this.readTime = t2, this;
  }
  get hasLocalMutations() {
    return this.documentState === 1;
  }
  get hasCommittedMutations() {
    return this.documentState === 2;
  }
  get hasPendingWrites() {
    return this.hasLocalMutations || this.hasCommittedMutations;
  }
  isValidDocument() {
    return this.documentType !== 0;
  }
  isFoundDocument() {
    return this.documentType === 1;
  }
  isNoDocument() {
    return this.documentType === 2;
  }
  isUnknownDocument() {
    return this.documentType === 3;
  }
  isEqual(t2) {
    return t2 instanceof te && this.key.isEqual(t2.key) && this.version.isEqual(t2.version) && this.documentType === t2.documentType && this.documentState === t2.documentState && this.data.isEqual(t2.data);
  }
  mutableCopy() {
    return new te(this.key, this.documentType, this.version, this.readTime, this.data.clone(), this.documentState);
  }
  toString() {
    return `Document(${this.key}, ${this.version}, ${JSON.stringify(this.data.value)}, {documentType: ${this.documentType}}), {documentState: ${this.documentState}})`;
  }
};
var ee = class {
  constructor(t2, e, n, s) {
    this.indexId = t2, this.collectionGroup = e, this.fields = n, this.indexState = s;
  }
};
function ne(t2) {
  return t2.fields.find((t3) => t3.kind === 2);
}
function se(t2) {
  return t2.fields.filter((t3) => t3.kind !== 2);
}
ee.UNKNOWN_ID = -1;
var ie = class {
  constructor(t2, e) {
    this.fieldPath = t2, this.kind = e;
  }
};
var re = class {
  constructor(t2, e) {
    this.sequenceNumber = t2, this.offset = e;
  }
  static empty() {
    return new re(0, ae.min());
  }
};
function oe(t2, e) {
  const n = t2.toTimestamp().seconds, s = t2.toTimestamp().nanoseconds + 1, i = ct.fromTimestamp(s === 1e9 ? new at(n + 1, 0) : new at(n, s));
  return new ae(i, xt.empty(), e);
}
function ue(t2) {
  return new ae(t2.readTime, t2.key, -1);
}
var ae = class {
  constructor(t2, e, n) {
    this.readTime = t2, this.documentKey = e, this.largestBatchId = n;
  }
  static min() {
    return new ae(ct.min(), xt.empty(), -1);
  }
  static max() {
    return new ae(ct.max(), xt.empty(), -1);
  }
};
function ce(t2, e) {
  let n = t2.readTime.compareTo(e.readTime);
  return n !== 0 ? n : (n = xt.comparator(t2.documentKey, e.documentKey), n !== 0 ? n : rt(t2.largestBatchId, e.largestBatchId));
}
var he = class {
  constructor(t2, e = null, n = [], s = [], i = null, r = null, o = null) {
    this.path = t2, this.collectionGroup = e, this.orderBy = n, this.filters = s, this.limit = i, this.startAt = r, this.endAt = o, this.P = null;
  }
};
function le(t2, e = null, n = [], s = [], i = null, r = null, o = null) {
  return new he(t2, e, n, s, i, r, o);
}
function fe(t2) {
  const e = G(t2);
  if (e.P === null) {
    let t3 = e.path.canonicalString();
    e.collectionGroup !== null && (t3 += "|cg:" + e.collectionGroup), t3 += "|f:", t3 += e.filters.map((t4) => {
      return (e2 = t4).field.canonicalString() + e2.op.toString() + Lt(e2.value);
      var e2;
    }).join(","), t3 += "|ob:", t3 += e.orderBy.map((t4) => function(t5) {
      return t5.field.canonicalString() + t5.dir;
    }(t4)).join(","), St(e.limit) || (t3 += "|l:", t3 += e.limit), e.startAt && (t3 += "|lb:", t3 += e.startAt.inclusive ? "b:" : "a:", t3 += e.startAt.position.map((t4) => Lt(t4)).join(",")), e.endAt && (t3 += "|ub:", t3 += e.endAt.inclusive ? "a:" : "b:", t3 += e.endAt.position.map((t4) => Lt(t4)).join(",")), e.P = t3;
  }
  return e.P;
}
function de(t2) {
  let e = t2.path.canonicalString();
  return t2.collectionGroup !== null && (e += " collectionGroup=" + t2.collectionGroup), t2.filters.length > 0 && (e += `, filters: [${t2.filters.map((t3) => {
    return `${(e2 = t3).field.canonicalString()} ${e2.op} ${Lt(e2.value)}`;
    var e2;
  }).join(", ")}]`), St(t2.limit) || (e += ", limit: " + t2.limit), t2.orderBy.length > 0 && (e += `, orderBy: [${t2.orderBy.map((t3) => function(t4) {
    return `${t4.field.canonicalString()} (${t4.dir})`;
  }(t3)).join(", ")}]`), t2.startAt && (e += ", startAt: ", e += t2.startAt.inclusive ? "b:" : "a:", e += t2.startAt.position.map((t3) => Lt(t3)).join(",")), t2.endAt && (e += ", endAt: ", e += t2.endAt.inclusive ? "a:" : "b:", e += t2.endAt.position.map((t3) => Lt(t3)).join(",")), `Target(${e})`;
}
function _e(t2, e) {
  if (t2.limit !== e.limit)
    return false;
  if (t2.orderBy.length !== e.orderBy.length)
    return false;
  for (let n2 = 0; n2 < t2.orderBy.length; n2++)
    if (!ve(t2.orderBy[n2], e.orderBy[n2]))
      return false;
  if (t2.filters.length !== e.filters.length)
    return false;
  for (let i = 0; i < t2.filters.length; i++)
    if (n = t2.filters[i], s = e.filters[i], n.op !== s.op || !n.field.isEqual(s.field) || !Ot(n.value, s.value))
      return false;
  var n, s;
  return t2.collectionGroup === e.collectionGroup && (!!t2.path.isEqual(e.path) && (!!De(t2.startAt, e.startAt) && De(t2.endAt, e.endAt)));
}
function we(t2) {
  return xt.isDocumentKey(t2.path) && t2.collectionGroup === null && t2.filters.length === 0;
}
function me(t2, e) {
  return t2.filters.filter((t3) => t3 instanceof ge && t3.field.isEqual(e));
}
var ge = class extends class {
} {
  constructor(t2, e, n) {
    super(), this.field = t2, this.op = e, this.value = n;
  }
  static create(t2, e, n) {
    return t2.isKeyField() ? e === "in" || e === "not-in" ? this.V(t2, e, n) : new ye(t2, e, n) : e === "array-contains" ? new Ee(t2, n) : e === "in" ? new Ae(t2, n) : e === "not-in" ? new Re(t2, n) : e === "array-contains-any" ? new be(t2, n) : new ge(t2, e, n);
  }
  static V(t2, e, n) {
    return e === "in" ? new pe(t2, n) : new Ie(t2, n);
  }
  matches(t2) {
    const e = t2.data.field(this.field);
    return this.op === "!=" ? e !== null && this.v($t(e, this.value)) : e !== null && Mt(this.value) === Mt(e) && this.v($t(e, this.value));
  }
  v(t2) {
    switch (this.op) {
      case "<":
        return t2 < 0;
      case "<=":
        return t2 <= 0;
      case "==":
        return t2 === 0;
      case "!=":
        return t2 !== 0;
      case ">":
        return t2 > 0;
      case ">=":
        return t2 >= 0;
      default:
        return L2();
    }
  }
  S() {
    return ["<", "<=", ">", ">=", "!=", "not-in"].indexOf(this.op) >= 0;
  }
};
var ye = class extends ge {
  constructor(t2, e, n) {
    super(t2, e, n), this.key = xt.fromName(n.referenceValue);
  }
  matches(t2) {
    const e = xt.comparator(t2.key, this.key);
    return this.v(e);
  }
};
var pe = class extends ge {
  constructor(t2, e) {
    super(t2, "in", e), this.keys = Te("in", e);
  }
  matches(t2) {
    return this.keys.some((e) => e.isEqual(t2.key));
  }
};
var Ie = class extends ge {
  constructor(t2, e) {
    super(t2, "not-in", e), this.keys = Te("not-in", e);
  }
  matches(t2) {
    return !this.keys.some((e) => e.isEqual(t2.key));
  }
};
function Te(t2, e) {
  var n;
  return (((n = e.arrayValue) === null || n === void 0 ? void 0 : n.values) || []).map((t3) => xt.fromName(t3.referenceValue));
}
var Ee = class extends ge {
  constructor(t2, e) {
    super(t2, "array-contains", e);
  }
  matches(t2) {
    const e = t2.data.field(this.field);
    return Kt(e) && Ft(e.arrayValue, this.value);
  }
};
var Ae = class extends ge {
  constructor(t2, e) {
    super(t2, "in", e);
  }
  matches(t2) {
    const e = t2.data.field(this.field);
    return e !== null && Ft(this.value.arrayValue, e);
  }
};
var Re = class extends ge {
  constructor(t2, e) {
    super(t2, "not-in", e);
  }
  matches(t2) {
    if (Ft(this.value.arrayValue, {
      nullValue: "NULL_VALUE"
    }))
      return false;
    const e = t2.data.field(this.field);
    return e !== null && !Ft(this.value.arrayValue, e);
  }
};
var be = class extends ge {
  constructor(t2, e) {
    super(t2, "array-contains-any", e);
  }
  matches(t2) {
    const e = t2.data.field(this.field);
    return !(!Kt(e) || !e.arrayValue.values) && e.arrayValue.values.some((t3) => Ft(this.value.arrayValue, t3));
  }
};
var Pe = class {
  constructor(t2, e) {
    this.position = t2, this.inclusive = e;
  }
};
var Ve = class {
  constructor(t2, e = "asc") {
    this.field = t2, this.dir = e;
  }
};
function ve(t2, e) {
  return t2.dir === e.dir && t2.field.isEqual(e.field);
}
function Se(t2, e, n) {
  let s = 0;
  for (let i = 0; i < t2.position.length; i++) {
    const r = e[i], o = t2.position[i];
    if (r.field.isKeyField())
      s = xt.comparator(xt.fromName(o.referenceValue), n.key);
    else {
      s = $t(o, n.data.field(r.field));
    }
    if (r.dir === "desc" && (s *= -1), s !== 0)
      break;
  }
  return s;
}
function De(t2, e) {
  if (t2 === null)
    return e === null;
  if (e === null)
    return false;
  if (t2.inclusive !== e.inclusive || t2.position.length !== e.position.length)
    return false;
  for (let n = 0; n < t2.position.length; n++) {
    if (!Ot(t2.position[n], e.position[n]))
      return false;
  }
  return true;
}
var Ce = class {
  constructor(t2, e = null, n = [], s = [], i = null, r = "F", o = null, u = null) {
    this.path = t2, this.collectionGroup = e, this.explicitOrderBy = n, this.filters = s, this.limit = i, this.limitType = r, this.startAt = o, this.endAt = u, this.D = null, this.C = null, this.startAt, this.endAt;
  }
};
function xe(t2, e, n, s, i, r, o, u) {
  return new Ce(t2, e, n, s, i, r, o, u);
}
function Ne(t2) {
  return new Ce(t2);
}
function ke(t2) {
  return !St(t2.limit) && t2.limitType === "F";
}
function Me(t2) {
  return !St(t2.limit) && t2.limitType === "L";
}
function Oe(t2) {
  return t2.explicitOrderBy.length > 0 ? t2.explicitOrderBy[0].field : null;
}
function Fe(t2) {
  for (const e of t2.filters)
    if (e.S())
      return e.field;
  return null;
}
function $e(t2) {
  return t2.collectionGroup !== null;
}
function Be(t2) {
  const e = G(t2);
  if (e.D === null) {
    e.D = [];
    const t3 = Fe(e), n = Oe(e);
    if (t3 !== null && n === null)
      t3.isKeyField() || e.D.push(new Ve(t3)), e.D.push(new Ve(mt.keyField(), "asc"));
    else {
      let t4 = false;
      for (const n2 of e.explicitOrderBy)
        e.D.push(n2), n2.field.isKeyField() && (t4 = true);
      if (!t4) {
        const t5 = e.explicitOrderBy.length > 0 ? e.explicitOrderBy[e.explicitOrderBy.length - 1].dir : "asc";
        e.D.push(new Ve(mt.keyField(), t5));
      }
    }
  }
  return e.D;
}
function Le(t2) {
  const e = G(t2);
  if (!e.C)
    if (e.limitType === "F")
      e.C = le(e.path, e.collectionGroup, Be(e), e.filters, e.limit, e.startAt, e.endAt);
    else {
      const t3 = [];
      for (const n2 of Be(e)) {
        const e2 = n2.dir === "desc" ? "asc" : "desc";
        t3.push(new Ve(n2.field, e2));
      }
      const n = e.endAt ? new Pe(e.endAt.position, !e.endAt.inclusive) : null, s = e.startAt ? new Pe(e.startAt.position, !e.startAt.inclusive) : null;
      e.C = le(e.path, e.collectionGroup, t3, e.filters, e.limit, n, s);
    }
  return e.C;
}
function Ue(t2, e, n) {
  return new Ce(t2.path, t2.collectionGroup, t2.explicitOrderBy.slice(), t2.filters.slice(), e, n, t2.startAt, t2.endAt);
}
function qe(t2, e) {
  return _e(Le(t2), Le(e)) && t2.limitType === e.limitType;
}
function Ge(t2) {
  return `${fe(Le(t2))}|lt:${t2.limitType}`;
}
function Ke(t2) {
  return `Query(target=${de(Le(t2))}; limitType=${t2.limitType})`;
}
function Qe(t2, e) {
  return e.isFoundDocument() && function(t3, e2) {
    const n = e2.key.path;
    return t3.collectionGroup !== null ? e2.key.hasCollectionId(t3.collectionGroup) && t3.path.isPrefixOf(n) : xt.isDocumentKey(t3.path) ? t3.path.isEqual(n) : t3.path.isImmediateParentOf(n);
  }(t2, e) && function(t3, e2) {
    for (const n of t3.explicitOrderBy)
      if (!n.field.isKeyField() && e2.data.field(n.field) === null)
        return false;
    return true;
  }(t2, e) && function(t3, e2) {
    for (const n of t3.filters)
      if (!n.matches(e2))
        return false;
    return true;
  }(t2, e) && function(t3, e2) {
    if (t3.startAt && !function(t4, e3, n) {
      const s = Se(t4, e3, n);
      return t4.inclusive ? s <= 0 : s < 0;
    }(t3.startAt, Be(t3), e2))
      return false;
    if (t3.endAt && !function(t4, e3, n) {
      const s = Se(t4, e3, n);
      return t4.inclusive ? s >= 0 : s > 0;
    }(t3.endAt, Be(t3), e2))
      return false;
    return true;
  }(t2, e);
}
function je(t2) {
  return t2.collectionGroup || (t2.path.length % 2 == 1 ? t2.path.lastSegment() : t2.path.get(t2.path.length - 2));
}
function We(t2) {
  return (e, n) => {
    let s = false;
    for (const i of Be(t2)) {
      const t3 = ze(i, e, n);
      if (t3 !== 0)
        return t3;
      s = s || i.field.isKeyField();
    }
    return 0;
  };
}
function ze(t2, e, n) {
  const s = t2.field.isKeyField() ? xt.comparator(e.key, n.key) : function(t3, e2, n2) {
    const s2 = e2.data.field(t3), i = n2.data.field(t3);
    return s2 !== null && i !== null ? $t(s2, i) : L2();
  }(t2.field, e, n);
  switch (t2.dir) {
    case "asc":
      return s;
    case "desc":
      return -1 * s;
    default:
      return L2();
  }
}
function He(t2, e) {
  if (t2.N) {
    if (isNaN(e))
      return {
        doubleValue: "NaN"
      };
    if (e === 1 / 0)
      return {
        doubleValue: "Infinity"
      };
    if (e === -1 / 0)
      return {
        doubleValue: "-Infinity"
      };
  }
  return {
    doubleValue: Dt(e) ? "-0" : e
  };
}
function Je(t2) {
  return {
    integerValue: "" + t2
  };
}
function Ye(t2, e) {
  return Ct(e) ? Je(e) : He(t2, e);
}
var Xe = class {
  constructor() {
    this._ = void 0;
  }
};
function Ze(t2, e, n) {
  return t2 instanceof nn ? function(t3, e2) {
    const n2 = {
      fields: {
        __type__: {
          stringValue: "server_timestamp"
        },
        __local_write_time__: {
          timestampValue: {
            seconds: t3.seconds,
            nanos: t3.nanoseconds
          }
        }
      }
    };
    return e2 && (n2.fields.__previous_value__ = e2), {
      mapValue: n2
    };
  }(n, e) : t2 instanceof sn ? rn(t2, e) : t2 instanceof on ? un(t2, e) : function(t3, e2) {
    const n2 = en(t3, e2), s = cn(n2) + cn(t3.k);
    return Gt(n2) && Gt(t3.k) ? Je(s) : He(t3.M, s);
  }(t2, e);
}
function tn(t2, e, n) {
  return t2 instanceof sn ? rn(t2, e) : t2 instanceof on ? un(t2, e) : n;
}
function en(t2, e) {
  return t2 instanceof an ? Gt(n = e) || function(t3) {
    return !!t3 && "doubleValue" in t3;
  }(n) ? e : {
    integerValue: 0
  } : null;
  var n;
}
var nn = class extends Xe {
};
var sn = class extends Xe {
  constructor(t2) {
    super(), this.elements = t2;
  }
};
function rn(t2, e) {
  const n = hn(e);
  for (const e2 of t2.elements)
    n.some((t3) => Ot(t3, e2)) || n.push(e2);
  return {
    arrayValue: {
      values: n
    }
  };
}
var on = class extends Xe {
  constructor(t2) {
    super(), this.elements = t2;
  }
};
function un(t2, e) {
  let n = hn(e);
  for (const e2 of t2.elements)
    n = n.filter((t3) => !Ot(t3, e2));
  return {
    arrayValue: {
      values: n
    }
  };
}
var an = class extends Xe {
  constructor(t2, e) {
    super(), this.M = t2, this.k = e;
  }
};
function cn(t2) {
  return Et(t2.integerValue || t2.doubleValue);
}
function hn(t2) {
  return Kt(t2) && t2.arrayValue.values ? t2.arrayValue.values.slice() : [];
}
var ln = class {
  constructor(t2, e) {
    this.field = t2, this.transform = e;
  }
};
function fn(t2, e) {
  return t2.field.isEqual(e.field) && function(t3, e2) {
    return t3 instanceof sn && e2 instanceof sn || t3 instanceof on && e2 instanceof on ? ot(t3.elements, e2.elements, Ot) : t3 instanceof an && e2 instanceof an ? Ot(t3.k, e2.k) : t3 instanceof nn && e2 instanceof nn;
  }(t2.transform, e.transform);
}
var dn = class {
  constructor(t2, e) {
    this.version = t2, this.transformResults = e;
  }
};
var _n = class {
  constructor(t2, e) {
    this.updateTime = t2, this.exists = e;
  }
  static none() {
    return new _n();
  }
  static exists(t2) {
    return new _n(void 0, t2);
  }
  static updateTime(t2) {
    return new _n(t2);
  }
  get isNone() {
    return this.updateTime === void 0 && this.exists === void 0;
  }
  isEqual(t2) {
    return this.exists === t2.exists && (this.updateTime ? !!t2.updateTime && this.updateTime.isEqual(t2.updateTime) : !t2.updateTime);
  }
};
function wn(t2, e) {
  return t2.updateTime !== void 0 ? e.isFoundDocument() && e.version.isEqual(t2.updateTime) : t2.exists === void 0 || t2.exists === e.isFoundDocument();
}
var mn = class {
};
function gn(t2, e, n) {
  t2 instanceof En ? function(t3, e2, n2) {
    const s = t3.value.clone(), i = bn(t3.fieldTransforms, e2, n2.transformResults);
    s.setAll(i), e2.convertToFoundDocument(n2.version, s).setHasCommittedMutations();
  }(t2, e, n) : t2 instanceof An ? function(t3, e2, n2) {
    if (!wn(t3.precondition, e2))
      return void e2.convertToUnknownDocument(n2.version);
    const s = bn(t3.fieldTransforms, e2, n2.transformResults), i = e2.data;
    i.setAll(Rn(t3)), i.setAll(s), e2.convertToFoundDocument(n2.version, i).setHasCommittedMutations();
  }(t2, e, n) : function(t3, e2, n2) {
    e2.convertToNoDocument(n2.version).setHasCommittedMutations();
  }(0, e, n);
}
function yn(t2, e, n) {
  t2 instanceof En ? function(t3, e2, n2) {
    if (!wn(t3.precondition, e2))
      return;
    const s = t3.value.clone(), i = Pn(t3.fieldTransforms, n2, e2);
    s.setAll(i), e2.convertToFoundDocument(Tn(e2), s).setHasLocalMutations();
  }(t2, e, n) : t2 instanceof An ? function(t3, e2, n2) {
    if (!wn(t3.precondition, e2))
      return;
    const s = Pn(t3.fieldTransforms, n2, e2), i = e2.data;
    i.setAll(Rn(t3)), i.setAll(s), e2.convertToFoundDocument(Tn(e2), i).setHasLocalMutations();
  }(t2, e, n) : function(t3, e2) {
    wn(t3.precondition, e2) && e2.convertToNoDocument(ct.min());
  }(t2, e);
}
function pn(t2, e) {
  let n = null;
  for (const s of t2.fieldTransforms) {
    const t3 = e.data.field(s.field), i = en(s.transform, t3 || null);
    i != null && (n == null && (n = Xt.empty()), n.set(s.field, i));
  }
  return n || null;
}
function In(t2, e) {
  return t2.type === e.type && (!!t2.key.isEqual(e.key) && (!!t2.precondition.isEqual(e.precondition) && (!!function(t3, e2) {
    return t3 === void 0 && e2 === void 0 || !(!t3 || !e2) && ot(t3, e2, (t4, e3) => fn(t4, e3));
  }(t2.fieldTransforms, e.fieldTransforms) && (t2.type === 0 ? t2.value.isEqual(e.value) : t2.type !== 1 || t2.data.isEqual(e.data) && t2.fieldMask.isEqual(e.fieldMask)))));
}
function Tn(t2) {
  return t2.isFoundDocument() ? t2.version : ct.min();
}
var En = class extends mn {
  constructor(t2, e, n, s = []) {
    super(), this.key = t2, this.value = e, this.precondition = n, this.fieldTransforms = s, this.type = 0;
  }
};
var An = class extends mn {
  constructor(t2, e, n, s, i = []) {
    super(), this.key = t2, this.data = e, this.fieldMask = n, this.precondition = s, this.fieldTransforms = i, this.type = 1;
  }
};
function Rn(t2) {
  const e = /* @__PURE__ */ new Map();
  return t2.fieldMask.fields.forEach((n) => {
    if (!n.isEmpty()) {
      const s = t2.data.field(n);
      e.set(n, s);
    }
  }), e;
}
function bn(t2, e, n) {
  const s = /* @__PURE__ */ new Map();
  U2(t2.length === n.length);
  for (let i = 0; i < n.length; i++) {
    const r = t2[i], o = r.transform, u = e.data.field(r.field);
    s.set(r.field, tn(o, u, n[i]));
  }
  return s;
}
function Pn(t2, e, n) {
  const s = /* @__PURE__ */ new Map();
  for (const i of t2) {
    const t3 = i.transform, r = n.data.field(i.field);
    s.set(i.field, Ze(t3, r, e));
  }
  return s;
}
var Vn = class extends mn {
  constructor(t2, e) {
    super(), this.key = t2, this.precondition = e, this.type = 2, this.fieldTransforms = [];
  }
};
var vn = class extends mn {
  constructor(t2, e) {
    super(), this.key = t2, this.precondition = e, this.type = 3, this.fieldTransforms = [];
  }
};
var Sn = class {
  constructor(t2) {
    this.count = t2;
  }
};
var Dn;
var Cn;
function xn(t2) {
  switch (t2) {
    default:
      return L2();
    case K2.CANCELLED:
    case K2.UNKNOWN:
    case K2.DEADLINE_EXCEEDED:
    case K2.RESOURCE_EXHAUSTED:
    case K2.INTERNAL:
    case K2.UNAVAILABLE:
    case K2.UNAUTHENTICATED:
      return false;
    case K2.INVALID_ARGUMENT:
    case K2.NOT_FOUND:
    case K2.ALREADY_EXISTS:
    case K2.PERMISSION_DENIED:
    case K2.FAILED_PRECONDITION:
    case K2.ABORTED:
    case K2.OUT_OF_RANGE:
    case K2.UNIMPLEMENTED:
    case K2.DATA_LOSS:
      return true;
  }
}
function Nn(t2) {
  if (t2 === void 0)
    return F2("GRPC error has no .code"), K2.UNKNOWN;
  switch (t2) {
    case Dn.OK:
      return K2.OK;
    case Dn.CANCELLED:
      return K2.CANCELLED;
    case Dn.UNKNOWN:
      return K2.UNKNOWN;
    case Dn.DEADLINE_EXCEEDED:
      return K2.DEADLINE_EXCEEDED;
    case Dn.RESOURCE_EXHAUSTED:
      return K2.RESOURCE_EXHAUSTED;
    case Dn.INTERNAL:
      return K2.INTERNAL;
    case Dn.UNAVAILABLE:
      return K2.UNAVAILABLE;
    case Dn.UNAUTHENTICATED:
      return K2.UNAUTHENTICATED;
    case Dn.INVALID_ARGUMENT:
      return K2.INVALID_ARGUMENT;
    case Dn.NOT_FOUND:
      return K2.NOT_FOUND;
    case Dn.ALREADY_EXISTS:
      return K2.ALREADY_EXISTS;
    case Dn.PERMISSION_DENIED:
      return K2.PERMISSION_DENIED;
    case Dn.FAILED_PRECONDITION:
      return K2.FAILED_PRECONDITION;
    case Dn.ABORTED:
      return K2.ABORTED;
    case Dn.OUT_OF_RANGE:
      return K2.OUT_OF_RANGE;
    case Dn.UNIMPLEMENTED:
      return K2.UNIMPLEMENTED;
    case Dn.DATA_LOSS:
      return K2.DATA_LOSS;
    default:
      return L2();
  }
}
(Cn = Dn || (Dn = {}))[Cn.OK = 0] = "OK", Cn[Cn.CANCELLED = 1] = "CANCELLED", Cn[Cn.UNKNOWN = 2] = "UNKNOWN", Cn[Cn.INVALID_ARGUMENT = 3] = "INVALID_ARGUMENT", Cn[Cn.DEADLINE_EXCEEDED = 4] = "DEADLINE_EXCEEDED", Cn[Cn.NOT_FOUND = 5] = "NOT_FOUND", Cn[Cn.ALREADY_EXISTS = 6] = "ALREADY_EXISTS", Cn[Cn.PERMISSION_DENIED = 7] = "PERMISSION_DENIED", Cn[Cn.UNAUTHENTICATED = 16] = "UNAUTHENTICATED", Cn[Cn.RESOURCE_EXHAUSTED = 8] = "RESOURCE_EXHAUSTED", Cn[Cn.FAILED_PRECONDITION = 9] = "FAILED_PRECONDITION", Cn[Cn.ABORTED = 10] = "ABORTED", Cn[Cn.OUT_OF_RANGE = 11] = "OUT_OF_RANGE", Cn[Cn.UNIMPLEMENTED = 12] = "UNIMPLEMENTED", Cn[Cn.INTERNAL = 13] = "INTERNAL", Cn[Cn.UNAVAILABLE = 14] = "UNAVAILABLE", Cn[Cn.DATA_LOSS = 15] = "DATA_LOSS";
var kn = class {
  constructor(t2, e) {
    this.mapKeyFn = t2, this.equalsFn = e, this.inner = {}, this.innerSize = 0;
  }
  get(t2) {
    const e = this.mapKeyFn(t2), n = this.inner[e];
    if (n !== void 0) {
      for (const [e2, s] of n)
        if (this.equalsFn(e2, t2))
          return s;
    }
  }
  has(t2) {
    return this.get(t2) !== void 0;
  }
  set(t2, e) {
    const n = this.mapKeyFn(t2), s = this.inner[n];
    if (s === void 0)
      return this.inner[n] = [[t2, e]], void this.innerSize++;
    for (let n2 = 0; n2 < s.length; n2++)
      if (this.equalsFn(s[n2][0], t2))
        return void (s[n2] = [t2, e]);
    s.push([t2, e]), this.innerSize++;
  }
  delete(t2) {
    const e = this.mapKeyFn(t2), n = this.inner[e];
    if (n === void 0)
      return false;
    for (let s = 0; s < n.length; s++)
      if (this.equalsFn(n[s][0], t2))
        return n.length === 1 ? delete this.inner[e] : n.splice(s, 1), this.innerSize--, true;
    return false;
  }
  forEach(t2) {
    lt(this.inner, (e, n) => {
      for (const [e2, s] of n)
        t2(e2, s);
    });
  }
  isEmpty() {
    return ft(this.inner);
  }
  size() {
    return this.innerSize;
  }
};
var Mn = class {
  constructor(t2, e) {
    this.comparator = t2, this.root = e || Fn.EMPTY;
  }
  insert(t2, e) {
    return new Mn(this.comparator, this.root.insert(t2, e, this.comparator).copy(null, null, Fn.BLACK, null, null));
  }
  remove(t2) {
    return new Mn(this.comparator, this.root.remove(t2, this.comparator).copy(null, null, Fn.BLACK, null, null));
  }
  get(t2) {
    let e = this.root;
    for (; !e.isEmpty(); ) {
      const n = this.comparator(t2, e.key);
      if (n === 0)
        return e.value;
      n < 0 ? e = e.left : n > 0 && (e = e.right);
    }
    return null;
  }
  indexOf(t2) {
    let e = 0, n = this.root;
    for (; !n.isEmpty(); ) {
      const s = this.comparator(t2, n.key);
      if (s === 0)
        return e + n.left.size;
      s < 0 ? n = n.left : (e += n.left.size + 1, n = n.right);
    }
    return -1;
  }
  isEmpty() {
    return this.root.isEmpty();
  }
  get size() {
    return this.root.size;
  }
  minKey() {
    return this.root.minKey();
  }
  maxKey() {
    return this.root.maxKey();
  }
  inorderTraversal(t2) {
    return this.root.inorderTraversal(t2);
  }
  forEach(t2) {
    this.inorderTraversal((e, n) => (t2(e, n), false));
  }
  toString() {
    const t2 = [];
    return this.inorderTraversal((e, n) => (t2.push(`${e}:${n}`), false)), `{${t2.join(", ")}}`;
  }
  reverseTraversal(t2) {
    return this.root.reverseTraversal(t2);
  }
  getIterator() {
    return new On(this.root, null, this.comparator, false);
  }
  getIteratorFrom(t2) {
    return new On(this.root, t2, this.comparator, false);
  }
  getReverseIterator() {
    return new On(this.root, null, this.comparator, true);
  }
  getReverseIteratorFrom(t2) {
    return new On(this.root, t2, this.comparator, true);
  }
};
var On = class {
  constructor(t2, e, n, s) {
    this.isReverse = s, this.nodeStack = [];
    let i = 1;
    for (; !t2.isEmpty(); )
      if (i = e ? n(t2.key, e) : 1, e && s && (i *= -1), i < 0)
        t2 = this.isReverse ? t2.left : t2.right;
      else {
        if (i === 0) {
          this.nodeStack.push(t2);
          break;
        }
        this.nodeStack.push(t2), t2 = this.isReverse ? t2.right : t2.left;
      }
  }
  getNext() {
    let t2 = this.nodeStack.pop();
    const e = {
      key: t2.key,
      value: t2.value
    };
    if (this.isReverse)
      for (t2 = t2.left; !t2.isEmpty(); )
        this.nodeStack.push(t2), t2 = t2.right;
    else
      for (t2 = t2.right; !t2.isEmpty(); )
        this.nodeStack.push(t2), t2 = t2.left;
    return e;
  }
  hasNext() {
    return this.nodeStack.length > 0;
  }
  peek() {
    if (this.nodeStack.length === 0)
      return null;
    const t2 = this.nodeStack[this.nodeStack.length - 1];
    return {
      key: t2.key,
      value: t2.value
    };
  }
};
var Fn = class {
  constructor(t2, e, n, s, i) {
    this.key = t2, this.value = e, this.color = n != null ? n : Fn.RED, this.left = s != null ? s : Fn.EMPTY, this.right = i != null ? i : Fn.EMPTY, this.size = this.left.size + 1 + this.right.size;
  }
  copy(t2, e, n, s, i) {
    return new Fn(t2 != null ? t2 : this.key, e != null ? e : this.value, n != null ? n : this.color, s != null ? s : this.left, i != null ? i : this.right);
  }
  isEmpty() {
    return false;
  }
  inorderTraversal(t2) {
    return this.left.inorderTraversal(t2) || t2(this.key, this.value) || this.right.inorderTraversal(t2);
  }
  reverseTraversal(t2) {
    return this.right.reverseTraversal(t2) || t2(this.key, this.value) || this.left.reverseTraversal(t2);
  }
  min() {
    return this.left.isEmpty() ? this : this.left.min();
  }
  minKey() {
    return this.min().key;
  }
  maxKey() {
    return this.right.isEmpty() ? this.key : this.right.maxKey();
  }
  insert(t2, e, n) {
    let s = this;
    const i = n(t2, s.key);
    return s = i < 0 ? s.copy(null, null, null, s.left.insert(t2, e, n), null) : i === 0 ? s.copy(null, e, null, null, null) : s.copy(null, null, null, null, s.right.insert(t2, e, n)), s.fixUp();
  }
  removeMin() {
    if (this.left.isEmpty())
      return Fn.EMPTY;
    let t2 = this;
    return t2.left.isRed() || t2.left.left.isRed() || (t2 = t2.moveRedLeft()), t2 = t2.copy(null, null, null, t2.left.removeMin(), null), t2.fixUp();
  }
  remove(t2, e) {
    let n, s = this;
    if (e(t2, s.key) < 0)
      s.left.isEmpty() || s.left.isRed() || s.left.left.isRed() || (s = s.moveRedLeft()), s = s.copy(null, null, null, s.left.remove(t2, e), null);
    else {
      if (s.left.isRed() && (s = s.rotateRight()), s.right.isEmpty() || s.right.isRed() || s.right.left.isRed() || (s = s.moveRedRight()), e(t2, s.key) === 0) {
        if (s.right.isEmpty())
          return Fn.EMPTY;
        n = s.right.min(), s = s.copy(n.key, n.value, null, null, s.right.removeMin());
      }
      s = s.copy(null, null, null, null, s.right.remove(t2, e));
    }
    return s.fixUp();
  }
  isRed() {
    return this.color;
  }
  fixUp() {
    let t2 = this;
    return t2.right.isRed() && !t2.left.isRed() && (t2 = t2.rotateLeft()), t2.left.isRed() && t2.left.left.isRed() && (t2 = t2.rotateRight()), t2.left.isRed() && t2.right.isRed() && (t2 = t2.colorFlip()), t2;
  }
  moveRedLeft() {
    let t2 = this.colorFlip();
    return t2.right.left.isRed() && (t2 = t2.copy(null, null, null, null, t2.right.rotateRight()), t2 = t2.rotateLeft(), t2 = t2.colorFlip()), t2;
  }
  moveRedRight() {
    let t2 = this.colorFlip();
    return t2.left.left.isRed() && (t2 = t2.rotateRight(), t2 = t2.colorFlip()), t2;
  }
  rotateLeft() {
    const t2 = this.copy(null, null, Fn.RED, null, this.right.left);
    return this.right.copy(null, null, this.color, t2, null);
  }
  rotateRight() {
    const t2 = this.copy(null, null, Fn.RED, this.left.right, null);
    return this.left.copy(null, null, this.color, null, t2);
  }
  colorFlip() {
    const t2 = this.left.copy(null, null, !this.left.color, null, null), e = this.right.copy(null, null, !this.right.color, null, null);
    return this.copy(null, null, !this.color, t2, e);
  }
  checkMaxDepth() {
    const t2 = this.check();
    return Math.pow(2, t2) <= this.size + 1;
  }
  check() {
    if (this.isRed() && this.left.isRed())
      throw L2();
    if (this.right.isRed())
      throw L2();
    const t2 = this.left.check();
    if (t2 !== this.right.check())
      throw L2();
    return t2 + (this.isRed() ? 0 : 1);
  }
};
Fn.EMPTY = null, Fn.RED = true, Fn.BLACK = false;
Fn.EMPTY = new class {
  constructor() {
    this.size = 0;
  }
  get key() {
    throw L2();
  }
  get value() {
    throw L2();
  }
  get color() {
    throw L2();
  }
  get left() {
    throw L2();
  }
  get right() {
    throw L2();
  }
  copy(t2, e, n, s, i) {
    return this;
  }
  insert(t2, e, n) {
    return new Fn(t2, e);
  }
  remove(t2, e) {
    return this;
  }
  isEmpty() {
    return true;
  }
  inorderTraversal(t2) {
    return false;
  }
  reverseTraversal(t2) {
    return false;
  }
  minKey() {
    return null;
  }
  maxKey() {
    return null;
  }
  isRed() {
    return false;
  }
  checkMaxDepth() {
    return true;
  }
  check() {
    return 0;
  }
}();
var $n = class {
  constructor(t2) {
    this.comparator = t2, this.data = new Mn(this.comparator);
  }
  has(t2) {
    return this.data.get(t2) !== null;
  }
  first() {
    return this.data.minKey();
  }
  last() {
    return this.data.maxKey();
  }
  get size() {
    return this.data.size;
  }
  indexOf(t2) {
    return this.data.indexOf(t2);
  }
  forEach(t2) {
    this.data.inorderTraversal((e, n) => (t2(e), false));
  }
  forEachInRange(t2, e) {
    const n = this.data.getIteratorFrom(t2[0]);
    for (; n.hasNext(); ) {
      const s = n.getNext();
      if (this.comparator(s.key, t2[1]) >= 0)
        return;
      e(s.key);
    }
  }
  forEachWhile(t2, e) {
    let n;
    for (n = e !== void 0 ? this.data.getIteratorFrom(e) : this.data.getIterator(); n.hasNext(); ) {
      if (!t2(n.getNext().key))
        return;
    }
  }
  firstAfterOrEqual(t2) {
    const e = this.data.getIteratorFrom(t2);
    return e.hasNext() ? e.getNext().key : null;
  }
  getIterator() {
    return new Bn(this.data.getIterator());
  }
  getIteratorFrom(t2) {
    return new Bn(this.data.getIteratorFrom(t2));
  }
  add(t2) {
    return this.copy(this.data.remove(t2).insert(t2, true));
  }
  delete(t2) {
    return this.has(t2) ? this.copy(this.data.remove(t2)) : this;
  }
  isEmpty() {
    return this.data.isEmpty();
  }
  unionWith(t2) {
    let e = this;
    return e.size < t2.size && (e = t2, t2 = this), t2.forEach((t3) => {
      e = e.add(t3);
    }), e;
  }
  isEqual(t2) {
    if (!(t2 instanceof $n))
      return false;
    if (this.size !== t2.size)
      return false;
    const e = this.data.getIterator(), n = t2.data.getIterator();
    for (; e.hasNext(); ) {
      const t3 = e.getNext().key, s = n.getNext().key;
      if (this.comparator(t3, s) !== 0)
        return false;
    }
    return true;
  }
  toArray() {
    const t2 = [];
    return this.forEach((e) => {
      t2.push(e);
    }), t2;
  }
  toString() {
    const t2 = [];
    return this.forEach((e) => t2.push(e)), "SortedSet(" + t2.toString() + ")";
  }
  copy(t2) {
    const e = new $n(this.comparator);
    return e.data = t2, e;
  }
};
var Bn = class {
  constructor(t2) {
    this.iter = t2;
  }
  getNext() {
    return this.iter.getNext().key;
  }
  hasNext() {
    return this.iter.hasNext();
  }
};
function Ln(t2) {
  return t2.hasNext() ? t2.getNext() : void 0;
}
var Un = new Mn(xt.comparator);
function qn() {
  return Un;
}
var Gn = new Mn(xt.comparator);
function Kn() {
  return Gn;
}
function Qn() {
  return new kn((t2) => t2.toString(), (t2, e) => t2.isEqual(e));
}
var jn = new Mn(xt.comparator);
var Wn = new $n(xt.comparator);
function zn(...t2) {
  let e = Wn;
  for (const n of t2)
    e = e.add(n);
  return e;
}
var Hn = new $n(rt);
function Jn() {
  return Hn;
}
var Yn = class {
  constructor(t2, e, n, s, i) {
    this.snapshotVersion = t2, this.targetChanges = e, this.targetMismatches = n, this.documentUpdates = s, this.resolvedLimboDocuments = i;
  }
  static createSynthesizedRemoteEventForCurrentChange(t2, e) {
    const n = /* @__PURE__ */ new Map();
    return n.set(t2, Xn.createSynthesizedTargetChangeForCurrentChange(t2, e)), new Yn(ct.min(), n, Jn(), qn(), zn());
  }
};
var Xn = class {
  constructor(t2, e, n, s, i) {
    this.resumeToken = t2, this.current = e, this.addedDocuments = n, this.modifiedDocuments = s, this.removedDocuments = i;
  }
  static createSynthesizedTargetChangeForCurrentChange(t2, e) {
    return new Xn(pt.EMPTY_BYTE_STRING, e, zn(), zn(), zn());
  }
};
var Zn = class {
  constructor(t2, e, n, s) {
    this.O = t2, this.removedTargetIds = e, this.key = n, this.F = s;
  }
};
var ts = class {
  constructor(t2, e) {
    this.targetId = t2, this.$ = e;
  }
};
var es = class {
  constructor(t2, e, n = pt.EMPTY_BYTE_STRING, s = null) {
    this.state = t2, this.targetIds = e, this.resumeToken = n, this.cause = s;
  }
};
var ns = class {
  constructor() {
    this.B = 0, this.L = rs(), this.U = pt.EMPTY_BYTE_STRING, this.q = false, this.G = true;
  }
  get current() {
    return this.q;
  }
  get resumeToken() {
    return this.U;
  }
  get K() {
    return this.B !== 0;
  }
  get j() {
    return this.G;
  }
  W(t2) {
    t2.approximateByteSize() > 0 && (this.G = true, this.U = t2);
  }
  H() {
    let t2 = zn(), e = zn(), n = zn();
    return this.L.forEach((s, i) => {
      switch (i) {
        case 0:
          t2 = t2.add(s);
          break;
        case 2:
          e = e.add(s);
          break;
        case 1:
          n = n.add(s);
          break;
        default:
          L2();
      }
    }), new Xn(this.U, this.q, t2, e, n);
  }
  J() {
    this.G = false, this.L = rs();
  }
  Y(t2, e) {
    this.G = true, this.L = this.L.insert(t2, e);
  }
  X(t2) {
    this.G = true, this.L = this.L.remove(t2);
  }
  Z() {
    this.B += 1;
  }
  tt() {
    this.B -= 1;
  }
  et() {
    this.G = true, this.q = true;
  }
};
var ss = class {
  constructor(t2) {
    this.nt = t2, this.st = /* @__PURE__ */ new Map(), this.it = qn(), this.rt = is(), this.ot = new $n(rt);
  }
  ut(t2) {
    for (const e of t2.O)
      t2.F && t2.F.isFoundDocument() ? this.at(e, t2.F) : this.ct(e, t2.key, t2.F);
    for (const e of t2.removedTargetIds)
      this.ct(e, t2.key, t2.F);
  }
  ht(t2) {
    this.forEachTarget(t2, (e) => {
      const n = this.lt(e);
      switch (t2.state) {
        case 0:
          this.ft(e) && n.W(t2.resumeToken);
          break;
        case 1:
          n.tt(), n.K || n.J(), n.W(t2.resumeToken);
          break;
        case 2:
          n.tt(), n.K || this.removeTarget(e);
          break;
        case 3:
          this.ft(e) && (n.et(), n.W(t2.resumeToken));
          break;
        case 4:
          this.ft(e) && (this.dt(e), n.W(t2.resumeToken));
          break;
        default:
          L2();
      }
    });
  }
  forEachTarget(t2, e) {
    t2.targetIds.length > 0 ? t2.targetIds.forEach(e) : this.st.forEach((t3, n) => {
      this.ft(n) && e(n);
    });
  }
  _t(t2) {
    const e = t2.targetId, n = t2.$.count, s = this.wt(e);
    if (s) {
      const t3 = s.target;
      if (we(t3))
        if (n === 0) {
          const n2 = new xt(t3.path);
          this.ct(e, n2, te.newNoDocument(n2, ct.min()));
        } else
          U2(n === 1);
      else {
        this.gt(e) !== n && (this.dt(e), this.ot = this.ot.add(e));
      }
    }
  }
  yt(t2) {
    const e = /* @__PURE__ */ new Map();
    this.st.forEach((n2, s2) => {
      const i = this.wt(s2);
      if (i) {
        if (n2.current && we(i.target)) {
          const e2 = new xt(i.target.path);
          this.it.get(e2) !== null || this.It(s2, e2) || this.ct(s2, e2, te.newNoDocument(e2, t2));
        }
        n2.j && (e.set(s2, n2.H()), n2.J());
      }
    });
    let n = zn();
    this.rt.forEach((t3, e2) => {
      let s2 = true;
      e2.forEachWhile((t4) => {
        const e3 = this.wt(t4);
        return !e3 || e3.purpose === 2 || (s2 = false, false);
      }), s2 && (n = n.add(t3));
    }), this.it.forEach((e2, n2) => n2.setReadTime(t2));
    const s = new Yn(t2, e, this.ot, this.it, n);
    return this.it = qn(), this.rt = is(), this.ot = new $n(rt), s;
  }
  at(t2, e) {
    if (!this.ft(t2))
      return;
    const n = this.It(t2, e.key) ? 2 : 0;
    this.lt(t2).Y(e.key, n), this.it = this.it.insert(e.key, e), this.rt = this.rt.insert(e.key, this.Tt(e.key).add(t2));
  }
  ct(t2, e, n) {
    if (!this.ft(t2))
      return;
    const s = this.lt(t2);
    this.It(t2, e) ? s.Y(e, 1) : s.X(e), this.rt = this.rt.insert(e, this.Tt(e).delete(t2)), n && (this.it = this.it.insert(e, n));
  }
  removeTarget(t2) {
    this.st.delete(t2);
  }
  gt(t2) {
    const e = this.lt(t2).H();
    return this.nt.getRemoteKeysForTarget(t2).size + e.addedDocuments.size - e.removedDocuments.size;
  }
  Z(t2) {
    this.lt(t2).Z();
  }
  lt(t2) {
    let e = this.st.get(t2);
    return e || (e = new ns(), this.st.set(t2, e)), e;
  }
  Tt(t2) {
    let e = this.rt.get(t2);
    return e || (e = new $n(rt), this.rt = this.rt.insert(t2, e)), e;
  }
  ft(t2) {
    const e = this.wt(t2) !== null;
    return e || O2("WatchChangeAggregator", "Detected inactive target", t2), e;
  }
  wt(t2) {
    const e = this.st.get(t2);
    return e && e.K ? null : this.nt.Et(t2);
  }
  dt(t2) {
    this.st.set(t2, new ns());
    this.nt.getRemoteKeysForTarget(t2).forEach((e) => {
      this.ct(t2, e, null);
    });
  }
  It(t2, e) {
    return this.nt.getRemoteKeysForTarget(t2).has(e);
  }
};
function is() {
  return new Mn(xt.comparator);
}
function rs() {
  return new Mn(xt.comparator);
}
var os = (() => {
  const t2 = {
    asc: "ASCENDING",
    desc: "DESCENDING"
  };
  return t2;
})();
var us = (() => {
  const t2 = {
    "<": "LESS_THAN",
    "<=": "LESS_THAN_OR_EQUAL",
    ">": "GREATER_THAN",
    ">=": "GREATER_THAN_OR_EQUAL",
    "==": "EQUAL",
    "!=": "NOT_EQUAL",
    "array-contains": "ARRAY_CONTAINS",
    in: "IN",
    "not-in": "NOT_IN",
    "array-contains-any": "ARRAY_CONTAINS_ANY"
  };
  return t2;
})();
var as = class {
  constructor(t2, e) {
    this.databaseId = t2, this.N = e;
  }
};
function cs(t2, e) {
  if (t2.N) {
    return `${new Date(1e3 * e.seconds).toISOString().replace(/\.\d*/, "").replace("Z", "")}.${("000000000" + e.nanoseconds).slice(-9)}Z`;
  }
  return {
    seconds: "" + e.seconds,
    nanos: e.nanoseconds
  };
}
function hs(t2, e) {
  return t2.N ? e.toBase64() : e.toUint8Array();
}
function ls(t2, e) {
  return cs(t2, e.toTimestamp());
}
function fs(t2) {
  return U2(!!t2), ct.fromTimestamp(function(t3) {
    const e = Tt(t3);
    return new at(e.seconds, e.nanos);
  }(t2));
}
function ds(t2, e) {
  return function(t3) {
    return new _t(["projects", t3.projectId, "databases", t3.database]);
  }(t2).child("documents").child(e).canonicalString();
}
function _s(t2) {
  const e = _t.fromString(t2);
  return U2(Ls(e)), e;
}
function ws(t2, e) {
  return ds(t2.databaseId, e.path);
}
function ms(t2, e) {
  const n = _s(e);
  if (n.get(1) !== t2.databaseId.projectId)
    throw new Q2(K2.INVALID_ARGUMENT, "Tried to deserialize key from different project: " + n.get(1) + " vs " + t2.databaseId.projectId);
  if (n.get(3) !== t2.databaseId.database)
    throw new Q2(K2.INVALID_ARGUMENT, "Tried to deserialize key from different database: " + n.get(3) + " vs " + t2.databaseId.database);
  return new xt(Is(n));
}
function gs(t2, e) {
  return ds(t2.databaseId, e);
}
function ys(t2) {
  const e = _s(t2);
  return e.length === 4 ? _t.emptyPath() : Is(e);
}
function ps(t2) {
  return new _t(["projects", t2.databaseId.projectId, "databases", t2.databaseId.database]).canonicalString();
}
function Is(t2) {
  return U2(t2.length > 4 && t2.get(4) === "documents"), t2.popFirst(5);
}
function Ts(t2, e, n) {
  return {
    name: ws(t2, e),
    fields: n.value.mapValue.fields
  };
}
function Es(t2, e, n) {
  const s = ms(t2, e.name), i = fs(e.updateTime), r = new Xt({
    mapValue: {
      fields: e.fields
    }
  }), o = te.newFoundDocument(s, i, r);
  return n && o.setHasCommittedMutations(), n ? o.setHasCommittedMutations() : o;
}
function As(t2, e) {
  return "found" in e ? function(t3, e2) {
    U2(!!e2.found), e2.found.name, e2.found.updateTime;
    const n = ms(t3, e2.found.name), s = fs(e2.found.updateTime), i = new Xt({
      mapValue: {
        fields: e2.found.fields
      }
    });
    return te.newFoundDocument(n, s, i);
  }(t2, e) : "missing" in e ? function(t3, e2) {
    U2(!!e2.missing), U2(!!e2.readTime);
    const n = ms(t3, e2.missing), s = fs(e2.readTime);
    return te.newNoDocument(n, s);
  }(t2, e) : L2();
}
function Rs(t2, e) {
  let n;
  if ("targetChange" in e) {
    e.targetChange;
    const s = function(t3) {
      return t3 === "NO_CHANGE" ? 0 : t3 === "ADD" ? 1 : t3 === "REMOVE" ? 2 : t3 === "CURRENT" ? 3 : t3 === "RESET" ? 4 : L2();
    }(e.targetChange.targetChangeType || "NO_CHANGE"), i = e.targetChange.targetIds || [], r = function(t3, e2) {
      return t3.N ? (U2(e2 === void 0 || typeof e2 == "string"), pt.fromBase64String(e2 || "")) : (U2(e2 === void 0 || e2 instanceof Uint8Array), pt.fromUint8Array(e2 || new Uint8Array()));
    }(t2, e.targetChange.resumeToken), o = e.targetChange.cause, u = o && function(t3) {
      const e2 = t3.code === void 0 ? K2.UNKNOWN : Nn(t3.code);
      return new Q2(e2, t3.message || "");
    }(o);
    n = new es(s, i, r, u || null);
  } else if ("documentChange" in e) {
    e.documentChange;
    const s = e.documentChange;
    s.document, s.document.name, s.document.updateTime;
    const i = ms(t2, s.document.name), r = fs(s.document.updateTime), o = new Xt({
      mapValue: {
        fields: s.document.fields
      }
    }), u = te.newFoundDocument(i, r, o), a = s.targetIds || [], c = s.removedTargetIds || [];
    n = new Zn(a, c, u.key, u);
  } else if ("documentDelete" in e) {
    e.documentDelete;
    const s = e.documentDelete;
    s.document;
    const i = ms(t2, s.document), r = s.readTime ? fs(s.readTime) : ct.min(), o = te.newNoDocument(i, r), u = s.removedTargetIds || [];
    n = new Zn([], u, o.key, o);
  } else if ("documentRemove" in e) {
    e.documentRemove;
    const s = e.documentRemove;
    s.document;
    const i = ms(t2, s.document), r = s.removedTargetIds || [];
    n = new Zn([], r, i, null);
  } else {
    if (!("filter" in e))
      return L2();
    {
      e.filter;
      const t3 = e.filter;
      t3.targetId;
      const s = t3.count || 0, i = new Sn(s), r = t3.targetId;
      n = new ts(r, i);
    }
  }
  return n;
}
function bs(t2, e) {
  let n;
  if (e instanceof En)
    n = {
      update: Ts(t2, e.key, e.value)
    };
  else if (e instanceof Vn)
    n = {
      delete: ws(t2, e.key)
    };
  else if (e instanceof An)
    n = {
      update: Ts(t2, e.key, e.data),
      updateMask: Bs(e.fieldMask)
    };
  else {
    if (!(e instanceof vn))
      return L2();
    n = {
      verify: ws(t2, e.key)
    };
  }
  return e.fieldTransforms.length > 0 && (n.updateTransforms = e.fieldTransforms.map((t3) => function(t4, e2) {
    const n2 = e2.transform;
    if (n2 instanceof nn)
      return {
        fieldPath: e2.field.canonicalString(),
        setToServerValue: "REQUEST_TIME"
      };
    if (n2 instanceof sn)
      return {
        fieldPath: e2.field.canonicalString(),
        appendMissingElements: {
          values: n2.elements
        }
      };
    if (n2 instanceof on)
      return {
        fieldPath: e2.field.canonicalString(),
        removeAllFromArray: {
          values: n2.elements
        }
      };
    if (n2 instanceof an)
      return {
        fieldPath: e2.field.canonicalString(),
        increment: n2.k
      };
    throw L2();
  }(0, t3))), e.precondition.isNone || (n.currentDocument = function(t3, e2) {
    return e2.updateTime !== void 0 ? {
      updateTime: ls(t3, e2.updateTime)
    } : e2.exists !== void 0 ? {
      exists: e2.exists
    } : L2();
  }(t2, e.precondition)), n;
}
function Ps(t2, e) {
  const n = e.currentDocument ? function(t3) {
    return t3.updateTime !== void 0 ? _n.updateTime(fs(t3.updateTime)) : t3.exists !== void 0 ? _n.exists(t3.exists) : _n.none();
  }(e.currentDocument) : _n.none(), s = e.updateTransforms ? e.updateTransforms.map((e2) => function(t3, e3) {
    let n2 = null;
    if ("setToServerValue" in e3)
      U2(e3.setToServerValue === "REQUEST_TIME"), n2 = new nn();
    else if ("appendMissingElements" in e3) {
      const t4 = e3.appendMissingElements.values || [];
      n2 = new sn(t4);
    } else if ("removeAllFromArray" in e3) {
      const t4 = e3.removeAllFromArray.values || [];
      n2 = new on(t4);
    } else
      "increment" in e3 ? n2 = new an(t3, e3.increment) : L2();
    const s2 = mt.fromServerFormat(e3.fieldPath);
    return new ln(s2, n2);
  }(t2, e2)) : [];
  if (e.update) {
    e.update.name;
    const i = ms(t2, e.update.name), r = new Xt({
      mapValue: {
        fields: e.update.fields
      }
    });
    if (e.updateMask) {
      const t3 = function(t4) {
        const e2 = t4.fieldPaths || [];
        return new gt(e2.map((t5) => mt.fromServerFormat(t5)));
      }(e.updateMask);
      return new An(i, r, t3, n, s);
    }
    return new En(i, r, n, s);
  }
  if (e.delete) {
    const s2 = ms(t2, e.delete);
    return new Vn(s2, n);
  }
  if (e.verify) {
    const s2 = ms(t2, e.verify);
    return new vn(s2, n);
  }
  return L2();
}
function Vs(t2, e) {
  return t2 && t2.length > 0 ? (U2(e !== void 0), t2.map((t3) => function(t4, e2) {
    let n = t4.updateTime ? fs(t4.updateTime) : fs(e2);
    return n.isEqual(ct.min()) && (n = fs(e2)), new dn(n, t4.transformResults || []);
  }(t3, e))) : [];
}
function vs(t2, e) {
  return {
    documents: [gs(t2, e.path)]
  };
}
function Ss(t2, e) {
  const n = {
    structuredQuery: {}
  }, s = e.path;
  e.collectionGroup !== null ? (n.parent = gs(t2, s), n.structuredQuery.from = [{
    collectionId: e.collectionGroup,
    allDescendants: true
  }]) : (n.parent = gs(t2, s.popLast()), n.structuredQuery.from = [{
    collectionId: s.lastSegment()
  }]);
  const i = function(t3) {
    if (t3.length === 0)
      return;
    const e2 = t3.map((t4) => function(t5) {
      if (t5.op === "==") {
        if (jt(t5.value))
          return {
            unaryFilter: {
              field: Ms(t5.field),
              op: "IS_NAN"
            }
          };
        if (Qt(t5.value))
          return {
            unaryFilter: {
              field: Ms(t5.field),
              op: "IS_NULL"
            }
          };
      } else if (t5.op === "!=") {
        if (jt(t5.value))
          return {
            unaryFilter: {
              field: Ms(t5.field),
              op: "IS_NOT_NAN"
            }
          };
        if (Qt(t5.value))
          return {
            unaryFilter: {
              field: Ms(t5.field),
              op: "IS_NOT_NULL"
            }
          };
      }
      return {
        fieldFilter: {
          field: Ms(t5.field),
          op: ks(t5.op),
          value: t5.value
        }
      };
    }(t4));
    if (e2.length === 1)
      return e2[0];
    return {
      compositeFilter: {
        op: "AND",
        filters: e2
      }
    };
  }(e.filters);
  i && (n.structuredQuery.where = i);
  const r = function(t3) {
    if (t3.length === 0)
      return;
    return t3.map((t4) => function(t5) {
      return {
        field: Ms(t5.field),
        direction: Ns(t5.dir)
      };
    }(t4));
  }(e.orderBy);
  r && (n.structuredQuery.orderBy = r);
  const o = function(t3, e2) {
    return t3.N || St(e2) ? e2 : {
      value: e2
    };
  }(t2, e.limit);
  var u;
  return o !== null && (n.structuredQuery.limit = o), e.startAt && (n.structuredQuery.startAt = {
    before: (u = e.startAt).inclusive,
    values: u.position
  }), e.endAt && (n.structuredQuery.endAt = function(t3) {
    return {
      before: !t3.inclusive,
      values: t3.position
    };
  }(e.endAt)), n;
}
function Ds(t2) {
  let e = ys(t2.parent);
  const n = t2.structuredQuery, s = n.from ? n.from.length : 0;
  let i = null;
  if (s > 0) {
    U2(s === 1);
    const t3 = n.from[0];
    t3.allDescendants ? i = t3.collectionId : e = e.child(t3.collectionId);
  }
  let r = [];
  n.where && (r = xs(n.where));
  let o = [];
  n.orderBy && (o = n.orderBy.map((t3) => function(t4) {
    return new Ve(Os(t4.field), function(t5) {
      switch (t5) {
        case "ASCENDING":
          return "asc";
        case "DESCENDING":
          return "desc";
        default:
          return;
      }
    }(t4.direction));
  }(t3)));
  let u = null;
  n.limit && (u = function(t3) {
    let e2;
    return e2 = typeof t3 == "object" ? t3.value : t3, St(e2) ? null : e2;
  }(n.limit));
  let a = null;
  n.startAt && (a = function(t3) {
    const e2 = !!t3.before, n2 = t3.values || [];
    return new Pe(n2, e2);
  }(n.startAt));
  let c = null;
  return n.endAt && (c = function(t3) {
    const e2 = !t3.before, n2 = t3.values || [];
    return new Pe(n2, e2);
  }(n.endAt)), xe(e, i, o, r, u, "F", a, c);
}
function Cs(t2, e) {
  const n = function(t3, e2) {
    switch (e2) {
      case 0:
        return null;
      case 1:
        return "existence-filter-mismatch";
      case 2:
        return "limbo-document";
      default:
        return L2();
    }
  }(0, e.purpose);
  return n == null ? null : {
    "goog-listen-tags": n
  };
}
function xs(t2) {
  return t2 ? t2.unaryFilter !== void 0 ? [$s(t2)] : t2.fieldFilter !== void 0 ? [Fs(t2)] : t2.compositeFilter !== void 0 ? t2.compositeFilter.filters.map((t3) => xs(t3)).reduce((t3, e) => t3.concat(e)) : L2() : [];
}
function Ns(t2) {
  return os[t2];
}
function ks(t2) {
  return us[t2];
}
function Ms(t2) {
  return {
    fieldPath: t2.canonicalString()
  };
}
function Os(t2) {
  return mt.fromServerFormat(t2.fieldPath);
}
function Fs(t2) {
  return ge.create(Os(t2.fieldFilter.field), function(t3) {
    switch (t3) {
      case "EQUAL":
        return "==";
      case "NOT_EQUAL":
        return "!=";
      case "GREATER_THAN":
        return ">";
      case "GREATER_THAN_OR_EQUAL":
        return ">=";
      case "LESS_THAN":
        return "<";
      case "LESS_THAN_OR_EQUAL":
        return "<=";
      case "ARRAY_CONTAINS":
        return "array-contains";
      case "IN":
        return "in";
      case "NOT_IN":
        return "not-in";
      case "ARRAY_CONTAINS_ANY":
        return "array-contains-any";
      default:
        return L2();
    }
  }(t2.fieldFilter.op), t2.fieldFilter.value);
}
function $s(t2) {
  switch (t2.unaryFilter.op) {
    case "IS_NAN":
      const e = Os(t2.unaryFilter.field);
      return ge.create(e, "==", {
        doubleValue: NaN
      });
    case "IS_NULL":
      const n = Os(t2.unaryFilter.field);
      return ge.create(n, "==", {
        nullValue: "NULL_VALUE"
      });
    case "IS_NOT_NAN":
      const s = Os(t2.unaryFilter.field);
      return ge.create(s, "!=", {
        doubleValue: NaN
      });
    case "IS_NOT_NULL":
      const i = Os(t2.unaryFilter.field);
      return ge.create(i, "!=", {
        nullValue: "NULL_VALUE"
      });
    default:
      return L2();
  }
}
function Bs(t2) {
  const e = [];
  return t2.fields.forEach((t3) => e.push(t3.canonicalString())), {
    fieldPaths: e
  };
}
function Ls(t2) {
  return t2.length >= 4 && t2.get(0) === "projects" && t2.get(2) === "databases";
}
function Us(t2) {
  let e = "";
  for (let n = 0; n < t2.length; n++)
    e.length > 0 && (e = Gs(e)), e = qs(t2.get(n), e);
  return Gs(e);
}
function qs(t2, e) {
  let n = e;
  const s = t2.length;
  for (let e2 = 0; e2 < s; e2++) {
    const s2 = t2.charAt(e2);
    switch (s2) {
      case "\0":
        n += "";
        break;
      case "":
        n += "";
        break;
      default:
        n += s2;
    }
  }
  return n;
}
function Gs(t2) {
  return t2 + "";
}
function Ks(t2) {
  const e = t2.length;
  if (U2(e >= 2), e === 2)
    return U2(t2.charAt(0) === "" && t2.charAt(1) === ""), _t.emptyPath();
  const n = e - 2, s = [];
  let i = "";
  for (let r = 0; r < e; ) {
    const e2 = t2.indexOf("", r);
    (e2 < 0 || e2 > n) && L2();
    switch (t2.charAt(e2 + 1)) {
      case "":
        const n2 = t2.substring(r, e2);
        let o;
        i.length === 0 ? o = n2 : (i += n2, o = i, i = ""), s.push(o);
        break;
      case "":
        i += t2.substring(r, e2), i += "\0";
        break;
      case "":
        i += t2.substring(r, e2 + 1);
        break;
      default:
        L2();
    }
    r = e2 + 2;
  }
  return new _t(s);
}
var Qs = ["userId", "batchId"];
function js(t2, e) {
  return [t2, Us(e)];
}
function Ws(t2, e, n) {
  return [t2, Us(e), n];
}
var zs = {};
var Hs = ["prefixPath", "collectionGroup", "readTime", "documentId"];
var Js = ["prefixPath", "collectionGroup", "documentId"];
var Ys = ["collectionGroup", "readTime", "prefixPath", "documentId"];
var Xs = ["canonicalId", "targetId"];
var Zs = ["targetId", "path"];
var ti = ["path", "targetId"];
var ei = ["collectionId", "parent"];
var ni = ["indexId", "uid"];
var si = ["uid", "sequenceNumber"];
var ii = ["indexId", "uid", "arrayValue", "directionalValue", "documentKey"];
var ri = ["indexId", "uid", "documentKey"];
var oi = ["userId", "collectionPath", "documentId"];
var ui = ["userId", "collectionPath", "largestBatchId"];
var ai = ["userId", "collectionGroup", "largestBatchId"];
var ci = [...[...[...[...["mutationQueues", "mutations", "documentMutations", "remoteDocuments", "targets", "owner", "targetGlobal", "targetDocuments"], "clientMetadata"], "remoteDocumentGlobal"], "collectionParents"], "bundles", "namedQueries"];
var hi = [...ci, "documentOverlays"];
var li = ["mutationQueues", "mutations", "documentMutations", "remoteDocumentsV14", "targets", "owner", "targetGlobal", "targetDocuments", "clientMetadata", "remoteDocumentGlobal", "collectionParents", "bundles", "namedQueries", "documentOverlays"];
var fi = [...li, "indexConfiguration", "indexState", "indexEntries"];
var di = "The current tab is not in the required state to perform this operation. It might be necessary to refresh the browser tab.";
var _i = class {
  constructor() {
    this.onCommittedListeners = [];
  }
  addOnCommittedListener(t2) {
    this.onCommittedListeners.push(t2);
  }
  raiseOnCommittedEvent() {
    this.onCommittedListeners.forEach((t2) => t2());
  }
};
var wi = class {
  constructor(t2) {
    this.nextCallback = null, this.catchCallback = null, this.result = void 0, this.error = void 0, this.isDone = false, this.callbackAttached = false, t2((t3) => {
      this.isDone = true, this.result = t3, this.nextCallback && this.nextCallback(t3);
    }, (t3) => {
      this.isDone = true, this.error = t3, this.catchCallback && this.catchCallback(t3);
    });
  }
  catch(t2) {
    return this.next(void 0, t2);
  }
  next(t2, e) {
    return this.callbackAttached && L2(), this.callbackAttached = true, this.isDone ? this.error ? this.wrapFailure(e, this.error) : this.wrapSuccess(t2, this.result) : new wi((n, s) => {
      this.nextCallback = (e2) => {
        this.wrapSuccess(t2, e2).next(n, s);
      }, this.catchCallback = (t3) => {
        this.wrapFailure(e, t3).next(n, s);
      };
    });
  }
  toPromise() {
    return new Promise((t2, e) => {
      this.next(t2, e);
    });
  }
  wrapUserFunction(t2) {
    try {
      const e = t2();
      return e instanceof wi ? e : wi.resolve(e);
    } catch (t3) {
      return wi.reject(t3);
    }
  }
  wrapSuccess(t2, e) {
    return t2 ? this.wrapUserFunction(() => t2(e)) : wi.resolve(e);
  }
  wrapFailure(t2, e) {
    return t2 ? this.wrapUserFunction(() => t2(e)) : wi.reject(e);
  }
  static resolve(t2) {
    return new wi((e, n) => {
      e(t2);
    });
  }
  static reject(t2) {
    return new wi((e, n) => {
      n(t2);
    });
  }
  static waitFor(t2) {
    return new wi((e, n) => {
      let s = 0, i = 0, r = false;
      t2.forEach((t3) => {
        ++s, t3.next(() => {
          ++i, r && i === s && e();
        }, (t4) => n(t4));
      }), r = true, i === s && e();
    });
  }
  static or(t2) {
    let e = wi.resolve(false);
    for (const n of t2)
      e = e.next((t3) => t3 ? wi.resolve(t3) : n());
    return e;
  }
  static forEach(t2, e) {
    const n = [];
    return t2.forEach((t3, s) => {
      n.push(e.call(this, t3, s));
    }), this.waitFor(n);
  }
};
var mi = class {
  constructor(t2, e) {
    this.action = t2, this.transaction = e, this.aborted = false, this.At = new j(), this.transaction.oncomplete = () => {
      this.At.resolve();
    }, this.transaction.onabort = () => {
      e.error ? this.At.reject(new pi(t2, e.error)) : this.At.resolve();
    }, this.transaction.onerror = (e2) => {
      const n = Ri(e2.target.error);
      this.At.reject(new pi(t2, n));
    };
  }
  static open(t2, e, n, s) {
    try {
      return new mi(e, t2.transaction(s, n));
    } catch (t3) {
      throw new pi(e, t3);
    }
  }
  get Rt() {
    return this.At.promise;
  }
  abort(t2) {
    t2 && this.At.reject(t2), this.aborted || (O2("SimpleDb", "Aborting transaction:", t2 ? t2.message : "Client-initiated abort"), this.aborted = true, this.transaction.abort());
  }
  bt() {
    const t2 = this.transaction;
    this.aborted || typeof t2.commit != "function" || t2.commit();
  }
  store(t2) {
    const e = this.transaction.objectStore(t2);
    return new Ti(e);
  }
};
var gi = class {
  constructor(t2, e, n) {
    this.name = t2, this.version = e, this.Pt = n;
    gi.Vt(getUA()) === 12.2 && F2("Firestore persistence suffers from a bug in iOS 12.2 Safari that may cause your app to stop working. See https://stackoverflow.com/q/56496296/110915 for details and a potential workaround.");
  }
  static delete(t2) {
    return O2("SimpleDb", "Removing database:", t2), Ei(window.indexedDB.deleteDatabase(t2)).toPromise();
  }
  static vt() {
    if (!isIndexedDBAvailable())
      return false;
    if (gi.St())
      return true;
    const t2 = getUA(), e = gi.Vt(t2), n = 0 < e && e < 10, s = gi.Dt(t2), i = 0 < s && s < 4.5;
    return !(t2.indexOf("MSIE ") > 0 || t2.indexOf("Trident/") > 0 || t2.indexOf("Edge/") > 0 || n || i);
  }
  static St() {
    var t2;
    return typeof process != "undefined" && ((t2 = process.env) === null || t2 === void 0 ? void 0 : t2.Ct) === "YES";
  }
  static xt(t2, e) {
    return t2.store(e);
  }
  static Vt(t2) {
    const e = t2.match(/i(?:phone|pad|pod) os ([\d_]+)/i), n = e ? e[1].split("_").slice(0, 2).join(".") : "-1";
    return Number(n);
  }
  static Dt(t2) {
    const e = t2.match(/Android ([\d.]+)/i), n = e ? e[1].split(".").slice(0, 2).join(".") : "-1";
    return Number(n);
  }
  async Nt(t2) {
    return this.db || (O2("SimpleDb", "Opening database:", this.name), this.db = await new Promise((e, n) => {
      const s = indexedDB.open(this.name, this.version);
      s.onsuccess = (t3) => {
        const n2 = t3.target.result;
        e(n2);
      }, s.onblocked = () => {
        n(new pi(t2, "Cannot upgrade IndexedDB schema while another tab is open. Close all tabs that access Firestore and reload this page to proceed."));
      }, s.onerror = (e2) => {
        const s2 = e2.target.error;
        s2.name === "VersionError" ? n(new Q2(K2.FAILED_PRECONDITION, "A newer version of the Firestore SDK was previously used and so the persisted data is not compatible with the version of the SDK you are now using. The SDK will operate with persistence disabled. If you need persistence, please re-upgrade to a newer version of the SDK or else clear the persisted IndexedDB data for your app to start fresh.")) : s2.name === "InvalidStateError" ? n(new Q2(K2.FAILED_PRECONDITION, "Unable to open an IndexedDB connection. This could be due to running in a private browsing session on a browser whose private browsing sessions do not support IndexedDB: " + s2)) : n(new pi(t2, s2));
      }, s.onupgradeneeded = (t3) => {
        O2("SimpleDb", 'Database "' + this.name + '" requires upgrade from version:', t3.oldVersion);
        const e2 = t3.target.result;
        this.Pt.kt(e2, s.transaction, t3.oldVersion, this.version).next(() => {
          O2("SimpleDb", "Database upgrade to version " + this.version + " complete");
        });
      };
    })), this.Mt && (this.db.onversionchange = (t3) => this.Mt(t3)), this.db;
  }
  Ot(t2) {
    this.Mt = t2, this.db && (this.db.onversionchange = (e) => t2(e));
  }
  async runTransaction(t2, e, n, s) {
    const i = e === "readonly";
    let r = 0;
    for (; ; ) {
      ++r;
      try {
        this.db = await this.Nt(t2);
        const e2 = mi.open(this.db, t2, i ? "readonly" : "readwrite", n), r2 = s(e2).next((t3) => (e2.bt(), t3)).catch((t3) => (e2.abort(t3), wi.reject(t3))).toPromise();
        return r2.catch(() => {
        }), await e2.Rt, r2;
      } catch (t3) {
        const e2 = t3.name !== "FirebaseError" && r < 3;
        if (O2("SimpleDb", "Transaction failed with error:", t3.message, "Retrying:", e2), this.close(), !e2)
          return Promise.reject(t3);
      }
    }
  }
  close() {
    this.db && this.db.close(), this.db = void 0;
  }
};
var yi = class {
  constructor(t2) {
    this.Ft = t2, this.$t = false, this.Bt = null;
  }
  get isDone() {
    return this.$t;
  }
  get Lt() {
    return this.Bt;
  }
  set cursor(t2) {
    this.Ft = t2;
  }
  done() {
    this.$t = true;
  }
  Ut(t2) {
    this.Bt = t2;
  }
  delete() {
    return Ei(this.Ft.delete());
  }
};
var pi = class extends Q2 {
  constructor(t2, e) {
    super(K2.UNAVAILABLE, `IndexedDB transaction '${t2}' failed: ${e}`), this.name = "IndexedDbTransactionError";
  }
};
function Ii(t2) {
  return t2.name === "IndexedDbTransactionError";
}
var Ti = class {
  constructor(t2) {
    this.store = t2;
  }
  put(t2, e) {
    let n;
    return e !== void 0 ? (O2("SimpleDb", "PUT", this.store.name, t2, e), n = this.store.put(e, t2)) : (O2("SimpleDb", "PUT", this.store.name, "<auto-key>", t2), n = this.store.put(t2)), Ei(n);
  }
  add(t2) {
    O2("SimpleDb", "ADD", this.store.name, t2, t2);
    return Ei(this.store.add(t2));
  }
  get(t2) {
    return Ei(this.store.get(t2)).next((e) => (e === void 0 && (e = null), O2("SimpleDb", "GET", this.store.name, t2, e), e));
  }
  delete(t2) {
    O2("SimpleDb", "DELETE", this.store.name, t2);
    return Ei(this.store.delete(t2));
  }
  count() {
    O2("SimpleDb", "COUNT", this.store.name);
    return Ei(this.store.count());
  }
  qt(t2, e) {
    const n = this.options(t2, e);
    if (n.index || typeof this.store.getAll != "function") {
      const t3 = this.cursor(n), e2 = [];
      return this.Gt(t3, (t4, n2) => {
        e2.push(n2);
      }).next(() => e2);
    }
    {
      const t3 = this.store.getAll(n.range);
      return new wi((e2, n2) => {
        t3.onerror = (t4) => {
          n2(t4.target.error);
        }, t3.onsuccess = (t4) => {
          e2(t4.target.result);
        };
      });
    }
  }
  Kt(t2, e) {
    const n = this.store.getAll(t2, e === null ? void 0 : e);
    return new wi((t3, e2) => {
      n.onerror = (t4) => {
        e2(t4.target.error);
      }, n.onsuccess = (e3) => {
        t3(e3.target.result);
      };
    });
  }
  Qt(t2, e) {
    O2("SimpleDb", "DELETE ALL", this.store.name);
    const n = this.options(t2, e);
    n.jt = false;
    const s = this.cursor(n);
    return this.Gt(s, (t3, e2, n2) => n2.delete());
  }
  Wt(t2, e) {
    let n;
    e ? n = t2 : (n = {}, e = t2);
    const s = this.cursor(n);
    return this.Gt(s, e);
  }
  zt(t2) {
    const e = this.cursor({});
    return new wi((n, s) => {
      e.onerror = (t3) => {
        const e2 = Ri(t3.target.error);
        s(e2);
      }, e.onsuccess = (e2) => {
        const s2 = e2.target.result;
        s2 ? t2(s2.primaryKey, s2.value).next((t3) => {
          t3 ? s2.continue() : n();
        }) : n();
      };
    });
  }
  Gt(t2, e) {
    const n = [];
    return new wi((s, i) => {
      t2.onerror = (t3) => {
        i(t3.target.error);
      }, t2.onsuccess = (t3) => {
        const i2 = t3.target.result;
        if (!i2)
          return void s();
        const r = new yi(i2), o = e(i2.primaryKey, i2.value, r);
        if (o instanceof wi) {
          const t4 = o.catch((t5) => (r.done(), wi.reject(t5)));
          n.push(t4);
        }
        r.isDone ? s() : r.Lt === null ? i2.continue() : i2.continue(r.Lt);
      };
    }).next(() => wi.waitFor(n));
  }
  options(t2, e) {
    let n;
    return t2 !== void 0 && (typeof t2 == "string" ? n = t2 : e = t2), {
      index: n,
      range: e
    };
  }
  cursor(t2) {
    let e = "next";
    if (t2.reverse && (e = "prev"), t2.index) {
      const n = this.store.index(t2.index);
      return t2.jt ? n.openKeyCursor(t2.range, e) : n.openCursor(t2.range, e);
    }
    return this.store.openCursor(t2.range, e);
  }
};
function Ei(t2) {
  return new wi((e, n) => {
    t2.onsuccess = (t3) => {
      const n2 = t3.target.result;
      e(n2);
    }, t2.onerror = (t3) => {
      const e2 = Ri(t3.target.error);
      n(e2);
    };
  });
}
var Ai = false;
function Ri(t2) {
  const e = gi.Vt(getUA());
  if (e >= 12.2 && e < 13) {
    const e2 = "An internal error was encountered in the Indexed Database server";
    if (t2.message.indexOf(e2) >= 0) {
      const t3 = new Q2("internal", `IOS_INDEXEDDB_BUG1: IndexedDb has thrown '${e2}'. This is likely due to an unavoidable bug in iOS. See https://stackoverflow.com/q/56496296/110915 for details and a potential workaround.`);
      return Ai || (Ai = true, setTimeout(() => {
        throw t3;
      }, 0)), t3;
    }
  }
  return t2;
}
var bi = class extends _i {
  constructor(t2, e) {
    super(), this.Ht = t2, this.currentSequenceNumber = e;
  }
};
function Pi(t2, e) {
  const n = G(t2);
  return gi.xt(n.Ht, e);
}
var Vi = class {
  constructor(t2, e, n, s) {
    this.batchId = t2, this.localWriteTime = e, this.baseMutations = n, this.mutations = s;
  }
  applyToRemoteDocument(t2, e) {
    const n = e.mutationResults;
    for (let e2 = 0; e2 < this.mutations.length; e2++) {
      const s = this.mutations[e2];
      if (s.key.isEqual(t2.key)) {
        gn(s, t2, n[e2]);
      }
    }
  }
  applyToLocalView(t2) {
    for (const e of this.baseMutations)
      e.key.isEqual(t2.key) && yn(e, t2, this.localWriteTime);
    for (const e of this.mutations)
      e.key.isEqual(t2.key) && yn(e, t2, this.localWriteTime);
  }
  applyToLocalDocumentSet(t2) {
    this.mutations.forEach((e) => {
      const n = t2.get(e.key), s = n;
      this.applyToLocalView(s), n.isValidDocument() || s.convertToNoDocument(ct.min());
    });
  }
  keys() {
    return this.mutations.reduce((t2, e) => t2.add(e.key), zn());
  }
  isEqual(t2) {
    return this.batchId === t2.batchId && ot(this.mutations, t2.mutations, (t3, e) => In(t3, e)) && ot(this.baseMutations, t2.baseMutations, (t3, e) => In(t3, e));
  }
};
var vi = class {
  constructor(t2, e, n, s) {
    this.batch = t2, this.commitVersion = e, this.mutationResults = n, this.docVersions = s;
  }
  static from(t2, e, n) {
    U2(t2.mutations.length === n.length);
    let s = jn;
    const i = t2.mutations;
    for (let t3 = 0; t3 < i.length; t3++)
      s = s.insert(i[t3].key, n[t3].version);
    return new vi(t2, e, n, s);
  }
};
var Si = class {
  constructor(t2, e) {
    this.largestBatchId = t2, this.mutation = e;
  }
  getKey() {
    return this.mutation.key;
  }
  isEqual(t2) {
    return t2 !== null && this.mutation === t2.mutation;
  }
  toString() {
    return `Overlay{
      largestBatchId: ${this.largestBatchId},
      mutation: ${this.mutation.toString()}
    }`;
  }
};
var Di = class {
  constructor(t2, e, n, s, i = ct.min(), r = ct.min(), o = pt.EMPTY_BYTE_STRING) {
    this.target = t2, this.targetId = e, this.purpose = n, this.sequenceNumber = s, this.snapshotVersion = i, this.lastLimboFreeSnapshotVersion = r, this.resumeToken = o;
  }
  withSequenceNumber(t2) {
    return new Di(this.target, this.targetId, this.purpose, t2, this.snapshotVersion, this.lastLimboFreeSnapshotVersion, this.resumeToken);
  }
  withResumeToken(t2, e) {
    return new Di(this.target, this.targetId, this.purpose, this.sequenceNumber, e, this.lastLimboFreeSnapshotVersion, t2);
  }
  withLastLimboFreeSnapshotVersion(t2) {
    return new Di(this.target, this.targetId, this.purpose, this.sequenceNumber, this.snapshotVersion, t2, this.resumeToken);
  }
};
var Ci = class {
  constructor(t2) {
    this.Jt = t2;
  }
};
function xi(t2, e) {
  let n;
  if (e.document)
    n = Es(t2.Jt, e.document, !!e.hasCommittedMutations);
  else if (e.noDocument) {
    const t3 = xt.fromSegments(e.noDocument.path), s = Oi(e.noDocument.readTime);
    n = te.newNoDocument(t3, s), e.hasCommittedMutations && n.setHasCommittedMutations();
  } else {
    if (!e.unknownDocument)
      return L2();
    {
      const t3 = xt.fromSegments(e.unknownDocument.path), s = Oi(e.unknownDocument.version);
      n = te.newUnknownDocument(t3, s);
    }
  }
  return e.readTime && n.setReadTime(function(t3) {
    const e2 = new at(t3[0], t3[1]);
    return ct.fromTimestamp(e2);
  }(e.readTime)), n;
}
function Ni(t2, e) {
  const n = e.key, s = {
    prefixPath: n.getCollectionPath().popLast().toArray(),
    collectionGroup: n.collectionGroup,
    documentId: n.path.lastSegment(),
    readTime: ki(e.readTime),
    hasCommittedMutations: e.hasCommittedMutations
  };
  if (e.isFoundDocument())
    s.document = function(t3, e2) {
      return {
        name: ws(t3, e2.key),
        fields: e2.data.value.mapValue.fields,
        updateTime: cs(t3, e2.version.toTimestamp())
      };
    }(t2.Jt, e);
  else if (e.isNoDocument())
    s.noDocument = {
      path: n.path.toArray(),
      readTime: Mi(e.version)
    };
  else {
    if (!e.isUnknownDocument())
      return L2();
    s.unknownDocument = {
      path: n.path.toArray(),
      version: Mi(e.version)
    };
  }
  return s;
}
function ki(t2) {
  const e = t2.toTimestamp();
  return [e.seconds, e.nanoseconds];
}
function Mi(t2) {
  const e = t2.toTimestamp();
  return {
    seconds: e.seconds,
    nanoseconds: e.nanoseconds
  };
}
function Oi(t2) {
  const e = new at(t2.seconds, t2.nanoseconds);
  return ct.fromTimestamp(e);
}
function Fi(t2, e) {
  const n = (e.baseMutations || []).map((e2) => Ps(t2.Jt, e2));
  for (let t3 = 0; t3 < e.mutations.length - 1; ++t3) {
    const n2 = e.mutations[t3];
    if (t3 + 1 < e.mutations.length && e.mutations[t3 + 1].transform !== void 0) {
      const s2 = e.mutations[t3 + 1];
      n2.updateTransforms = s2.transform.fieldTransforms, e.mutations.splice(t3 + 1, 1), ++t3;
    }
  }
  const s = e.mutations.map((e2) => Ps(t2.Jt, e2)), i = at.fromMillis(e.localWriteTimeMs);
  return new Vi(e.batchId, i, n, s);
}
function $i(t2) {
  const e = Oi(t2.readTime), n = t2.lastLimboFreeSnapshotVersion !== void 0 ? Oi(t2.lastLimboFreeSnapshotVersion) : ct.min();
  let s;
  var i;
  return t2.query.documents !== void 0 ? (U2((i = t2.query).documents.length === 1), s = Le(Ne(ys(i.documents[0])))) : s = function(t3) {
    return Le(Ds(t3));
  }(t2.query), new Di(s, t2.targetId, 0, t2.lastListenSequenceNumber, e, n, pt.fromBase64String(t2.resumeToken));
}
function Bi(t2, e) {
  const n = Mi(e.snapshotVersion), s = Mi(e.lastLimboFreeSnapshotVersion);
  let i;
  i = we(e.target) ? vs(t2.Jt, e.target) : Ss(t2.Jt, e.target);
  const r = e.resumeToken.toBase64();
  return {
    targetId: e.targetId,
    canonicalId: fe(e.target),
    readTime: n,
    resumeToken: r,
    lastListenSequenceNumber: e.sequenceNumber,
    lastLimboFreeSnapshotVersion: s,
    query: i
  };
}
function Li(t2) {
  const e = Ds({
    parent: t2.parent,
    structuredQuery: t2.structuredQuery
  });
  return t2.limitType === "LAST" ? Ue(e, e.limit, "L") : e;
}
function Ui(t2, e) {
  return new Si(e.largestBatchId, Ps(t2.Jt, e.overlayMutation));
}
function qi(t2, e) {
  const n = e.path.lastSegment();
  return [t2, Us(e.path.popLast()), n];
}
var Gi = class {
  getBundleMetadata(t2, e) {
    return Ki(t2).get(e).next((t3) => {
      if (t3)
        return {
          id: (e2 = t3).bundleId,
          createTime: Oi(e2.createTime),
          version: e2.version
        };
      var e2;
    });
  }
  saveBundleMetadata(t2, e) {
    return Ki(t2).put({
      bundleId: (n = e).id,
      createTime: Mi(fs(n.createTime)),
      version: n.version
    });
    var n;
  }
  getNamedQuery(t2, e) {
    return Qi(t2).get(e).next((t3) => {
      if (t3)
        return {
          name: (e2 = t3).name,
          query: Li(e2.bundledQuery),
          readTime: Oi(e2.readTime)
        };
      var e2;
    });
  }
  saveNamedQuery(t2, e) {
    return Qi(t2).put(function(t3) {
      return {
        name: t3.name,
        readTime: Mi(fs(t3.readTime)),
        bundledQuery: t3.bundledQuery
      };
    }(e));
  }
};
function Ki(t2) {
  return Pi(t2, "bundles");
}
function Qi(t2) {
  return Pi(t2, "namedQueries");
}
var ji = class {
  constructor(t2, e) {
    this.M = t2, this.userId = e;
  }
  static Yt(t2, e) {
    const n = e.uid || "";
    return new ji(t2, n);
  }
  getOverlay(t2, e) {
    return Wi(t2).get(qi(this.userId, e)).next((t3) => t3 ? Ui(this.M, t3) : null);
  }
  saveOverlays(t2, e, n) {
    const s = [];
    return n.forEach((n2, i) => {
      const r = new Si(e, i);
      s.push(this.Xt(t2, r));
    }), wi.waitFor(s);
  }
  removeOverlaysForBatchId(t2, e, n) {
    const s = /* @__PURE__ */ new Set();
    e.forEach((t3) => s.add(Us(t3.getCollectionPath())));
    const i = [];
    return s.forEach((e2) => {
      const s2 = IDBKeyRange.bound([this.userId, e2, n], [this.userId, e2, n + 1], false, true);
      i.push(Wi(t2).Qt("collectionPathOverlayIndex", s2));
    }), wi.waitFor(i);
  }
  getOverlaysForCollection(t2, e, n) {
    const s = Qn(), i = Us(e), r = IDBKeyRange.bound([this.userId, i, n], [this.userId, i, Number.POSITIVE_INFINITY], true);
    return Wi(t2).qt("collectionPathOverlayIndex", r).next((t3) => {
      for (const e2 of t3) {
        const t4 = Ui(this.M, e2);
        s.set(t4.getKey(), t4);
      }
      return s;
    });
  }
  getOverlaysForCollectionGroup(t2, e, n, s) {
    const i = Qn();
    let r;
    const o = IDBKeyRange.bound([this.userId, e, n], [this.userId, e, Number.POSITIVE_INFINITY], true);
    return Wi(t2).Wt({
      index: "collectionGroupOverlayIndex",
      range: o
    }, (t3, e2, n2) => {
      const o2 = Ui(this.M, e2);
      i.size() < s || o2.largestBatchId === r ? (i.set(o2.getKey(), o2), r = o2.largestBatchId) : n2.done();
    }).next(() => i);
  }
  Xt(t2, e) {
    return Wi(t2).put(function(t3, e2, n) {
      const [s, i, r] = qi(e2, n.mutation.key);
      return {
        userId: e2,
        collectionPath: i,
        documentId: r,
        collectionGroup: n.mutation.key.getCollectionGroup(),
        largestBatchId: n.largestBatchId,
        overlayMutation: bs(t3.Jt, n.mutation)
      };
    }(this.M, this.userId, e));
  }
};
function Wi(t2) {
  return Pi(t2, "documentOverlays");
}
var zi = class {
  constructor() {
  }
  Zt(t2, e) {
    this.te(t2, e), e.ee();
  }
  te(t2, e) {
    if ("nullValue" in t2)
      this.ne(e, 5);
    else if ("booleanValue" in t2)
      this.ne(e, 10), e.se(t2.booleanValue ? 1 : 0);
    else if ("integerValue" in t2)
      this.ne(e, 15), e.se(Et(t2.integerValue));
    else if ("doubleValue" in t2) {
      const n = Et(t2.doubleValue);
      isNaN(n) ? this.ne(e, 13) : (this.ne(e, 15), Dt(n) ? e.se(0) : e.se(n));
    } else if ("timestampValue" in t2) {
      const n = t2.timestampValue;
      this.ne(e, 20), typeof n == "string" ? e.ie(n) : (e.ie(`${n.seconds || ""}`), e.se(n.nanos || 0));
    } else if ("stringValue" in t2)
      this.re(t2.stringValue, e), this.oe(e);
    else if ("bytesValue" in t2)
      this.ne(e, 30), e.ue(At(t2.bytesValue)), this.oe(e);
    else if ("referenceValue" in t2)
      this.ae(t2.referenceValue, e);
    else if ("geoPointValue" in t2) {
      const n = t2.geoPointValue;
      this.ne(e, 45), e.se(n.latitude || 0), e.se(n.longitude || 0);
    } else
      "mapValue" in t2 ? Ht(t2) ? this.ne(e, Number.MAX_SAFE_INTEGER) : (this.ce(t2.mapValue, e), this.oe(e)) : "arrayValue" in t2 ? (this.he(t2.arrayValue, e), this.oe(e)) : L2();
  }
  re(t2, e) {
    this.ne(e, 25), this.le(t2, e);
  }
  le(t2, e) {
    e.ie(t2);
  }
  ce(t2, e) {
    const n = t2.fields || {};
    this.ne(e, 55);
    for (const t3 of Object.keys(n))
      this.re(t3, e), this.te(n[t3], e);
  }
  he(t2, e) {
    const n = t2.values || [];
    this.ne(e, 50);
    for (const t3 of n)
      this.te(t3, e);
  }
  ae(t2, e) {
    this.ne(e, 37);
    xt.fromName(t2).path.forEach((t3) => {
      this.ne(e, 60), this.le(t3, e);
    });
  }
  ne(t2, e) {
    t2.se(e);
  }
  oe(t2) {
    t2.se(2);
  }
};
zi.fe = new zi();
function Hi(t2) {
  if (t2 === 0)
    return 8;
  let e = 0;
  return t2 >> 4 == 0 && (e += 4, t2 <<= 4), t2 >> 6 == 0 && (e += 2, t2 <<= 2), t2 >> 7 == 0 && (e += 1), e;
}
function Ji(t2) {
  const e = 64 - function(t3) {
    let e2 = 0;
    for (let n = 0; n < 8; ++n) {
      const s = Hi(255 & t3[n]);
      if (e2 += s, s !== 8)
        break;
    }
    return e2;
  }(t2);
  return Math.ceil(e / 8);
}
var Yi = class {
  constructor() {
    this.buffer = new Uint8Array(1024), this.position = 0;
  }
  de(t2) {
    const e = t2[Symbol.iterator]();
    let n = e.next();
    for (; !n.done; )
      this._e(n.value), n = e.next();
    this.we();
  }
  me(t2) {
    const e = t2[Symbol.iterator]();
    let n = e.next();
    for (; !n.done; )
      this.ge(n.value), n = e.next();
    this.ye();
  }
  pe(t2) {
    for (const e of t2) {
      const t3 = e.charCodeAt(0);
      if (t3 < 128)
        this._e(t3);
      else if (t3 < 2048)
        this._e(960 | t3 >>> 6), this._e(128 | 63 & t3);
      else if (e < "\uD800" || "\uDBFF" < e)
        this._e(480 | t3 >>> 12), this._e(128 | 63 & t3 >>> 6), this._e(128 | 63 & t3);
      else {
        const t4 = e.codePointAt(0);
        this._e(240 | t4 >>> 18), this._e(128 | 63 & t4 >>> 12), this._e(128 | 63 & t4 >>> 6), this._e(128 | 63 & t4);
      }
    }
    this.we();
  }
  Ie(t2) {
    for (const e of t2) {
      const t3 = e.charCodeAt(0);
      if (t3 < 128)
        this.ge(t3);
      else if (t3 < 2048)
        this.ge(960 | t3 >>> 6), this.ge(128 | 63 & t3);
      else if (e < "\uD800" || "\uDBFF" < e)
        this.ge(480 | t3 >>> 12), this.ge(128 | 63 & t3 >>> 6), this.ge(128 | 63 & t3);
      else {
        const t4 = e.codePointAt(0);
        this.ge(240 | t4 >>> 18), this.ge(128 | 63 & t4 >>> 12), this.ge(128 | 63 & t4 >>> 6), this.ge(128 | 63 & t4);
      }
    }
    this.ye();
  }
  Te(t2) {
    const e = this.Ee(t2), n = Ji(e);
    this.Ae(1 + n), this.buffer[this.position++] = 255 & n;
    for (let t3 = e.length - n; t3 < e.length; ++t3)
      this.buffer[this.position++] = 255 & e[t3];
  }
  Re(t2) {
    const e = this.Ee(t2), n = Ji(e);
    this.Ae(1 + n), this.buffer[this.position++] = ~(255 & n);
    for (let t3 = e.length - n; t3 < e.length; ++t3)
      this.buffer[this.position++] = ~(255 & e[t3]);
  }
  be() {
    this.Pe(255), this.Pe(255);
  }
  Ve() {
    this.ve(255), this.ve(255);
  }
  reset() {
    this.position = 0;
  }
  seed(t2) {
    this.Ae(t2.length), this.buffer.set(t2, this.position), this.position += t2.length;
  }
  Se() {
    return this.buffer.slice(0, this.position);
  }
  Ee(t2) {
    const e = function(t3) {
      const e2 = new DataView(new ArrayBuffer(8));
      return e2.setFloat64(0, t3, false), new Uint8Array(e2.buffer);
    }(t2), n = (128 & e[0]) != 0;
    e[0] ^= n ? 255 : 128;
    for (let t3 = 1; t3 < e.length; ++t3)
      e[t3] ^= n ? 255 : 0;
    return e;
  }
  _e(t2) {
    const e = 255 & t2;
    e === 0 ? (this.Pe(0), this.Pe(255)) : e === 255 ? (this.Pe(255), this.Pe(0)) : this.Pe(e);
  }
  ge(t2) {
    const e = 255 & t2;
    e === 0 ? (this.ve(0), this.ve(255)) : e === 255 ? (this.ve(255), this.ve(0)) : this.ve(t2);
  }
  we() {
    this.Pe(0), this.Pe(1);
  }
  ye() {
    this.ve(0), this.ve(1);
  }
  Pe(t2) {
    this.Ae(1), this.buffer[this.position++] = t2;
  }
  ve(t2) {
    this.Ae(1), this.buffer[this.position++] = ~t2;
  }
  Ae(t2) {
    const e = t2 + this.position;
    if (e <= this.buffer.length)
      return;
    let n = 2 * this.buffer.length;
    n < e && (n = e);
    const s = new Uint8Array(n);
    s.set(this.buffer), this.buffer = s;
  }
};
var Xi = class {
  constructor(t2) {
    this.De = t2;
  }
  ue(t2) {
    this.De.de(t2);
  }
  ie(t2) {
    this.De.pe(t2);
  }
  se(t2) {
    this.De.Te(t2);
  }
  ee() {
    this.De.be();
  }
};
var Zi = class {
  constructor(t2) {
    this.De = t2;
  }
  ue(t2) {
    this.De.me(t2);
  }
  ie(t2) {
    this.De.Ie(t2);
  }
  se(t2) {
    this.De.Re(t2);
  }
  ee() {
    this.De.Ve();
  }
};
var tr = class {
  constructor() {
    this.De = new Yi(), this.Ce = new Xi(this.De), this.xe = new Zi(this.De);
  }
  seed(t2) {
    this.De.seed(t2);
  }
  Ne(t2) {
    return t2 === 0 ? this.Ce : this.xe;
  }
  Se() {
    return this.De.Se();
  }
  reset() {
    this.De.reset();
  }
};
var er = class {
  constructor(t2, e, n, s) {
    this.indexId = t2, this.documentKey = e, this.arrayValue = n, this.directionalValue = s;
  }
  ke() {
    const t2 = this.directionalValue.length, e = t2 === 0 || this.directionalValue[t2 - 1] === 255 ? t2 + 1 : t2, n = new Uint8Array(e);
    return n.set(this.directionalValue, 0), e !== t2 ? n.set([0], this.directionalValue.length) : ++n[n.length - 1], new er(this.indexId, this.documentKey, this.arrayValue, n);
  }
};
function nr(t2, e) {
  let n = t2.indexId - e.indexId;
  return n !== 0 ? n : (n = sr(t2.arrayValue, e.arrayValue), n !== 0 ? n : (n = sr(t2.directionalValue, e.directionalValue), n !== 0 ? n : xt.comparator(t2.documentKey, e.documentKey)));
}
function sr(t2, e) {
  for (let n = 0; n < t2.length && n < e.length; ++n) {
    const s = t2[n] - e[n];
    if (s !== 0)
      return s;
  }
  return t2.length - e.length;
}
var ir = class {
  constructor(t2) {
    this.collectionId = t2.collectionGroup != null ? t2.collectionGroup : t2.path.lastSegment(), this.Me = t2.orderBy, this.Oe = [];
    for (const e of t2.filters) {
      const t3 = e;
      t3.S() ? this.Fe = t3 : this.Oe.push(t3);
    }
  }
  $e(t2) {
    const e = ne(t2);
    if (e !== void 0 && !this.Be(e))
      return false;
    const n = se(t2);
    let s = 0, i = 0;
    for (; s < n.length && this.Be(n[s]); ++s)
      ;
    if (s === n.length)
      return true;
    if (this.Fe !== void 0) {
      const t3 = n[s];
      if (!this.Le(this.Fe, t3) || !this.Ue(this.Me[i++], t3))
        return false;
      ++s;
    }
    for (; s < n.length; ++s) {
      const t3 = n[s];
      if (i >= this.Me.length || !this.Ue(this.Me[i++], t3))
        return false;
    }
    return true;
  }
  Be(t2) {
    for (const e of this.Oe)
      if (this.Le(e, t2))
        return true;
    return false;
  }
  Le(t2, e) {
    if (t2 === void 0 || !t2.field.isEqual(e.fieldPath))
      return false;
    const n = t2.op === "array-contains" || t2.op === "array-contains-any";
    return e.kind === 2 === n;
  }
  Ue(t2, e) {
    return !!t2.field.isEqual(e.fieldPath) && (e.kind === 0 && t2.dir === "asc" || e.kind === 1 && t2.dir === "desc");
  }
};
var rr = class {
  constructor() {
    this.qe = new or();
  }
  addToCollectionParentIndex(t2, e) {
    return this.qe.add(e), wi.resolve();
  }
  getCollectionParents(t2, e) {
    return wi.resolve(this.qe.getEntries(e));
  }
  addFieldIndex(t2, e) {
    return wi.resolve();
  }
  deleteFieldIndex(t2, e) {
    return wi.resolve();
  }
  getDocumentsMatchingTarget(t2, e) {
    return wi.resolve(null);
  }
  getFieldIndex(t2, e) {
    return wi.resolve(null);
  }
  getFieldIndexes(t2, e) {
    return wi.resolve([]);
  }
  getNextCollectionGroupToUpdate(t2) {
    return wi.resolve(null);
  }
  updateCollectionGroup(t2, e, n) {
    return wi.resolve();
  }
  updateIndexEntries(t2, e) {
    return wi.resolve();
  }
};
var or = class {
  constructor() {
    this.index = {};
  }
  add(t2) {
    const e = t2.lastSegment(), n = t2.popLast(), s = this.index[e] || new $n(_t.comparator), i = !s.has(n);
    return this.index[e] = s.add(n), i;
  }
  has(t2) {
    const e = t2.lastSegment(), n = t2.popLast(), s = this.index[e];
    return s && s.has(n);
  }
  getEntries(t2) {
    return (this.index[t2] || new $n(_t.comparator)).toArray();
  }
};
var ur = new Uint8Array(0);
var ar = class {
  constructor(t2) {
    this.user = t2, this.Ge = new or(), this.Ke = new kn((t3) => fe(t3), (t3, e) => _e(t3, e)), this.uid = t2.uid || "";
  }
  addToCollectionParentIndex(t2, e) {
    if (!this.Ge.has(e)) {
      const n = e.lastSegment(), s = e.popLast();
      t2.addOnCommittedListener(() => {
        this.Ge.add(e);
      });
      const i = {
        collectionId: n,
        parent: Us(s)
      };
      return cr(t2).put(i);
    }
    return wi.resolve();
  }
  getCollectionParents(t2, e) {
    const n = [], s = IDBKeyRange.bound([e, ""], [ut(e), ""], false, true);
    return cr(t2).qt(s).next((t3) => {
      for (const s2 of t3) {
        if (s2.collectionId !== e)
          break;
        n.push(Ks(s2.parent));
      }
      return n;
    });
  }
  addFieldIndex(t2, e) {
    const n = lr(t2), s = function(t3) {
      return {
        indexId: t3.indexId,
        collectionGroup: t3.collectionGroup,
        fields: t3.fields.map((t4) => [t4.fieldPath.canonicalString(), t4.kind])
      };
    }(e);
    return delete s.indexId, n.add(s).next();
  }
  deleteFieldIndex(t2, e) {
    const n = lr(t2), s = fr(t2), i = hr(t2);
    return n.delete(e.indexId).next(() => s.delete(IDBKeyRange.bound([e.indexId], [e.indexId + 1], false, true))).next(() => i.delete(IDBKeyRange.bound([e.indexId], [e.indexId + 1], false, true)));
  }
  getDocumentsMatchingTarget(t2, e) {
    const n = hr(t2);
    let s = true;
    const i = /* @__PURE__ */ new Map();
    return wi.forEach(this.Qe(e), (e2) => this.getFieldIndex(t2, e2).next((t3) => {
      s && (s = !!t3), i.set(e2, t3);
    })).next(() => {
      if (s) {
        let t3 = zn();
        return wi.forEach(i, (s2, i2) => {
          var r;
          O2("IndexedDbIndexManager", `Using index ${r = s2, `id=${r.indexId}|cg=${r.collectionGroup}|f=${r.fields.map((t4) => `${t4.fieldPath}:${t4.kind}`).join(",")}`} to execute ${fe(e)}`);
          const o = function(t4, e2) {
            const n2 = ne(e2);
            if (n2 === void 0)
              return null;
            for (const e3 of me(t4, n2.fieldPath))
              switch (e3.op) {
                case "array-contains-any":
                  return e3.value.arrayValue.values || [];
                case "array-contains":
                  return [e3.value];
              }
            return null;
          }(i2, s2), u = function(t4, e2) {
            const n2 = /* @__PURE__ */ new Map();
            for (const s3 of se(e2))
              for (const e3 of me(t4, s3.fieldPath))
                switch (e3.op) {
                  case "==":
                  case "in":
                    n2.set(s3.fieldPath.canonicalString(), e3.value);
                    break;
                  case "not-in":
                  case "!=":
                    return n2.set(s3.fieldPath.canonicalString(), e3.value), Array.from(n2.values());
                }
            return null;
          }(i2, s2), a = function(t4, e2) {
            const n2 = [];
            let s3 = true;
            for (const r2 of se(e2)) {
              let e3, o2 = true;
              for (const n3 of me(t4, r2.fieldPath)) {
                let t5, s4 = true;
                switch (n3.op) {
                  case "<":
                  case "<=":
                    t5 = "nullValue" in (i3 = n3.value) ? kt : "booleanValue" in i3 ? {
                      booleanValue: false
                    } : "integerValue" in i3 || "doubleValue" in i3 ? {
                      doubleValue: NaN
                    } : "timestampValue" in i3 ? {
                      timestampValue: {
                        seconds: Number.MIN_SAFE_INTEGER
                      }
                    } : "stringValue" in i3 ? {
                      stringValue: ""
                    } : "bytesValue" in i3 ? {
                      bytesValue: ""
                    } : "referenceValue" in i3 ? qt(vt.empty(), xt.empty()) : "geoPointValue" in i3 ? {
                      geoPointValue: {
                        latitude: -90,
                        longitude: -180
                      }
                    } : "arrayValue" in i3 ? {
                      arrayValue: {}
                    } : "mapValue" in i3 ? {
                      mapValue: {}
                    } : L2();
                    break;
                  case "==":
                  case "in":
                  case ">=":
                    t5 = n3.value;
                    break;
                  case ">":
                    t5 = n3.value, s4 = false;
                    break;
                  case "!=":
                  case "not-in":
                    t5 = kt;
                }
                Jt(e3, t5) === t5 && (e3 = t5, o2 = s4);
              }
              if (t4.startAt !== null) {
                for (let n3 = 0; n3 < t4.orderBy.length; ++n3)
                  if (t4.orderBy[n3].field.isEqual(r2.fieldPath)) {
                    const s4 = t4.startAt.position[n3];
                    Jt(e3, s4) === s4 && (e3 = s4, o2 = t4.startAt.inclusive);
                    break;
                  }
              }
              if (e3 === void 0)
                return null;
              n2.push(e3), s3 && (s3 = o2);
            }
            var i3;
            return new Pe(n2, s3);
          }(i2, s2), c = function(t4, e2) {
            const n2 = [];
            let s3 = true;
            for (const r2 of se(e2)) {
              let e3, o2 = true;
              for (const n3 of me(t4, r2.fieldPath)) {
                let t5, s4 = true;
                switch (n3.op) {
                  case ">=":
                  case ">":
                    t5 = "nullValue" in (i3 = n3.value) ? {
                      booleanValue: false
                    } : "booleanValue" in i3 ? {
                      doubleValue: NaN
                    } : "integerValue" in i3 || "doubleValue" in i3 ? {
                      timestampValue: {
                        seconds: Number.MIN_SAFE_INTEGER
                      }
                    } : "timestampValue" in i3 ? {
                      stringValue: ""
                    } : "stringValue" in i3 ? {
                      bytesValue: ""
                    } : "bytesValue" in i3 ? qt(vt.empty(), xt.empty()) : "referenceValue" in i3 ? {
                      geoPointValue: {
                        latitude: -90,
                        longitude: -180
                      }
                    } : "geoPointValue" in i3 ? {
                      arrayValue: {}
                    } : "arrayValue" in i3 ? {
                      mapValue: {}
                    } : "mapValue" in i3 ? Nt : L2(), s4 = false;
                    break;
                  case "==":
                  case "in":
                  case "<=":
                    t5 = n3.value;
                    break;
                  case "<":
                    t5 = n3.value, s4 = false;
                    break;
                  case "!=":
                  case "not-in":
                    t5 = Nt;
                }
                Yt(e3, t5) === t5 && (e3 = t5, o2 = s4);
              }
              if (t4.endAt !== null) {
                for (let n3 = 0; n3 < t4.orderBy.length; ++n3)
                  if (t4.orderBy[n3].field.isEqual(r2.fieldPath)) {
                    const s4 = t4.endAt.position[n3];
                    Yt(e3, s4) === s4 && (e3 = s4, o2 = t4.endAt.inclusive);
                    break;
                  }
              }
              if (e3 === void 0)
                return null;
              n2.push(e3), s3 && (s3 = o2);
            }
            var i3;
            return new Pe(n2, s3);
          }(i2, s2), h = this.je(s2, i2, a), l2 = this.je(s2, i2, c), f = this.We(s2, i2, u), d = this.ze(s2.indexId, o, h, !!a && a.inclusive, l2, !!c && c.inclusive, f);
          return wi.forEach(d, (s3) => n.Kt(s3, e.limit).next((e2) => {
            e2.forEach((e3) => {
              t3 = t3.add(new xt(Ks(e3.documentKey)));
            });
          }));
        }).next(() => t3);
      }
      return wi.resolve(null);
    });
  }
  Qe(t2) {
    let e = this.Ke.get(t2);
    return e || (e = [t2], this.Ke.set(t2, e), e);
  }
  ze(t2, e, n, s, i, r, o) {
    const u = (e != null ? e.length : 1) * Math.max(n != null ? n.length : 1, i != null ? i.length : 1), a = u / (e != null ? e.length : 1), c = [];
    for (let h = 0; h < u; ++h) {
      const u2 = e ? this.He(e[h / a]) : ur, l2 = n ? this.Je(t2, u2, n[h % a], s) : this.Ye(t2), f = i ? this.Xe(t2, u2, i[h % a], r) : this.Ye(t2 + 1);
      c.push(...this.createRange(l2, f, o.map((e2) => this.Je(t2, u2, e2, true))));
    }
    return c;
  }
  Je(t2, e, n, s) {
    const i = new er(t2, xt.empty(), e, n);
    return s ? i : i.ke();
  }
  Xe(t2, e, n, s) {
    const i = new er(t2, xt.empty(), e, n);
    return s ? i.ke() : i;
  }
  Ye(t2) {
    return new er(t2, xt.empty(), ur, ur);
  }
  getFieldIndex(t2, e) {
    const n = new ir(e), s = e.collectionGroup != null ? e.collectionGroup : e.path.lastSegment();
    return this.getFieldIndexes(t2, s).next((t3) => {
      const e2 = t3.filter((t4) => n.$e(t4));
      return e2.sort((t4, e3) => e3.fields.length - t4.fields.length), e2.length > 0 ? e2[0] : null;
    });
  }
  Ze(t2, e) {
    const n = new tr();
    for (const s of se(t2)) {
      const t3 = e.data.field(s.fieldPath);
      if (t3 == null)
        return null;
      const i = n.Ne(s.kind);
      zi.fe.Zt(t3, i);
    }
    return n.Se();
  }
  He(t2) {
    const e = new tr();
    return zi.fe.Zt(t2, e.Ne(0)), e.Se();
  }
  We(t2, e, n) {
    if (n === null)
      return [];
    let s = [];
    s.push(new tr());
    let i = 0;
    for (const r of se(t2)) {
      const t3 = n[i++];
      for (const n2 of s)
        if (this.tn(e, r.fieldPath) && Kt(t3))
          s = this.en(s, r, t3);
        else {
          const e2 = n2.Ne(r.kind);
          zi.fe.Zt(t3, e2);
        }
    }
    return this.nn(s);
  }
  je(t2, e, n) {
    return n == null ? null : this.We(t2, e, n.position);
  }
  nn(t2) {
    const e = [];
    for (let n = 0; n < t2.length; ++n)
      e[n] = t2[n].Se();
    return e;
  }
  en(t2, e, n) {
    const s = [...t2], i = [];
    for (const t3 of n.arrayValue.values || [])
      for (const n2 of s) {
        const s2 = new tr();
        s2.seed(n2.Se()), zi.fe.Zt(t3, s2.Ne(e.kind)), i.push(s2);
      }
    return i;
  }
  tn(t2, e) {
    return !!t2.filters.find((t3) => t3 instanceof ge && t3.field.isEqual(e) && (t3.op === "in" || t3.op === "not-in"));
  }
  getFieldIndexes(t2, e) {
    const n = lr(t2), s = fr(t2);
    return (e ? n.qt("collectionGroupIndex", IDBKeyRange.bound(e, e)) : n.qt()).next((t3) => {
      const e2 = [];
      return wi.forEach(t3, (t4) => s.get([t4.indexId, this.uid]).next((n2) => {
        e2.push(function(t5, e3) {
          const n3 = e3 ? new re(e3.sequenceNumber, new ae(Oi(e3.readTime), new xt(Ks(e3.documentKey)), e3.largestBatchId)) : re.empty(), s2 = t5.fields.map(([t6, e4]) => new ie(mt.fromServerFormat(t6), e4));
          return new ee(t5.indexId, t5.collectionGroup, s2, n3);
        }(t4, n2));
      })).next(() => e2);
    });
  }
  getNextCollectionGroupToUpdate(t2) {
    return this.getFieldIndexes(t2).next((t3) => t3.length === 0 ? null : (t3.sort((t4, e) => {
      const n = t4.indexState.sequenceNumber - e.indexState.sequenceNumber;
      return n !== 0 ? n : rt(t4.collectionGroup, e.collectionGroup);
    }), t3[0].collectionGroup));
  }
  updateCollectionGroup(t2, e, n) {
    const s = lr(t2), i = fr(t2);
    return this.sn(t2).next((t3) => s.qt("collectionGroupIndex", IDBKeyRange.bound(e, e)).next((e2) => wi.forEach(e2, (e3) => i.put(function(t4, e4, n2, s2) {
      return {
        indexId: t4,
        uid: e4.uid || "",
        sequenceNumber: n2,
        readTime: Mi(s2.readTime),
        documentKey: Us(s2.documentKey.path),
        largestBatchId: s2.largestBatchId
      };
    }(e3.indexId, this.user, t3, n)))));
  }
  updateIndexEntries(t2, e) {
    const n = /* @__PURE__ */ new Map();
    return wi.forEach(e, (e2, s) => {
      const i = n.get(e2.collectionGroup);
      return (i ? wi.resolve(i) : this.getFieldIndexes(t2, e2.collectionGroup)).next((i2) => (n.set(e2.collectionGroup, i2), wi.forEach(i2, (n2) => this.rn(t2, e2, n2).next((e3) => {
        const i3 = this.on(s, n2);
        return e3.isEqual(i3) ? wi.resolve() : this.un(t2, s, e3, i3);
      }))));
    });
  }
  an(t2, e, n) {
    return hr(t2).put({
      indexId: n.indexId,
      uid: this.uid,
      arrayValue: n.arrayValue,
      directionalValue: n.directionalValue,
      documentKey: Us(e.key.path)
    });
  }
  cn(t2, e, n) {
    return hr(t2).delete([n.indexId, this.uid, n.arrayValue, n.directionalValue, Us(e.key.path)]);
  }
  rn(t2, e, n) {
    const s = hr(t2);
    let i = new $n(nr);
    return s.Wt({
      index: "documentKeyIndex",
      range: IDBKeyRange.only([n.indexId, this.uid, Us(e.path)])
    }, (t3, s2) => {
      i = i.add(new er(n.indexId, e, s2.arrayValue, s2.directionalValue));
    }).next(() => i);
  }
  on(t2, e) {
    let n = new $n(nr);
    const s = this.Ze(e, t2);
    if (s == null)
      return n;
    const i = ne(e);
    if (i != null) {
      const r = t2.data.field(i.fieldPath);
      if (Kt(r))
        for (const i2 of r.arrayValue.values || [])
          n = n.add(new er(e.indexId, t2.key, this.He(i2), s));
    } else
      n = n.add(new er(e.indexId, t2.key, ur, s));
    return n;
  }
  un(t2, e, n, s) {
    O2("IndexedDbIndexManager", "Updating index entries for document '%s'", e.key);
    const i = [];
    return function(t3, e2, n2, s2, i2) {
      const r = t3.getIterator(), o = e2.getIterator();
      let u = Ln(r), a = Ln(o);
      for (; u || a; ) {
        let t4 = false, e3 = false;
        if (u && a) {
          const s3 = n2(u, a);
          s3 < 0 ? e3 = true : s3 > 0 && (t4 = true);
        } else
          u != null ? e3 = true : t4 = true;
        t4 ? (s2(a), a = Ln(o)) : e3 ? (i2(u), u = Ln(r)) : (u = Ln(r), a = Ln(o));
      }
    }(n, s, nr, (n2) => {
      i.push(this.an(t2, e, n2));
    }, (n2) => {
      i.push(this.cn(t2, e, n2));
    }), wi.waitFor(i);
  }
  sn(t2) {
    let e = 1;
    return fr(t2).Wt({
      index: "sequenceNumberIndex",
      reverse: true,
      range: IDBKeyRange.upperBound([this.uid, Number.MAX_SAFE_INTEGER])
    }, (t3, n, s) => {
      s.done(), e = n.sequenceNumber + 1;
    }).next(() => e);
  }
  createRange(t2, e, n) {
    n = n.sort((t3, e2) => nr(t3, e2)).filter((t3, e2, n2) => !e2 || nr(t3, n2[e2 - 1]) !== 0);
    const s = [];
    s.push(t2);
    for (const i2 of n) {
      const n2 = nr(i2, t2), r = nr(i2, e);
      if (n2 === 0)
        s[0] = t2.ke();
      else if (n2 > 0 && r < 0)
        s.push(i2), s.push(i2.ke());
      else if (r > 0)
        break;
    }
    s.push(e);
    const i = [];
    for (let t3 = 0; t3 < s.length; t3 += 2)
      i.push(IDBKeyRange.bound([s[t3].indexId, this.uid, s[t3].arrayValue, s[t3].directionalValue, ""], [s[t3 + 1].indexId, this.uid, s[t3 + 1].arrayValue, s[t3 + 1].directionalValue, ""]));
    return i;
  }
};
function cr(t2) {
  return Pi(t2, "collectionParents");
}
function hr(t2) {
  return Pi(t2, "indexEntries");
}
function lr(t2) {
  return Pi(t2, "indexConfiguration");
}
function fr(t2) {
  return Pi(t2, "indexState");
}
var dr = {
  didRun: false,
  sequenceNumbersCollected: 0,
  targetsRemoved: 0,
  documentsRemoved: 0
};
var _r = class {
  constructor(t2, e, n) {
    this.cacheSizeCollectionThreshold = t2, this.percentileToCollect = e, this.maximumSequenceNumbersToCollect = n;
  }
  static withCacheSize(t2) {
    return new _r(t2, _r.DEFAULT_COLLECTION_PERCENTILE, _r.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT);
  }
};
function wr(t2, e, n) {
  const s = t2.store("mutations"), i = t2.store("documentMutations"), r = [], o = IDBKeyRange.only(n.batchId);
  let u = 0;
  const a = s.Wt({
    range: o
  }, (t3, e2, n2) => (u++, n2.delete()));
  r.push(a.next(() => {
    U2(u === 1);
  }));
  const c = [];
  for (const t3 of n.mutations) {
    const s2 = Ws(e, t3.key.path, n.batchId);
    r.push(i.delete(s2)), c.push(t3.key);
  }
  return wi.waitFor(r).next(() => c);
}
function mr(t2) {
  if (!t2)
    return 0;
  let e;
  if (t2.document)
    e = t2.document;
  else if (t2.unknownDocument)
    e = t2.unknownDocument;
  else {
    if (!t2.noDocument)
      throw L2();
    e = t2.noDocument;
  }
  return JSON.stringify(e).length;
}
_r.DEFAULT_COLLECTION_PERCENTILE = 10, _r.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT = 1e3, _r.DEFAULT = new _r(41943040, _r.DEFAULT_COLLECTION_PERCENTILE, _r.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT), _r.DISABLED = new _r(-1, 0, 0);
var gr = class {
  constructor(t2, e, n, s) {
    this.userId = t2, this.M = e, this.indexManager = n, this.referenceDelegate = s, this.hn = {};
  }
  static Yt(t2, e, n, s) {
    U2(t2.uid !== "");
    const i = t2.isAuthenticated() ? t2.uid : "";
    return new gr(i, e, n, s);
  }
  checkEmpty(t2) {
    let e = true;
    const n = IDBKeyRange.bound([this.userId, Number.NEGATIVE_INFINITY], [this.userId, Number.POSITIVE_INFINITY]);
    return pr(t2).Wt({
      index: "userMutationsIndex",
      range: n
    }, (t3, n2, s) => {
      e = false, s.done();
    }).next(() => e);
  }
  addMutationBatch(t2, e, n, s) {
    const i = Ir(t2), r = pr(t2);
    return r.add({}).next((o) => {
      U2(typeof o == "number");
      const u = new Vi(o, e, n, s), a = function(t3, e2, n2) {
        const s2 = n2.baseMutations.map((e3) => bs(t3.Jt, e3)), i2 = n2.mutations.map((e3) => bs(t3.Jt, e3));
        return {
          userId: e2,
          batchId: n2.batchId,
          localWriteTimeMs: n2.localWriteTime.toMillis(),
          baseMutations: s2,
          mutations: i2
        };
      }(this.M, this.userId, u), c = [];
      let h = new $n((t3, e2) => rt(t3.canonicalString(), e2.canonicalString()));
      for (const t3 of s) {
        const e2 = Ws(this.userId, t3.key.path, o);
        h = h.add(t3.key.path.popLast()), c.push(r.put(a)), c.push(i.put(e2, zs));
      }
      return h.forEach((e2) => {
        c.push(this.indexManager.addToCollectionParentIndex(t2, e2));
      }), t2.addOnCommittedListener(() => {
        this.hn[o] = u.keys();
      }), wi.waitFor(c).next(() => u);
    });
  }
  lookupMutationBatch(t2, e) {
    return pr(t2).get(e).next((t3) => t3 ? (U2(t3.userId === this.userId), Fi(this.M, t3)) : null);
  }
  ln(t2, e) {
    return this.hn[e] ? wi.resolve(this.hn[e]) : this.lookupMutationBatch(t2, e).next((t3) => {
      if (t3) {
        const n = t3.keys();
        return this.hn[e] = n, n;
      }
      return null;
    });
  }
  getNextMutationBatchAfterBatchId(t2, e) {
    const n = e + 1, s = IDBKeyRange.lowerBound([this.userId, n]);
    let i = null;
    return pr(t2).Wt({
      index: "userMutationsIndex",
      range: s
    }, (t3, e2, s2) => {
      e2.userId === this.userId && (U2(e2.batchId >= n), i = Fi(this.M, e2)), s2.done();
    }).next(() => i);
  }
  getHighestUnacknowledgedBatchId(t2) {
    const e = IDBKeyRange.upperBound([this.userId, Number.POSITIVE_INFINITY]);
    let n = -1;
    return pr(t2).Wt({
      index: "userMutationsIndex",
      range: e,
      reverse: true
    }, (t3, e2, s) => {
      n = e2.batchId, s.done();
    }).next(() => n);
  }
  getAllMutationBatches(t2) {
    const e = IDBKeyRange.bound([this.userId, -1], [this.userId, Number.POSITIVE_INFINITY]);
    return pr(t2).qt("userMutationsIndex", e).next((t3) => t3.map((t4) => Fi(this.M, t4)));
  }
  getAllMutationBatchesAffectingDocumentKey(t2, e) {
    const n = js(this.userId, e.path), s = IDBKeyRange.lowerBound(n), i = [];
    return Ir(t2).Wt({
      range: s
    }, (n2, s2, r) => {
      const [o, u, a] = n2, c = Ks(u);
      if (o === this.userId && e.path.isEqual(c))
        return pr(t2).get(a).next((t3) => {
          if (!t3)
            throw L2();
          U2(t3.userId === this.userId), i.push(Fi(this.M, t3));
        });
      r.done();
    }).next(() => i);
  }
  getAllMutationBatchesAffectingDocumentKeys(t2, e) {
    let n = new $n(rt);
    const s = [];
    return e.forEach((e2) => {
      const i = js(this.userId, e2.path), r = IDBKeyRange.lowerBound(i), o = Ir(t2).Wt({
        range: r
      }, (t3, s2, i2) => {
        const [r2, o2, u] = t3, a = Ks(o2);
        r2 === this.userId && e2.path.isEqual(a) ? n = n.add(u) : i2.done();
      });
      s.push(o);
    }), wi.waitFor(s).next(() => this.fn(t2, n));
  }
  getAllMutationBatchesAffectingQuery(t2, e) {
    const n = e.path, s = n.length + 1, i = js(this.userId, n), r = IDBKeyRange.lowerBound(i);
    let o = new $n(rt);
    return Ir(t2).Wt({
      range: r
    }, (t3, e2, i2) => {
      const [r2, u, a] = t3, c = Ks(u);
      r2 === this.userId && n.isPrefixOf(c) ? c.length === s && (o = o.add(a)) : i2.done();
    }).next(() => this.fn(t2, o));
  }
  fn(t2, e) {
    const n = [], s = [];
    return e.forEach((e2) => {
      s.push(pr(t2).get(e2).next((t3) => {
        if (t3 === null)
          throw L2();
        U2(t3.userId === this.userId), n.push(Fi(this.M, t3));
      }));
    }), wi.waitFor(s).next(() => n);
  }
  removeMutationBatch(t2, e) {
    return wr(t2.Ht, this.userId, e).next((n) => (t2.addOnCommittedListener(() => {
      this.dn(e.batchId);
    }), wi.forEach(n, (e2) => this.referenceDelegate.markPotentiallyOrphaned(t2, e2))));
  }
  dn(t2) {
    delete this.hn[t2];
  }
  performConsistencyCheck(t2) {
    return this.checkEmpty(t2).next((e) => {
      if (!e)
        return wi.resolve();
      const n = IDBKeyRange.lowerBound([this.userId]);
      const s = [];
      return Ir(t2).Wt({
        range: n
      }, (t3, e2, n2) => {
        if (t3[0] === this.userId) {
          const e3 = Ks(t3[1]);
          s.push(e3);
        } else
          n2.done();
      }).next(() => {
        U2(s.length === 0);
      });
    });
  }
  containsKey(t2, e) {
    return yr(t2, this.userId, e);
  }
  _n(t2) {
    return Tr(t2).get(this.userId).next((t3) => t3 || {
      userId: this.userId,
      lastAcknowledgedBatchId: -1,
      lastStreamToken: ""
    });
  }
};
function yr(t2, e, n) {
  const s = js(e, n.path), i = s[1], r = IDBKeyRange.lowerBound(s);
  let o = false;
  return Ir(t2).Wt({
    range: r,
    jt: true
  }, (t3, n2, s2) => {
    const [r2, u, a] = t3;
    r2 === e && u === i && (o = true), s2.done();
  }).next(() => o);
}
function pr(t2) {
  return Pi(t2, "mutations");
}
function Ir(t2) {
  return Pi(t2, "documentMutations");
}
function Tr(t2) {
  return Pi(t2, "mutationQueues");
}
var Er = class {
  constructor(t2) {
    this.wn = t2;
  }
  next() {
    return this.wn += 2, this.wn;
  }
  static mn() {
    return new Er(0);
  }
  static gn() {
    return new Er(-1);
  }
};
var Ar = class {
  constructor(t2, e) {
    this.referenceDelegate = t2, this.M = e;
  }
  allocateTargetId(t2) {
    return this.yn(t2).next((e) => {
      const n = new Er(e.highestTargetId);
      return e.highestTargetId = n.next(), this.pn(t2, e).next(() => e.highestTargetId);
    });
  }
  getLastRemoteSnapshotVersion(t2) {
    return this.yn(t2).next((t3) => ct.fromTimestamp(new at(t3.lastRemoteSnapshotVersion.seconds, t3.lastRemoteSnapshotVersion.nanoseconds)));
  }
  getHighestSequenceNumber(t2) {
    return this.yn(t2).next((t3) => t3.highestListenSequenceNumber);
  }
  setTargetsMetadata(t2, e, n) {
    return this.yn(t2).next((s) => (s.highestListenSequenceNumber = e, n && (s.lastRemoteSnapshotVersion = n.toTimestamp()), e > s.highestListenSequenceNumber && (s.highestListenSequenceNumber = e), this.pn(t2, s)));
  }
  addTargetData(t2, e) {
    return this.In(t2, e).next(() => this.yn(t2).next((n) => (n.targetCount += 1, this.Tn(e, n), this.pn(t2, n))));
  }
  updateTargetData(t2, e) {
    return this.In(t2, e);
  }
  removeTargetData(t2, e) {
    return this.removeMatchingKeysForTargetId(t2, e.targetId).next(() => Rr(t2).delete(e.targetId)).next(() => this.yn(t2)).next((e2) => (U2(e2.targetCount > 0), e2.targetCount -= 1, this.pn(t2, e2)));
  }
  removeTargets(t2, e, n) {
    let s = 0;
    const i = [];
    return Rr(t2).Wt((r, o) => {
      const u = $i(o);
      u.sequenceNumber <= e && n.get(u.targetId) === null && (s++, i.push(this.removeTargetData(t2, u)));
    }).next(() => wi.waitFor(i)).next(() => s);
  }
  forEachTarget(t2, e) {
    return Rr(t2).Wt((t3, n) => {
      const s = $i(n);
      e(s);
    });
  }
  yn(t2) {
    return br(t2).get("targetGlobalKey").next((t3) => (U2(t3 !== null), t3));
  }
  pn(t2, e) {
    return br(t2).put("targetGlobalKey", e);
  }
  In(t2, e) {
    return Rr(t2).put(Bi(this.M, e));
  }
  Tn(t2, e) {
    let n = false;
    return t2.targetId > e.highestTargetId && (e.highestTargetId = t2.targetId, n = true), t2.sequenceNumber > e.highestListenSequenceNumber && (e.highestListenSequenceNumber = t2.sequenceNumber, n = true), n;
  }
  getTargetCount(t2) {
    return this.yn(t2).next((t3) => t3.targetCount);
  }
  getTargetData(t2, e) {
    const n = fe(e), s = IDBKeyRange.bound([n, Number.NEGATIVE_INFINITY], [n, Number.POSITIVE_INFINITY]);
    let i = null;
    return Rr(t2).Wt({
      range: s,
      index: "queryTargetsIndex"
    }, (t3, n2, s2) => {
      const r = $i(n2);
      _e(e, r.target) && (i = r, s2.done());
    }).next(() => i);
  }
  addMatchingKeys(t2, e, n) {
    const s = [], i = Pr(t2);
    return e.forEach((e2) => {
      const r = Us(e2.path);
      s.push(i.put({
        targetId: n,
        path: r
      })), s.push(this.referenceDelegate.addReference(t2, n, e2));
    }), wi.waitFor(s);
  }
  removeMatchingKeys(t2, e, n) {
    const s = Pr(t2);
    return wi.forEach(e, (e2) => {
      const i = Us(e2.path);
      return wi.waitFor([s.delete([n, i]), this.referenceDelegate.removeReference(t2, n, e2)]);
    });
  }
  removeMatchingKeysForTargetId(t2, e) {
    const n = Pr(t2), s = IDBKeyRange.bound([e], [e + 1], false, true);
    return n.delete(s);
  }
  getMatchingKeysForTargetId(t2, e) {
    const n = IDBKeyRange.bound([e], [e + 1], false, true), s = Pr(t2);
    let i = zn();
    return s.Wt({
      range: n,
      jt: true
    }, (t3, e2, n2) => {
      const s2 = Ks(t3[1]), r = new xt(s2);
      i = i.add(r);
    }).next(() => i);
  }
  containsKey(t2, e) {
    const n = Us(e.path), s = IDBKeyRange.bound([n], [ut(n)], false, true);
    let i = 0;
    return Pr(t2).Wt({
      index: "documentTargetsIndex",
      jt: true,
      range: s
    }, ([t3, e2], n2, s2) => {
      t3 !== 0 && (i++, s2.done());
    }).next(() => i > 0);
  }
  Et(t2, e) {
    return Rr(t2).get(e).next((t3) => t3 ? $i(t3) : null);
  }
};
function Rr(t2) {
  return Pi(t2, "targets");
}
function br(t2) {
  return Pi(t2, "targetGlobal");
}
function Pr(t2) {
  return Pi(t2, "targetDocuments");
}
async function Vr(t2) {
  if (t2.code !== K2.FAILED_PRECONDITION || t2.message !== di)
    throw t2;
  O2("LocalStore", "Unexpectedly lost primary lease");
}
function vr([t2, e], [n, s]) {
  const i = rt(t2, n);
  return i === 0 ? rt(e, s) : i;
}
var Sr = class {
  constructor(t2) {
    this.En = t2, this.buffer = new $n(vr), this.An = 0;
  }
  Rn() {
    return ++this.An;
  }
  bn(t2) {
    const e = [t2, this.Rn()];
    if (this.buffer.size < this.En)
      this.buffer = this.buffer.add(e);
    else {
      const t3 = this.buffer.last();
      vr(e, t3) < 0 && (this.buffer = this.buffer.delete(t3).add(e));
    }
  }
  get maxValue() {
    return this.buffer.last()[0];
  }
};
var Dr = class {
  constructor(t2, e) {
    this.garbageCollector = t2, this.asyncQueue = e, this.Pn = false, this.Vn = null;
  }
  start(t2) {
    this.garbageCollector.params.cacheSizeCollectionThreshold !== -1 && this.vn(t2);
  }
  stop() {
    this.Vn && (this.Vn.cancel(), this.Vn = null);
  }
  get started() {
    return this.Vn !== null;
  }
  vn(t2) {
    const e = this.Pn ? 3e5 : 6e4;
    O2("LruGarbageCollector", `Garbage collection scheduled in ${e}ms`), this.Vn = this.asyncQueue.enqueueAfterDelay("lru_garbage_collection", e, async () => {
      this.Vn = null, this.Pn = true;
      try {
        await t2.collectGarbage(this.garbageCollector);
      } catch (t3) {
        Ii(t3) ? O2("LruGarbageCollector", "Ignoring IndexedDB error during garbage collection: ", t3) : await Vr(t3);
      }
      await this.vn(t2);
    });
  }
};
var Cr = class {
  constructor(t2, e) {
    this.Sn = t2, this.params = e;
  }
  calculateTargetCount(t2, e) {
    return this.Sn.Dn(t2).next((t3) => Math.floor(e / 100 * t3));
  }
  nthSequenceNumber(t2, e) {
    if (e === 0)
      return wi.resolve(nt.A);
    const n = new Sr(e);
    return this.Sn.forEachTarget(t2, (t3) => n.bn(t3.sequenceNumber)).next(() => this.Sn.Cn(t2, (t3) => n.bn(t3))).next(() => n.maxValue);
  }
  removeTargets(t2, e, n) {
    return this.Sn.removeTargets(t2, e, n);
  }
  removeOrphanedDocuments(t2, e) {
    return this.Sn.removeOrphanedDocuments(t2, e);
  }
  collect(t2, e) {
    return this.params.cacheSizeCollectionThreshold === -1 ? (O2("LruGarbageCollector", "Garbage collection skipped; disabled"), wi.resolve(dr)) : this.getCacheSize(t2).next((n) => n < this.params.cacheSizeCollectionThreshold ? (O2("LruGarbageCollector", `Garbage collection skipped; Cache size ${n} is lower than threshold ${this.params.cacheSizeCollectionThreshold}`), dr) : this.xn(t2, e));
  }
  getCacheSize(t2) {
    return this.Sn.getCacheSize(t2);
  }
  xn(t2, e) {
    let n, s, i, r, o, a, c;
    const h = Date.now();
    return this.calculateTargetCount(t2, this.params.percentileToCollect).next((e2) => (e2 > this.params.maximumSequenceNumbersToCollect ? (O2("LruGarbageCollector", `Capping sequence numbers to collect down to the maximum of ${this.params.maximumSequenceNumbersToCollect} from ${e2}`), s = this.params.maximumSequenceNumbersToCollect) : s = e2, r = Date.now(), this.nthSequenceNumber(t2, s))).next((s2) => (n = s2, o = Date.now(), this.removeTargets(t2, n, e))).next((e2) => (i = e2, a = Date.now(), this.removeOrphanedDocuments(t2, n))).next((t3) => {
      if (c = Date.now(), k2() <= LogLevel.DEBUG) {
        O2("LruGarbageCollector", `LRU Garbage Collection
	Counted targets in ${r - h}ms
	Determined least recently used ${s} in ` + (o - r) + `ms
	Removed ${i} targets in ` + (a - o) + `ms
	Removed ${t3} documents in ` + (c - a) + `ms
Total Duration: ${c - h}ms`);
      }
      return wi.resolve({
        didRun: true,
        sequenceNumbersCollected: s,
        targetsRemoved: i,
        documentsRemoved: t3
      });
    });
  }
};
var xr = class {
  constructor(t2, e) {
    this.db = t2, this.garbageCollector = function(t3, e2) {
      return new Cr(t3, e2);
    }(this, e);
  }
  Dn(t2) {
    const e = this.Nn(t2);
    return this.db.getTargetCache().getTargetCount(t2).next((t3) => e.next((e2) => t3 + e2));
  }
  Nn(t2) {
    let e = 0;
    return this.Cn(t2, (t3) => {
      e++;
    }).next(() => e);
  }
  forEachTarget(t2, e) {
    return this.db.getTargetCache().forEachTarget(t2, e);
  }
  Cn(t2, e) {
    return this.kn(t2, (t3, n) => e(n));
  }
  addReference(t2, e, n) {
    return Nr(t2, n);
  }
  removeReference(t2, e, n) {
    return Nr(t2, n);
  }
  removeTargets(t2, e, n) {
    return this.db.getTargetCache().removeTargets(t2, e, n);
  }
  markPotentiallyOrphaned(t2, e) {
    return Nr(t2, e);
  }
  Mn(t2, e) {
    return function(t3, e2) {
      let n = false;
      return Tr(t3).zt((s) => yr(t3, s, e2).next((t4) => (t4 && (n = true), wi.resolve(!t4)))).next(() => n);
    }(t2, e);
  }
  removeOrphanedDocuments(t2, e) {
    const n = this.db.getRemoteDocumentCache().newChangeBuffer(), s = [];
    let i = 0;
    return this.kn(t2, (r, o) => {
      if (o <= e) {
        const e2 = this.Mn(t2, r).next((e3) => {
          if (!e3)
            return i++, n.getEntry(t2, r).next(() => (n.removeEntry(r, ct.min()), Pr(t2).delete([0, Us(r.path)])));
        });
        s.push(e2);
      }
    }).next(() => wi.waitFor(s)).next(() => n.apply(t2)).next(() => i);
  }
  removeTarget(t2, e) {
    const n = e.withSequenceNumber(t2.currentSequenceNumber);
    return this.db.getTargetCache().updateTargetData(t2, n);
  }
  updateLimboDocument(t2, e) {
    return Nr(t2, e);
  }
  kn(t2, e) {
    const n = Pr(t2);
    let s, i = nt.A;
    return n.Wt({
      index: "documentTargetsIndex"
    }, ([t3, n2], { path: r, sequenceNumber: o }) => {
      t3 === 0 ? (i !== nt.A && e(new xt(Ks(s)), i), i = o, s = r) : i = nt.A;
    }).next(() => {
      i !== nt.A && e(new xt(Ks(s)), i);
    });
  }
  getCacheSize(t2) {
    return this.db.getRemoteDocumentCache().getSize(t2);
  }
};
function Nr(t2, e) {
  return Pr(t2).put(function(t3, e2) {
    return {
      targetId: 0,
      path: Us(t3.path),
      sequenceNumber: e2
    };
  }(e, t2.currentSequenceNumber));
}
var kr = class {
  constructor() {
    this.changes = new kn((t2) => t2.toString(), (t2, e) => t2.isEqual(e)), this.changesApplied = false;
  }
  addEntry(t2) {
    this.assertNotApplied(), this.changes.set(t2.key, t2);
  }
  removeEntry(t2, e) {
    this.assertNotApplied(), this.changes.set(t2, te.newInvalidDocument(t2).setReadTime(e));
  }
  getEntry(t2, e) {
    this.assertNotApplied();
    const n = this.changes.get(e);
    return n !== void 0 ? wi.resolve(n) : this.getFromCache(t2, e);
  }
  getEntries(t2, e) {
    return this.getAllFromCache(t2, e);
  }
  apply(t2) {
    return this.assertNotApplied(), this.changesApplied = true, this.applyChanges(t2);
  }
  assertNotApplied() {
  }
};
var Mr = class {
  constructor(t2) {
    this.M = t2;
  }
  setIndexManager(t2) {
    this.indexManager = t2;
  }
  addEntry(t2, e, n) {
    return $r(t2).put(n);
  }
  removeEntry(t2, e, n) {
    return $r(t2).delete(function(t3, e2) {
      const n2 = t3.path.toArray();
      return [
        n2.slice(0, n2.length - 2),
        n2[n2.length - 2],
        ki(e2),
        n2[n2.length - 1]
      ];
    }(e, n));
  }
  updateMetadata(t2, e) {
    return this.getMetadata(t2).next((n) => (n.byteSize += e, this.On(t2, n)));
  }
  getEntry(t2, e) {
    let n = te.newInvalidDocument(e);
    return $r(t2).Wt({
      index: "documentKeyIndex",
      range: IDBKeyRange.only(Br(e))
    }, (t3, s) => {
      n = this.Fn(e, s);
    }).next(() => n);
  }
  $n(t2, e) {
    let n = {
      size: 0,
      document: te.newInvalidDocument(e)
    };
    return $r(t2).Wt({
      index: "documentKeyIndex",
      range: IDBKeyRange.only(Br(e))
    }, (t3, s) => {
      n = {
        document: this.Fn(e, s),
        size: mr(s)
      };
    }).next(() => n);
  }
  getEntries(t2, e) {
    let n = qn();
    return this.Bn(t2, e, (t3, e2) => {
      const s = this.Fn(t3, e2);
      n = n.insert(t3, s);
    }).next(() => n);
  }
  Ln(t2, e) {
    let n = qn(), s = new Mn(xt.comparator);
    return this.Bn(t2, e, (t3, e2) => {
      const i = this.Fn(t3, e2);
      n = n.insert(t3, i), s = s.insert(t3, mr(e2));
    }).next(() => ({
      documents: n,
      Un: s
    }));
  }
  Bn(t2, e, n) {
    if (e.isEmpty())
      return wi.resolve();
    let s = new $n(Ur);
    e.forEach((t3) => s = s.add(t3));
    const i = IDBKeyRange.bound(Br(s.first()), Br(s.last())), r = s.getIterator();
    let o = r.getNext();
    return $r(t2).Wt({
      index: "documentKeyIndex",
      range: i
    }, (t3, e2, s2) => {
      const i2 = xt.fromSegments([...e2.prefixPath, e2.collectionGroup, e2.documentId]);
      for (; o && Ur(o, i2) < 0; )
        n(o, null), o = r.getNext();
      o && o.isEqual(i2) && (n(o, e2), o = r.hasNext() ? r.getNext() : null), o ? s2.Ut(Br(o)) : s2.done();
    }).next(() => {
      for (; o; )
        n(o, null), o = r.hasNext() ? r.getNext() : null;
    });
  }
  getAllFromCollection(t2, e, n) {
    const s = [e.popLast().toArray(), e.lastSegment(), ki(n.readTime), n.documentKey.path.isEmpty() ? "" : n.documentKey.path.lastSegment()], i = [e.popLast().toArray(), e.lastSegment(), [Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER], ""];
    return $r(t2).qt(IDBKeyRange.bound(s, i, true)).next((t3) => {
      let e2 = qn();
      for (const n2 of t3) {
        const t4 = this.Fn(xt.fromSegments(n2.prefixPath.concat(n2.collectionGroup, n2.documentId)), n2);
        e2 = e2.insert(t4.key, t4);
      }
      return e2;
    });
  }
  getAllFromCollectionGroup(t2, e, n, s) {
    let i = qn();
    const r = Lr(e, n), o = Lr(e, ae.max());
    return $r(t2).Wt({
      index: "collectionGroupIndex",
      range: IDBKeyRange.bound(r, o, true)
    }, (t3, e2, n2) => {
      const r2 = this.Fn(xt.fromSegments(e2.prefixPath.concat(e2.collectionGroup, e2.documentId)), e2);
      i = i.insert(r2.key, r2), i.size === s && n2.done();
    }).next(() => i);
  }
  newChangeBuffer(t2) {
    return new Or(this, !!t2 && t2.trackRemovals);
  }
  getSize(t2) {
    return this.getMetadata(t2).next((t3) => t3.byteSize);
  }
  getMetadata(t2) {
    return Fr(t2).get("remoteDocumentGlobalKey").next((t3) => (U2(!!t3), t3));
  }
  On(t2, e) {
    return Fr(t2).put("remoteDocumentGlobalKey", e);
  }
  Fn(t2, e) {
    if (e) {
      const t3 = xi(this.M, e);
      if (!(t3.isNoDocument() && t3.version.isEqual(ct.min())))
        return t3;
    }
    return te.newInvalidDocument(t2);
  }
};
var Or = class extends kr {
  constructor(t2, e) {
    super(), this.qn = t2, this.trackRemovals = e, this.Gn = new kn((t3) => t3.toString(), (t3, e2) => t3.isEqual(e2));
  }
  applyChanges(t2) {
    const e = [];
    let n = 0, s = new $n((t3, e2) => rt(t3.canonicalString(), e2.canonicalString()));
    return this.changes.forEach((i, r) => {
      const o = this.Gn.get(i);
      if (e.push(this.qn.removeEntry(t2, i, o.readTime)), r.isValidDocument()) {
        const u = Ni(this.qn.M, r);
        s = s.add(i.path.popLast());
        const a = mr(u);
        n += a - o.size, e.push(this.qn.addEntry(t2, i, u));
      } else if (n -= o.size, this.trackRemovals) {
        const n2 = Ni(this.qn.M, r.convertToNoDocument(ct.min()));
        e.push(this.qn.addEntry(t2, i, n2));
      }
    }), s.forEach((n2) => {
      e.push(this.qn.indexManager.addToCollectionParentIndex(t2, n2));
    }), e.push(this.qn.updateMetadata(t2, n)), wi.waitFor(e);
  }
  getFromCache(t2, e) {
    return this.qn.$n(t2, e).next((t3) => (this.Gn.set(e, {
      size: t3.size,
      readTime: t3.document.readTime
    }), t3.document));
  }
  getAllFromCache(t2, e) {
    return this.qn.Ln(t2, e).next(({ documents: t3, Un: e2 }) => (e2.forEach((e3, n) => {
      this.Gn.set(e3, {
        size: n,
        readTime: t3.get(e3).readTime
      });
    }), t3));
  }
};
function Fr(t2) {
  return Pi(t2, "remoteDocumentGlobal");
}
function $r(t2) {
  return Pi(t2, "remoteDocumentsV14");
}
function Br(t2) {
  const e = t2.path.toArray();
  return [
    e.slice(0, e.length - 2),
    e[e.length - 2],
    e[e.length - 1]
  ];
}
function Lr(t2, e) {
  const n = e.documentKey.path.toArray();
  return [
    t2,
    ki(e.readTime),
    n.slice(0, n.length - 2),
    n.length > 0 ? n[n.length - 1] : ""
  ];
}
function Ur(t2, e) {
  const n = t2.path.length - e.path.length;
  return n !== 0 ? n : xt.comparator(t2, e);
}
var qr = class {
  constructor(t2) {
    this.M = t2;
  }
  kt(t2, e, n, s) {
    const i = new mi("createOrUpgrade", e);
    n < 1 && s >= 1 && (function(t3) {
      t3.createObjectStore("owner");
    }(t2), function(t3) {
      t3.createObjectStore("mutationQueues", {
        keyPath: "userId"
      });
      t3.createObjectStore("mutations", {
        keyPath: "batchId",
        autoIncrement: true
      }).createIndex("userMutationsIndex", Qs, {
        unique: true
      }), t3.createObjectStore("documentMutations");
    }(t2), Gr(t2), function(t3) {
      t3.createObjectStore("remoteDocuments");
    }(t2));
    let r = wi.resolve();
    return n < 3 && s >= 3 && (n !== 0 && (!function(t3) {
      t3.deleteObjectStore("targetDocuments"), t3.deleteObjectStore("targets"), t3.deleteObjectStore("targetGlobal");
    }(t2), Gr(t2)), r = r.next(() => function(t3) {
      const e2 = t3.store("targetGlobal"), n2 = {
        highestTargetId: 0,
        highestListenSequenceNumber: 0,
        lastRemoteSnapshotVersion: ct.min().toTimestamp(),
        targetCount: 0
      };
      return e2.put("targetGlobalKey", n2);
    }(i))), n < 4 && s >= 4 && (n !== 0 && (r = r.next(() => function(t3, e2) {
      return e2.store("mutations").qt().next((n2) => {
        t3.deleteObjectStore("mutations");
        t3.createObjectStore("mutations", {
          keyPath: "batchId",
          autoIncrement: true
        }).createIndex("userMutationsIndex", Qs, {
          unique: true
        });
        const s2 = e2.store("mutations"), i2 = n2.map((t4) => s2.put(t4));
        return wi.waitFor(i2);
      });
    }(t2, i))), r = r.next(() => {
      !function(t3) {
        t3.createObjectStore("clientMetadata", {
          keyPath: "clientId"
        });
      }(t2);
    })), n < 5 && s >= 5 && (r = r.next(() => this.Kn(i))), n < 6 && s >= 6 && (r = r.next(() => (function(t3) {
      t3.createObjectStore("remoteDocumentGlobal");
    }(t2), this.Qn(i)))), n < 7 && s >= 7 && (r = r.next(() => this.jn(i))), n < 8 && s >= 8 && (r = r.next(() => this.Wn(t2, i))), n < 9 && s >= 9 && (r = r.next(() => {
      !function(t3) {
        t3.objectStoreNames.contains("remoteDocumentChanges") && t3.deleteObjectStore("remoteDocumentChanges");
      }(t2);
    })), n < 10 && s >= 10 && (r = r.next(() => this.zn(i))), n < 11 && s >= 11 && (r = r.next(() => {
      !function(t3) {
        t3.createObjectStore("bundles", {
          keyPath: "bundleId"
        });
      }(t2), function(t3) {
        t3.createObjectStore("namedQueries", {
          keyPath: "name"
        });
      }(t2);
    })), n < 12 && s >= 12 && (r = r.next(() => {
      !function(t3) {
        const e2 = t3.createObjectStore("documentOverlays", {
          keyPath: oi
        });
        e2.createIndex("collectionPathOverlayIndex", ui, {
          unique: false
        }), e2.createIndex("collectionGroupOverlayIndex", ai, {
          unique: false
        });
      }(t2);
    })), n < 13 && s >= 13 && (r = r.next(() => function(t3) {
      const e2 = t3.createObjectStore("remoteDocumentsV14", {
        keyPath: Hs
      });
      e2.createIndex("documentKeyIndex", Js), e2.createIndex("collectionGroupIndex", Ys);
    }(t2)).next(() => this.Hn(t2, i)).next(() => t2.deleteObjectStore("remoteDocuments"))), n < 14 && s >= 14 && (r = r.next(() => {
      !function(t3) {
        t3.createObjectStore("indexConfiguration", {
          keyPath: "indexId",
          autoIncrement: true
        }).createIndex("collectionGroupIndex", "collectionGroup", {
          unique: false
        });
        t3.createObjectStore("indexState", {
          keyPath: ni
        }).createIndex("sequenceNumberIndex", si, {
          unique: false
        });
        t3.createObjectStore("indexEntries", {
          keyPath: ii
        }).createIndex("documentKeyIndex", ri, {
          unique: false
        });
      }(t2);
    })), r;
  }
  Qn(t2) {
    let e = 0;
    return t2.store("remoteDocuments").Wt((t3, n) => {
      e += mr(n);
    }).next(() => {
      const n = {
        byteSize: e
      };
      return t2.store("remoteDocumentGlobal").put("remoteDocumentGlobalKey", n);
    });
  }
  Kn(t2) {
    const e = t2.store("mutationQueues"), n = t2.store("mutations");
    return e.qt().next((e2) => wi.forEach(e2, (e3) => {
      const s = IDBKeyRange.bound([e3.userId, -1], [e3.userId, e3.lastAcknowledgedBatchId]);
      return n.qt("userMutationsIndex", s).next((n2) => wi.forEach(n2, (n3) => {
        U2(n3.userId === e3.userId);
        const s2 = Fi(this.M, n3);
        return wr(t2, e3.userId, s2).next(() => {
        });
      }));
    }));
  }
  jn(t2) {
    const e = t2.store("targetDocuments"), n = t2.store("remoteDocuments");
    return t2.store("targetGlobal").get("targetGlobalKey").next((t3) => {
      const s = [];
      return n.Wt((n2, i) => {
        const r = new _t(n2), o = function(t4) {
          return [0, Us(t4)];
        }(r);
        s.push(e.get(o).next((n3) => n3 ? wi.resolve() : ((n4) => e.put({
          targetId: 0,
          path: Us(n4),
          sequenceNumber: t3.highestListenSequenceNumber
        }))(r)));
      }).next(() => wi.waitFor(s));
    });
  }
  Wn(t2, e) {
    t2.createObjectStore("collectionParents", {
      keyPath: ei
    });
    const n = e.store("collectionParents"), s = new or(), i = (t3) => {
      if (s.add(t3)) {
        const e2 = t3.lastSegment(), s2 = t3.popLast();
        return n.put({
          collectionId: e2,
          parent: Us(s2)
        });
      }
    };
    return e.store("remoteDocuments").Wt({
      jt: true
    }, (t3, e2) => {
      const n2 = new _t(t3);
      return i(n2.popLast());
    }).next(() => e.store("documentMutations").Wt({
      jt: true
    }, ([t3, e2, n2], s2) => {
      const r = Ks(e2);
      return i(r.popLast());
    }));
  }
  zn(t2) {
    const e = t2.store("targets");
    return e.Wt((t3, n) => {
      const s = $i(n), i = Bi(this.M, s);
      return e.put(i);
    });
  }
  Hn(t2, e) {
    const n = e.store("remoteDocuments"), s = [];
    return n.Wt((t3, n2) => {
      const i = e.store("remoteDocumentsV14"), r = (o = n2, o.document ? new xt(_t.fromString(o.document.name).popFirst(5)) : o.noDocument ? xt.fromSegments(o.noDocument.path) : o.unknownDocument ? xt.fromSegments(o.unknownDocument.path) : L2()).path.toArray();
      var o;
      const u = {
        prefixPath: r.slice(0, r.length - 2),
        collectionGroup: r[r.length - 2],
        documentId: r[r.length - 1],
        readTime: n2.readTime || [0, 0],
        unknownDocument: n2.unknownDocument,
        noDocument: n2.noDocument,
        document: n2.document,
        hasCommittedMutations: !!n2.hasCommittedMutations
      };
      s.push(i.put(u));
    }).next(() => wi.waitFor(s));
  }
};
function Gr(t2) {
  t2.createObjectStore("targetDocuments", {
    keyPath: Zs
  }).createIndex("documentTargetsIndex", ti, {
    unique: true
  });
  t2.createObjectStore("targets", {
    keyPath: "targetId"
  }).createIndex("queryTargetsIndex", Xs, {
    unique: true
  }), t2.createObjectStore("targetGlobal");
}
var Kr = "Failed to obtain exclusive access to the persistence layer. To allow shared access, multi-tab synchronization has to be enabled in all tabs. If you are using `experimentalForceOwningTab:true`, make sure that only one tab has persistence enabled at any given time.";
var Qr = class {
  constructor(t2, e, n, s, i, r, o, u, a, c, h = 13) {
    if (this.allowTabSynchronization = t2, this.persistenceKey = e, this.clientId = n, this.Jn = i, this.window = r, this.document = o, this.Yn = a, this.Xn = c, this.Zn = h, this.ts = null, this.es = false, this.isPrimary = false, this.networkEnabled = true, this.ns = null, this.inForeground = false, this.ss = null, this.rs = null, this.os = Number.NEGATIVE_INFINITY, this.us = (t3) => Promise.resolve(), !Qr.vt())
      throw new Q2(K2.UNIMPLEMENTED, "This platform is either missing IndexedDB or is known to have an incomplete implementation. Offline persistence has been disabled.");
    this.referenceDelegate = new xr(this, s), this.cs = e + "main", this.M = new Ci(u), this.hs = new gi(this.cs, this.Zn, new qr(this.M)), this.ls = new Ar(this.referenceDelegate, this.M), this.fs = function(t3) {
      return new Mr(t3);
    }(this.M), this.ds = new Gi(), this.window && this.window.localStorage ? this._s = this.window.localStorage : (this._s = null, c === false && F2("IndexedDbPersistence", "LocalStorage is unavailable. As a result, persistence may not work reliably. In particular enablePersistence() could fail immediately after refreshing the page."));
  }
  start() {
    return this.ws().then(() => {
      if (!this.isPrimary && !this.allowTabSynchronization)
        throw new Q2(K2.FAILED_PRECONDITION, Kr);
      return this.gs(), this.ys(), this.ps(), this.runTransaction("getHighestListenSequenceNumber", "readonly", (t2) => this.ls.getHighestSequenceNumber(t2));
    }).then((t2) => {
      this.ts = new nt(t2, this.Yn);
    }).then(() => {
      this.es = true;
    }).catch((t2) => (this.hs && this.hs.close(), Promise.reject(t2)));
  }
  Is(t2) {
    return this.us = async (e) => {
      if (this.started)
        return t2(e);
    }, t2(this.isPrimary);
  }
  setDatabaseDeletedListener(t2) {
    this.hs.Ot(async (e) => {
      e.newVersion === null && await t2();
    });
  }
  setNetworkEnabled(t2) {
    this.networkEnabled !== t2 && (this.networkEnabled = t2, this.Jn.enqueueAndForget(async () => {
      this.started && await this.ws();
    }));
  }
  ws() {
    return this.runTransaction("updateClientMetadataAndTryBecomePrimary", "readwrite", (t2) => Wr(t2).put({
      clientId: this.clientId,
      updateTimeMs: Date.now(),
      networkEnabled: this.networkEnabled,
      inForeground: this.inForeground
    }).next(() => {
      if (this.isPrimary)
        return this.Ts(t2).next((t3) => {
          t3 || (this.isPrimary = false, this.Jn.enqueueRetryable(() => this.us(false)));
        });
    }).next(() => this.Es(t2)).next((e) => this.isPrimary && !e ? this.As(t2).next(() => false) : !!e && this.Rs(t2).next(() => true))).catch((t2) => {
      if (Ii(t2))
        return O2("IndexedDbPersistence", "Failed to extend owner lease: ", t2), this.isPrimary;
      if (!this.allowTabSynchronization)
        throw t2;
      return O2("IndexedDbPersistence", "Releasing owner lease after error during lease refresh", t2), false;
    }).then((t2) => {
      this.isPrimary !== t2 && this.Jn.enqueueRetryable(() => this.us(t2)), this.isPrimary = t2;
    });
  }
  Ts(t2) {
    return jr(t2).get("owner").next((t3) => wi.resolve(this.bs(t3)));
  }
  Ps(t2) {
    return Wr(t2).delete(this.clientId);
  }
  async Vs() {
    if (this.isPrimary && !this.vs(this.os, 18e5)) {
      this.os = Date.now();
      const t2 = await this.runTransaction("maybeGarbageCollectMultiClientState", "readwrite-primary", (t3) => {
        const e = Pi(t3, "clientMetadata");
        return e.qt().next((t4) => {
          const n = this.Ss(t4, 18e5), s = t4.filter((t5) => n.indexOf(t5) === -1);
          return wi.forEach(s, (t5) => e.delete(t5.clientId)).next(() => s);
        });
      }).catch(() => []);
      if (this._s)
        for (const e of t2)
          this._s.removeItem(this.Ds(e.clientId));
    }
  }
  ps() {
    this.rs = this.Jn.enqueueAfterDelay("client_metadata_refresh", 4e3, () => this.ws().then(() => this.Vs()).then(() => this.ps()));
  }
  bs(t2) {
    return !!t2 && t2.ownerId === this.clientId;
  }
  Es(t2) {
    if (this.Xn)
      return wi.resolve(true);
    return jr(t2).get("owner").next((e) => {
      if (e !== null && this.vs(e.leaseTimestampMs, 5e3) && !this.Cs(e.ownerId)) {
        if (this.bs(e) && this.networkEnabled)
          return true;
        if (!this.bs(e)) {
          if (!e.allowTabSynchronization)
            throw new Q2(K2.FAILED_PRECONDITION, Kr);
          return false;
        }
      }
      return !(!this.networkEnabled || !this.inForeground) || Wr(t2).qt().next((t3) => this.Ss(t3, 5e3).find((t4) => {
        if (this.clientId !== t4.clientId) {
          const e2 = !this.networkEnabled && t4.networkEnabled, n = !this.inForeground && t4.inForeground, s = this.networkEnabled === t4.networkEnabled;
          if (e2 || n && s)
            return true;
        }
        return false;
      }) === void 0);
    }).next((t3) => (this.isPrimary !== t3 && O2("IndexedDbPersistence", `Client ${t3 ? "is" : "is not"} eligible for a primary lease.`), t3));
  }
  async shutdown() {
    this.es = false, this.xs(), this.rs && (this.rs.cancel(), this.rs = null), this.Ns(), this.ks(), await this.hs.runTransaction("shutdown", "readwrite", ["owner", "clientMetadata"], (t2) => {
      const e = new bi(t2, nt.A);
      return this.As(e).next(() => this.Ps(e));
    }), this.hs.close(), this.Ms();
  }
  Ss(t2, e) {
    return t2.filter((t3) => this.vs(t3.updateTimeMs, e) && !this.Cs(t3.clientId));
  }
  Os() {
    return this.runTransaction("getActiveClients", "readonly", (t2) => Wr(t2).qt().next((t3) => this.Ss(t3, 18e5).map((t4) => t4.clientId)));
  }
  get started() {
    return this.es;
  }
  getMutationQueue(t2, e) {
    return gr.Yt(t2, this.M, e, this.referenceDelegate);
  }
  getTargetCache() {
    return this.ls;
  }
  getRemoteDocumentCache() {
    return this.fs;
  }
  getIndexManager(t2) {
    return new ar(t2);
  }
  getDocumentOverlayCache(t2) {
    return ji.Yt(this.M, t2);
  }
  getBundleCache() {
    return this.ds;
  }
  runTransaction(t2, e, n) {
    O2("IndexedDbPersistence", "Starting transaction:", t2);
    const s = e === "readonly" ? "readonly" : "readwrite", i = (r = this.Zn) === 14 ? fi : r === 13 ? li : r === 12 ? hi : r === 11 ? ci : void L2();
    var r;
    let o;
    return this.hs.runTransaction(t2, s, i, (s2) => (o = new bi(s2, this.ts ? this.ts.next() : nt.A), e === "readwrite-primary" ? this.Ts(o).next((t3) => !!t3 || this.Es(o)).next((e2) => {
      if (!e2)
        throw F2(`Failed to obtain primary lease for action '${t2}'.`), this.isPrimary = false, this.Jn.enqueueRetryable(() => this.us(false)), new Q2(K2.FAILED_PRECONDITION, di);
      return n(o);
    }).next((t3) => this.Rs(o).next(() => t3)) : this.Fs(o).next(() => n(o)))).then((t3) => (o.raiseOnCommittedEvent(), t3));
  }
  Fs(t2) {
    return jr(t2).get("owner").next((t3) => {
      if (t3 !== null && this.vs(t3.leaseTimestampMs, 5e3) && !this.Cs(t3.ownerId) && !this.bs(t3) && !(this.Xn || this.allowTabSynchronization && t3.allowTabSynchronization))
        throw new Q2(K2.FAILED_PRECONDITION, Kr);
    });
  }
  Rs(t2) {
    const e = {
      ownerId: this.clientId,
      allowTabSynchronization: this.allowTabSynchronization,
      leaseTimestampMs: Date.now()
    };
    return jr(t2).put("owner", e);
  }
  static vt() {
    return gi.vt();
  }
  As(t2) {
    const e = jr(t2);
    return e.get("owner").next((t3) => this.bs(t3) ? (O2("IndexedDbPersistence", "Releasing primary lease."), e.delete("owner")) : wi.resolve());
  }
  vs(t2, e) {
    const n = Date.now();
    return !(t2 < n - e) && (!(t2 > n) || (F2(`Detected an update time that is in the future: ${t2} > ${n}`), false));
  }
  gs() {
    this.document !== null && typeof this.document.addEventListener == "function" && (this.ss = () => {
      this.Jn.enqueueAndForget(() => (this.inForeground = this.document.visibilityState === "visible", this.ws()));
    }, this.document.addEventListener("visibilitychange", this.ss), this.inForeground = this.document.visibilityState === "visible");
  }
  Ns() {
    this.ss && (this.document.removeEventListener("visibilitychange", this.ss), this.ss = null);
  }
  ys() {
    var t2;
    typeof ((t2 = this.window) === null || t2 === void 0 ? void 0 : t2.addEventListener) == "function" && (this.ns = () => {
      this.xs(), isSafari() && navigator.appVersion.match(/Version\/1[45]/) && this.Jn.enterRestrictedMode(true), this.Jn.enqueueAndForget(() => this.shutdown());
    }, this.window.addEventListener("pagehide", this.ns));
  }
  ks() {
    this.ns && (this.window.removeEventListener("pagehide", this.ns), this.ns = null);
  }
  Cs(t2) {
    var e;
    try {
      const n = ((e = this._s) === null || e === void 0 ? void 0 : e.getItem(this.Ds(t2))) !== null;
      return O2("IndexedDbPersistence", `Client '${t2}' ${n ? "is" : "is not"} zombied in LocalStorage`), n;
    } catch (t3) {
      return F2("IndexedDbPersistence", "Failed to get zombied client id.", t3), false;
    }
  }
  xs() {
    if (this._s)
      try {
        this._s.setItem(this.Ds(this.clientId), String(Date.now()));
      } catch (t2) {
        F2("Failed to set zombie client id.", t2);
      }
  }
  Ms() {
    if (this._s)
      try {
        this._s.removeItem(this.Ds(this.clientId));
      } catch (t2) {
      }
  }
  Ds(t2) {
    return `firestore_zombie_${this.persistenceKey}_${t2}`;
  }
};
function jr(t2) {
  return Pi(t2, "owner");
}
function Wr(t2) {
  return Pi(t2, "clientMetadata");
}
function zr(t2, e) {
  let n = t2.projectId;
  return t2.isDefaultDatabase || (n += "." + t2.database), "firestore/" + e + "/" + n + "/";
}
var Hr = class {
  constructor(t2, e, n) {
    this.fs = t2, this.$s = e, this.indexManager = n;
  }
  Bs(t2, e) {
    return this.$s.getAllMutationBatchesAffectingDocumentKey(t2, e).next((n) => this.Ls(t2, e, n));
  }
  Ls(t2, e, n) {
    return this.fs.getEntry(t2, e).next((t3) => {
      for (const e2 of n)
        e2.applyToLocalView(t3);
      return t3;
    });
  }
  Us(t2, e) {
    t2.forEach((t3, n) => {
      for (const t4 of e)
        t4.applyToLocalView(n);
    });
  }
  qs(t2, e) {
    return this.fs.getEntries(t2, e).next((e2) => this.Gs(t2, e2).next(() => e2));
  }
  Gs(t2, e) {
    return this.$s.getAllMutationBatchesAffectingDocumentKeys(t2, e).next((t3) => this.Us(e, t3));
  }
  Ks(t2, e, n) {
    return function(t3) {
      return xt.isDocumentKey(t3.path) && t3.collectionGroup === null && t3.filters.length === 0;
    }(e) ? this.Qs(t2, e.path) : $e(e) ? this.js(t2, e, n) : this.Ws(t2, e, n);
  }
  Qs(t2, e) {
    return this.Bs(t2, new xt(e)).next((t3) => {
      let e2 = Kn();
      return t3.isFoundDocument() && (e2 = e2.insert(t3.key, t3)), e2;
    });
  }
  js(t2, e, n) {
    const s = e.collectionGroup;
    let i = Kn();
    return this.indexManager.getCollectionParents(t2, s).next((r) => wi.forEach(r, (r2) => {
      const o = function(t3, e2) {
        return new Ce(e2, null, t3.explicitOrderBy.slice(), t3.filters.slice(), t3.limit, t3.limitType, t3.startAt, t3.endAt);
      }(e, r2.child(s));
      return this.Ws(t2, o, n).next((t3) => {
        t3.forEach((t4, e2) => {
          i = i.insert(t4, e2);
        });
      });
    }).next(() => i));
  }
  Ws(t2, e, n) {
    let s;
    return this.fs.getAllFromCollection(t2, e.path, n).next((n2) => (s = n2, this.$s.getAllMutationBatchesAffectingQuery(t2, e))).next((t3) => {
      for (const e2 of t3)
        for (const t4 of e2.mutations) {
          const n2 = t4.key;
          let i = s.get(n2);
          i == null && (i = te.newInvalidDocument(n2), s = s.insert(n2, i)), yn(t4, i, e2.localWriteTime), i.isFoundDocument() || (s = s.remove(n2));
        }
    }).next(() => (s.forEach((t3, n2) => {
      Qe(e, n2) || (s = s.remove(t3));
    }), s));
  }
};
var Jr = class {
  constructor(t2, e, n, s) {
    this.targetId = t2, this.fromCache = e, this.zs = n, this.Hs = s;
  }
  static Js(t2, e) {
    let n = zn(), s = zn();
    for (const t3 of e.docChanges)
      switch (t3.type) {
        case 0:
          n = n.add(t3.doc.key);
          break;
        case 1:
          s = s.add(t3.doc.key);
      }
    return new Jr(t2, e.fromCache, n, s);
  }
};
var Yr = class {
  Ys(t2) {
    this.Xs = t2;
  }
  Ks(t2, e, n, s) {
    return function(t3) {
      return t3.filters.length === 0 && t3.limit === null && t3.startAt == null && t3.endAt == null && (t3.explicitOrderBy.length === 0 || t3.explicitOrderBy.length === 1 && t3.explicitOrderBy[0].field.isKeyField());
    }(e) || n.isEqual(ct.min()) ? this.Zs(t2, e) : this.Xs.qs(t2, s).next((i) => {
      const r = this.ti(e, i);
      return (ke(e) || Me(e)) && this.ei(e.limitType, r, s, n) ? this.Zs(t2, e) : (k2() <= LogLevel.DEBUG && O2("QueryEngine", "Re-using previous result from %s to execute query: %s", n.toString(), Ke(e)), this.Xs.Ks(t2, e, oe(n, -1)).next((t3) => (r.forEach((e2) => {
        t3 = t3.insert(e2.key, e2);
      }), t3)));
    });
  }
  ti(t2, e) {
    let n = new $n(We(t2));
    return e.forEach((e2, s) => {
      Qe(t2, s) && (n = n.add(s));
    }), n;
  }
  ei(t2, e, n, s) {
    if (n.size !== e.size)
      return true;
    const i = t2 === "F" ? e.last() : e.first();
    return !!i && (i.hasPendingWrites || i.version.compareTo(s) > 0);
  }
  Zs(t2, e) {
    return k2() <= LogLevel.DEBUG && O2("QueryEngine", "Using full collection scan to execute query:", Ke(e)), this.Xs.Ks(t2, e, ae.min());
  }
};
var Xr = class {
  constructor(t2, e, n, s) {
    this.persistence = t2, this.ni = e, this.M = s, this.si = new Mn(rt), this.ii = new kn((t3) => fe(t3), _e), this.ri = /* @__PURE__ */ new Map(), this.oi = t2.getRemoteDocumentCache(), this.ls = t2.getTargetCache(), this.ds = t2.getBundleCache(), this.ui(n);
  }
  ui(t2) {
    this.indexManager = this.persistence.getIndexManager(t2), this.$s = this.persistence.getMutationQueue(t2, this.indexManager), this.ai = new Hr(this.oi, this.$s, this.indexManager), this.oi.setIndexManager(this.indexManager), this.ni.Ys(this.ai);
  }
  collectGarbage(t2) {
    return this.persistence.runTransaction("Collect garbage", "readwrite-primary", (e) => t2.collect(e, this.si));
  }
};
function Zr(t2, e, n, s) {
  return new Xr(t2, e, n, s);
}
async function to(t2, e) {
  const n = G(t2);
  return await n.persistence.runTransaction("Handle user change", "readonly", (t3) => {
    let s;
    return n.$s.getAllMutationBatches(t3).next((i) => (s = i, n.ui(e), n.$s.getAllMutationBatches(t3))).next((e2) => {
      const i = [], r = [];
      let o = zn();
      for (const t4 of s) {
        i.push(t4.batchId);
        for (const e3 of t4.mutations)
          o = o.add(e3.key);
      }
      for (const t4 of e2) {
        r.push(t4.batchId);
        for (const e3 of t4.mutations)
          o = o.add(e3.key);
      }
      return n.ai.qs(t3, o).next((t4) => ({
        ci: t4,
        removedBatchIds: i,
        addedBatchIds: r
      }));
    });
  });
}
function eo(t2, e) {
  const n = G(t2);
  return n.persistence.runTransaction("Acknowledge batch", "readwrite-primary", (t3) => {
    const s = e.batch.keys(), i = n.oi.newChangeBuffer({
      trackRemovals: true
    });
    return function(t4, e2, n2, s2) {
      const i2 = n2.batch, r = i2.keys();
      let o = wi.resolve();
      return r.forEach((t5) => {
        o = o.next(() => s2.getEntry(e2, t5)).next((e3) => {
          const r2 = n2.docVersions.get(t5);
          U2(r2 !== null), e3.version.compareTo(r2) < 0 && (i2.applyToRemoteDocument(e3, n2), e3.isValidDocument() && (e3.setReadTime(n2.commitVersion), s2.addEntry(e3)));
        });
      }), o.next(() => t4.$s.removeMutationBatch(e2, i2));
    }(n, t3, e, i).next(() => i.apply(t3)).next(() => n.$s.performConsistencyCheck(t3)).next(() => n.ai.qs(t3, s));
  });
}
function no(t2) {
  const e = G(t2);
  return e.persistence.runTransaction("Get last remote snapshot version", "readonly", (t3) => e.ls.getLastRemoteSnapshotVersion(t3));
}
function so(t2, e) {
  const n = G(t2), s = e.snapshotVersion;
  let i = n.si;
  return n.persistence.runTransaction("Apply remote event", "readwrite-primary", (t3) => {
    const r = n.oi.newChangeBuffer({
      trackRemovals: true
    });
    i = n.si;
    const o = [];
    e.targetChanges.forEach((r2, u2) => {
      const a = i.get(u2);
      if (!a)
        return;
      o.push(n.ls.removeMatchingKeys(t3, r2.removedDocuments, u2).next(() => n.ls.addMatchingKeys(t3, r2.addedDocuments, u2)));
      let c = a.withSequenceNumber(t3.currentSequenceNumber);
      e.targetMismatches.has(u2) ? c = c.withResumeToken(pt.EMPTY_BYTE_STRING, ct.min()).withLastLimboFreeSnapshotVersion(ct.min()) : r2.resumeToken.approximateByteSize() > 0 && (c = c.withResumeToken(r2.resumeToken, s)), i = i.insert(u2, c), function(t4, e2, n2) {
        if (t4.resumeToken.approximateByteSize() === 0)
          return true;
        if (e2.snapshotVersion.toMicroseconds() - t4.snapshotVersion.toMicroseconds() >= 3e8)
          return true;
        return n2.addedDocuments.size + n2.modifiedDocuments.size + n2.removedDocuments.size > 0;
      }(a, c, r2) && o.push(n.ls.updateTargetData(t3, c));
    });
    let u = qn();
    if (e.documentUpdates.forEach((s2) => {
      e.resolvedLimboDocuments.has(s2) && o.push(n.persistence.referenceDelegate.updateLimboDocument(t3, s2));
    }), o.push(io(t3, r, e.documentUpdates).next((t4) => {
      u = t4;
    })), !s.isEqual(ct.min())) {
      const e2 = n.ls.getLastRemoteSnapshotVersion(t3).next((e3) => n.ls.setTargetsMetadata(t3, t3.currentSequenceNumber, s));
      o.push(e2);
    }
    return wi.waitFor(o).next(() => r.apply(t3)).next(() => n.ai.Gs(t3, u)).next(() => u);
  }).then((t3) => (n.si = i, t3));
}
function io(t2, e, n) {
  let s = zn();
  return n.forEach((t3) => s = s.add(t3)), e.getEntries(t2, s).next((t3) => {
    let s2 = qn();
    return n.forEach((n2, i) => {
      const r = t3.get(n2);
      i.isNoDocument() && i.version.isEqual(ct.min()) ? (e.removeEntry(n2, i.readTime), s2 = s2.insert(n2, i)) : !r.isValidDocument() || i.version.compareTo(r.version) > 0 || i.version.compareTo(r.version) === 0 && r.hasPendingWrites ? (e.addEntry(i), s2 = s2.insert(n2, i)) : O2("LocalStore", "Ignoring outdated watch update for ", n2, ". Current version:", r.version, " Watch version:", i.version);
    }), s2;
  });
}
function ro(t2, e) {
  const n = G(t2);
  return n.persistence.runTransaction("Get next mutation batch", "readonly", (t3) => (e === void 0 && (e = -1), n.$s.getNextMutationBatchAfterBatchId(t3, e)));
}
function oo(t2, e) {
  const n = G(t2);
  return n.persistence.runTransaction("Allocate target", "readwrite", (t3) => {
    let s;
    return n.ls.getTargetData(t3, e).next((i) => i ? (s = i, wi.resolve(s)) : n.ls.allocateTargetId(t3).next((i2) => (s = new Di(e, i2, 0, t3.currentSequenceNumber), n.ls.addTargetData(t3, s).next(() => s))));
  }).then((t3) => {
    const s = n.si.get(t3.targetId);
    return (s === null || t3.snapshotVersion.compareTo(s.snapshotVersion) > 0) && (n.si = n.si.insert(t3.targetId, t3), n.ii.set(e, t3.targetId)), t3;
  });
}
async function uo(t2, e, n) {
  const s = G(t2), i = s.si.get(e), r = n ? "readwrite" : "readwrite-primary";
  try {
    n || await s.persistence.runTransaction("Release target", r, (t3) => s.persistence.referenceDelegate.removeTarget(t3, i));
  } catch (t3) {
    if (!Ii(t3))
      throw t3;
    O2("LocalStore", `Failed to update sequence numbers for target ${e}: ${t3}`);
  }
  s.si = s.si.remove(e), s.ii.delete(i.target);
}
function ao(t2, e, n) {
  const s = G(t2);
  let i = ct.min(), r = zn();
  return s.persistence.runTransaction("Execute query", "readonly", (t3) => function(t4, e2, n2) {
    const s2 = G(t4), i2 = s2.ii.get(n2);
    return i2 !== void 0 ? wi.resolve(s2.si.get(i2)) : s2.ls.getTargetData(e2, n2);
  }(s, t3, Le(e)).next((e2) => {
    if (e2)
      return i = e2.lastLimboFreeSnapshotVersion, s.ls.getMatchingKeysForTargetId(t3, e2.targetId).next((t4) => {
        r = t4;
      });
  }).next(() => s.ni.Ks(t3, e, n ? i : ct.min(), n ? r : zn())).next((t4) => (lo(s, je(e), t4), {
    documents: t4,
    hi: r
  })));
}
function co(t2, e) {
  const n = G(t2), s = G(n.ls), i = n.si.get(e);
  return i ? Promise.resolve(i.target) : n.persistence.runTransaction("Get target data", "readonly", (t3) => s.Et(t3, e).next((t4) => t4 ? t4.target : null));
}
function ho(t2, e) {
  const n = G(t2), s = n.ri.get(e) || ct.min();
  return n.persistence.runTransaction("Get new document changes", "readonly", (t3) => n.oi.getAllFromCollectionGroup(t3, e, oe(s, -1), Number.MAX_SAFE_INTEGER)).then((t3) => (lo(n, e, t3), t3));
}
function lo(t2, e, n) {
  let s = ct.min();
  n.forEach((t3, e2) => {
    e2.readTime.compareTo(s) > 0 && (s = e2.readTime);
  }), t2.ri.set(e, s);
}
async function fo(t2, e, n, s) {
  const i = G(t2);
  let r = zn(), o = qn();
  for (const t3 of n) {
    const n2 = e.li(t3.metadata.name);
    t3.document && (r = r.add(n2));
    const s2 = e.fi(t3);
    s2.setReadTime(e.di(t3.metadata.readTime)), o = o.insert(n2, s2);
  }
  const u = i.oi.newChangeBuffer({
    trackRemovals: true
  }), a = await oo(i, function(t3) {
    return Le(Ne(_t.fromString(`__bundle__/docs/${t3}`)));
  }(s));
  return i.persistence.runTransaction("Apply bundle documents", "readwrite", (t3) => io(t3, u, o).next((e2) => (u.apply(t3), e2)).next((e2) => i.ls.removeMatchingKeysForTargetId(t3, a.targetId).next(() => i.ls.addMatchingKeys(t3, r, a.targetId)).next(() => i.ai.Gs(t3, e2)).next(() => e2)));
}
async function _o(t2, e, n = zn()) {
  const s = await oo(t2, Le(Li(e.bundledQuery))), i = G(t2);
  return i.persistence.runTransaction("Save named query", "readwrite", (t3) => {
    const r = fs(e.readTime);
    if (s.snapshotVersion.compareTo(r) >= 0)
      return i.ds.saveNamedQuery(t3, e);
    const o = s.withResumeToken(pt.EMPTY_BYTE_STRING, r);
    return i.si = i.si.insert(o.targetId, o), i.ls.updateTargetData(t3, o).next(() => i.ls.removeMatchingKeysForTargetId(t3, s.targetId)).next(() => i.ls.addMatchingKeys(t3, n, s.targetId)).next(() => i.ds.saveNamedQuery(t3, e));
  });
}
var wo = class {
  constructor(t2) {
    this.M = t2, this._i = /* @__PURE__ */ new Map(), this.wi = /* @__PURE__ */ new Map();
  }
  getBundleMetadata(t2, e) {
    return wi.resolve(this._i.get(e));
  }
  saveBundleMetadata(t2, e) {
    var n;
    return this._i.set(e.id, {
      id: (n = e).id,
      version: n.version,
      createTime: fs(n.createTime)
    }), wi.resolve();
  }
  getNamedQuery(t2, e) {
    return wi.resolve(this.wi.get(e));
  }
  saveNamedQuery(t2, e) {
    return this.wi.set(e.name, function(t3) {
      return {
        name: t3.name,
        query: Li(t3.bundledQuery),
        readTime: fs(t3.readTime)
      };
    }(e)), wi.resolve();
  }
};
var mo = class {
  constructor() {
    this.overlays = new Mn(xt.comparator), this.mi = /* @__PURE__ */ new Map();
  }
  getOverlay(t2, e) {
    return wi.resolve(this.overlays.get(e));
  }
  saveOverlays(t2, e, n) {
    return n.forEach((n2, s) => {
      this.Xt(t2, e, s);
    }), wi.resolve();
  }
  removeOverlaysForBatchId(t2, e, n) {
    const s = this.mi.get(n);
    return s !== void 0 && (s.forEach((t3) => this.overlays = this.overlays.remove(t3)), this.mi.delete(n)), wi.resolve();
  }
  getOverlaysForCollection(t2, e, n) {
    const s = Qn(), i = e.length + 1, r = new xt(e.child("")), o = this.overlays.getIteratorFrom(r);
    for (; o.hasNext(); ) {
      const t3 = o.getNext().value, r2 = t3.getKey();
      if (!e.isPrefixOf(r2.path))
        break;
      r2.path.length === i && (t3.largestBatchId > n && s.set(t3.getKey(), t3));
    }
    return wi.resolve(s);
  }
  getOverlaysForCollectionGroup(t2, e, n, s) {
    let i = new Mn((t3, e2) => t3 - e2);
    const r = this.overlays.getIterator();
    for (; r.hasNext(); ) {
      const t3 = r.getNext().value;
      if (t3.getKey().getCollectionGroup() === e && t3.largestBatchId > n) {
        let e2 = i.get(t3.largestBatchId);
        e2 === null && (e2 = Qn(), i = i.insert(t3.largestBatchId, e2)), e2.set(t3.getKey(), t3);
      }
    }
    const o = Qn(), u = i.getIterator();
    for (; u.hasNext(); ) {
      if (u.getNext().value.forEach((t3, e2) => o.set(t3, e2)), o.size() >= s)
        break;
    }
    return wi.resolve(o);
  }
  Xt(t2, e, n) {
    if (n === null)
      return;
    const s = this.overlays.get(n.key);
    if (s !== null) {
      const t3 = this.mi.get(s.largestBatchId).delete(n.key);
      this.mi.set(s.largestBatchId, t3);
    }
    this.overlays = this.overlays.insert(n.key, new Si(e, n));
    let i = this.mi.get(e);
    i === void 0 && (i = zn(), this.mi.set(e, i)), this.mi.set(e, i.add(n.key));
  }
};
var go = class {
  constructor() {
    this.gi = new $n(yo.yi), this.pi = new $n(yo.Ii);
  }
  isEmpty() {
    return this.gi.isEmpty();
  }
  addReference(t2, e) {
    const n = new yo(t2, e);
    this.gi = this.gi.add(n), this.pi = this.pi.add(n);
  }
  Ti(t2, e) {
    t2.forEach((t3) => this.addReference(t3, e));
  }
  removeReference(t2, e) {
    this.Ei(new yo(t2, e));
  }
  Ai(t2, e) {
    t2.forEach((t3) => this.removeReference(t3, e));
  }
  Ri(t2) {
    const e = new xt(new _t([])), n = new yo(e, t2), s = new yo(e, t2 + 1), i = [];
    return this.pi.forEachInRange([n, s], (t3) => {
      this.Ei(t3), i.push(t3.key);
    }), i;
  }
  bi() {
    this.gi.forEach((t2) => this.Ei(t2));
  }
  Ei(t2) {
    this.gi = this.gi.delete(t2), this.pi = this.pi.delete(t2);
  }
  Pi(t2) {
    const e = new xt(new _t([])), n = new yo(e, t2), s = new yo(e, t2 + 1);
    let i = zn();
    return this.pi.forEachInRange([n, s], (t3) => {
      i = i.add(t3.key);
    }), i;
  }
  containsKey(t2) {
    const e = new yo(t2, 0), n = this.gi.firstAfterOrEqual(e);
    return n !== null && t2.isEqual(n.key);
  }
};
var yo = class {
  constructor(t2, e) {
    this.key = t2, this.Vi = e;
  }
  static yi(t2, e) {
    return xt.comparator(t2.key, e.key) || rt(t2.Vi, e.Vi);
  }
  static Ii(t2, e) {
    return rt(t2.Vi, e.Vi) || xt.comparator(t2.key, e.key);
  }
};
var po = class {
  constructor(t2, e) {
    this.indexManager = t2, this.referenceDelegate = e, this.$s = [], this.vi = 1, this.Si = new $n(yo.yi);
  }
  checkEmpty(t2) {
    return wi.resolve(this.$s.length === 0);
  }
  addMutationBatch(t2, e, n, s) {
    const i = this.vi;
    this.vi++, this.$s.length > 0 && this.$s[this.$s.length - 1];
    const r = new Vi(i, e, n, s);
    this.$s.push(r);
    for (const e2 of s)
      this.Si = this.Si.add(new yo(e2.key, i)), this.indexManager.addToCollectionParentIndex(t2, e2.key.path.popLast());
    return wi.resolve(r);
  }
  lookupMutationBatch(t2, e) {
    return wi.resolve(this.Di(e));
  }
  getNextMutationBatchAfterBatchId(t2, e) {
    const n = e + 1, s = this.Ci(n), i = s < 0 ? 0 : s;
    return wi.resolve(this.$s.length > i ? this.$s[i] : null);
  }
  getHighestUnacknowledgedBatchId() {
    return wi.resolve(this.$s.length === 0 ? -1 : this.vi - 1);
  }
  getAllMutationBatches(t2) {
    return wi.resolve(this.$s.slice());
  }
  getAllMutationBatchesAffectingDocumentKey(t2, e) {
    const n = new yo(e, 0), s = new yo(e, Number.POSITIVE_INFINITY), i = [];
    return this.Si.forEachInRange([n, s], (t3) => {
      const e2 = this.Di(t3.Vi);
      i.push(e2);
    }), wi.resolve(i);
  }
  getAllMutationBatchesAffectingDocumentKeys(t2, e) {
    let n = new $n(rt);
    return e.forEach((t3) => {
      const e2 = new yo(t3, 0), s = new yo(t3, Number.POSITIVE_INFINITY);
      this.Si.forEachInRange([e2, s], (t4) => {
        n = n.add(t4.Vi);
      });
    }), wi.resolve(this.xi(n));
  }
  getAllMutationBatchesAffectingQuery(t2, e) {
    const n = e.path, s = n.length + 1;
    let i = n;
    xt.isDocumentKey(i) || (i = i.child(""));
    const r = new yo(new xt(i), 0);
    let o = new $n(rt);
    return this.Si.forEachWhile((t3) => {
      const e2 = t3.key.path;
      return !!n.isPrefixOf(e2) && (e2.length === s && (o = o.add(t3.Vi)), true);
    }, r), wi.resolve(this.xi(o));
  }
  xi(t2) {
    const e = [];
    return t2.forEach((t3) => {
      const n = this.Di(t3);
      n !== null && e.push(n);
    }), e;
  }
  removeMutationBatch(t2, e) {
    U2(this.Ni(e.batchId, "removed") === 0), this.$s.shift();
    let n = this.Si;
    return wi.forEach(e.mutations, (s) => {
      const i = new yo(s.key, e.batchId);
      return n = n.delete(i), this.referenceDelegate.markPotentiallyOrphaned(t2, s.key);
    }).next(() => {
      this.Si = n;
    });
  }
  dn(t2) {
  }
  containsKey(t2, e) {
    const n = new yo(e, 0), s = this.Si.firstAfterOrEqual(n);
    return wi.resolve(e.isEqual(s && s.key));
  }
  performConsistencyCheck(t2) {
    return this.$s.length, wi.resolve();
  }
  Ni(t2, e) {
    return this.Ci(t2);
  }
  Ci(t2) {
    if (this.$s.length === 0)
      return 0;
    return t2 - this.$s[0].batchId;
  }
  Di(t2) {
    const e = this.Ci(t2);
    if (e < 0 || e >= this.$s.length)
      return null;
    return this.$s[e];
  }
};
var Io = class {
  constructor(t2) {
    this.ki = t2, this.docs = new Mn(xt.comparator), this.size = 0;
  }
  setIndexManager(t2) {
    this.indexManager = t2;
  }
  addEntry(t2, e) {
    const n = e.key, s = this.docs.get(n), i = s ? s.size : 0, r = this.ki(e);
    return this.docs = this.docs.insert(n, {
      document: e.mutableCopy(),
      size: r
    }), this.size += r - i, this.indexManager.addToCollectionParentIndex(t2, n.path.popLast());
  }
  removeEntry(t2) {
    const e = this.docs.get(t2);
    e && (this.docs = this.docs.remove(t2), this.size -= e.size);
  }
  getEntry(t2, e) {
    const n = this.docs.get(e);
    return wi.resolve(n ? n.document.mutableCopy() : te.newInvalidDocument(e));
  }
  getEntries(t2, e) {
    let n = qn();
    return e.forEach((t3) => {
      const e2 = this.docs.get(t3);
      n = n.insert(t3, e2 ? e2.document.mutableCopy() : te.newInvalidDocument(t3));
    }), wi.resolve(n);
  }
  getAllFromCollection(t2, e, n) {
    let s = qn();
    const i = new xt(e.child("")), r = this.docs.getIteratorFrom(i);
    for (; r.hasNext(); ) {
      const { key: t3, value: { document: i2 } } = r.getNext();
      if (!e.isPrefixOf(t3.path))
        break;
      t3.path.length > e.length + 1 || (ce(ue(i2), n) <= 0 || (s = s.insert(i2.key, i2.mutableCopy())));
    }
    return wi.resolve(s);
  }
  getAllFromCollectionGroup(t2, e, n, s) {
    L2();
  }
  Mi(t2, e) {
    return wi.forEach(this.docs, (t3) => e(t3));
  }
  newChangeBuffer(t2) {
    return new To(this);
  }
  getSize(t2) {
    return wi.resolve(this.size);
  }
};
var To = class extends kr {
  constructor(t2) {
    super(), this.qn = t2;
  }
  applyChanges(t2) {
    const e = [];
    return this.changes.forEach((n, s) => {
      s.isValidDocument() ? e.push(this.qn.addEntry(t2, s)) : this.qn.removeEntry(n);
    }), wi.waitFor(e);
  }
  getFromCache(t2, e) {
    return this.qn.getEntry(t2, e);
  }
  getAllFromCache(t2, e) {
    return this.qn.getEntries(t2, e);
  }
};
var Eo = class {
  constructor(t2) {
    this.persistence = t2, this.Oi = new kn((t3) => fe(t3), _e), this.lastRemoteSnapshotVersion = ct.min(), this.highestTargetId = 0, this.Fi = 0, this.$i = new go(), this.targetCount = 0, this.Bi = Er.mn();
  }
  forEachTarget(t2, e) {
    return this.Oi.forEach((t3, n) => e(n)), wi.resolve();
  }
  getLastRemoteSnapshotVersion(t2) {
    return wi.resolve(this.lastRemoteSnapshotVersion);
  }
  getHighestSequenceNumber(t2) {
    return wi.resolve(this.Fi);
  }
  allocateTargetId(t2) {
    return this.highestTargetId = this.Bi.next(), wi.resolve(this.highestTargetId);
  }
  setTargetsMetadata(t2, e, n) {
    return n && (this.lastRemoteSnapshotVersion = n), e > this.Fi && (this.Fi = e), wi.resolve();
  }
  In(t2) {
    this.Oi.set(t2.target, t2);
    const e = t2.targetId;
    e > this.highestTargetId && (this.Bi = new Er(e), this.highestTargetId = e), t2.sequenceNumber > this.Fi && (this.Fi = t2.sequenceNumber);
  }
  addTargetData(t2, e) {
    return this.In(e), this.targetCount += 1, wi.resolve();
  }
  updateTargetData(t2, e) {
    return this.In(e), wi.resolve();
  }
  removeTargetData(t2, e) {
    return this.Oi.delete(e.target), this.$i.Ri(e.targetId), this.targetCount -= 1, wi.resolve();
  }
  removeTargets(t2, e, n) {
    let s = 0;
    const i = [];
    return this.Oi.forEach((r, o) => {
      o.sequenceNumber <= e && n.get(o.targetId) === null && (this.Oi.delete(r), i.push(this.removeMatchingKeysForTargetId(t2, o.targetId)), s++);
    }), wi.waitFor(i).next(() => s);
  }
  getTargetCount(t2) {
    return wi.resolve(this.targetCount);
  }
  getTargetData(t2, e) {
    const n = this.Oi.get(e) || null;
    return wi.resolve(n);
  }
  addMatchingKeys(t2, e, n) {
    return this.$i.Ti(e, n), wi.resolve();
  }
  removeMatchingKeys(t2, e, n) {
    this.$i.Ai(e, n);
    const s = this.persistence.referenceDelegate, i = [];
    return s && e.forEach((e2) => {
      i.push(s.markPotentiallyOrphaned(t2, e2));
    }), wi.waitFor(i);
  }
  removeMatchingKeysForTargetId(t2, e) {
    return this.$i.Ri(e), wi.resolve();
  }
  getMatchingKeysForTargetId(t2, e) {
    const n = this.$i.Pi(e);
    return wi.resolve(n);
  }
  containsKey(t2, e) {
    return wi.resolve(this.$i.containsKey(e));
  }
};
var Ao = class {
  constructor(t2, e) {
    this.Li = {}, this.overlays = {}, this.ts = new nt(0), this.es = false, this.es = true, this.referenceDelegate = t2(this), this.ls = new Eo(this);
    this.indexManager = new rr(), this.fs = function(t3) {
      return new Io(t3);
    }((t3) => this.referenceDelegate.Ui(t3)), this.M = new Ci(e), this.ds = new wo(this.M);
  }
  start() {
    return Promise.resolve();
  }
  shutdown() {
    return this.es = false, Promise.resolve();
  }
  get started() {
    return this.es;
  }
  setDatabaseDeletedListener() {
  }
  setNetworkEnabled() {
  }
  getIndexManager(t2) {
    return this.indexManager;
  }
  getDocumentOverlayCache(t2) {
    let e = this.overlays[t2.toKey()];
    return e || (e = new mo(), this.overlays[t2.toKey()] = e), e;
  }
  getMutationQueue(t2, e) {
    let n = this.Li[t2.toKey()];
    return n || (n = new po(e, this.referenceDelegate), this.Li[t2.toKey()] = n), n;
  }
  getTargetCache() {
    return this.ls;
  }
  getRemoteDocumentCache() {
    return this.fs;
  }
  getBundleCache() {
    return this.ds;
  }
  runTransaction(t2, e, n) {
    O2("MemoryPersistence", "Starting transaction:", t2);
    const s = new Ro(this.ts.next());
    return this.referenceDelegate.qi(), n(s).next((t3) => this.referenceDelegate.Gi(s).next(() => t3)).toPromise().then((t3) => (s.raiseOnCommittedEvent(), t3));
  }
  Ki(t2, e) {
    return wi.or(Object.values(this.Li).map((n) => () => n.containsKey(t2, e)));
  }
};
var Ro = class extends _i {
  constructor(t2) {
    super(), this.currentSequenceNumber = t2;
  }
};
var bo = class {
  constructor(t2) {
    this.persistence = t2, this.Qi = new go(), this.ji = null;
  }
  static Wi(t2) {
    return new bo(t2);
  }
  get zi() {
    if (this.ji)
      return this.ji;
    throw L2();
  }
  addReference(t2, e, n) {
    return this.Qi.addReference(n, e), this.zi.delete(n.toString()), wi.resolve();
  }
  removeReference(t2, e, n) {
    return this.Qi.removeReference(n, e), this.zi.add(n.toString()), wi.resolve();
  }
  markPotentiallyOrphaned(t2, e) {
    return this.zi.add(e.toString()), wi.resolve();
  }
  removeTarget(t2, e) {
    this.Qi.Ri(e.targetId).forEach((t3) => this.zi.add(t3.toString()));
    const n = this.persistence.getTargetCache();
    return n.getMatchingKeysForTargetId(t2, e.targetId).next((t3) => {
      t3.forEach((t4) => this.zi.add(t4.toString()));
    }).next(() => n.removeTargetData(t2, e));
  }
  qi() {
    this.ji = /* @__PURE__ */ new Set();
  }
  Gi(t2) {
    const e = this.persistence.getRemoteDocumentCache().newChangeBuffer();
    return wi.forEach(this.zi, (n) => {
      const s = xt.fromPath(n);
      return this.Hi(t2, s).next((t3) => {
        t3 || e.removeEntry(s, ct.min());
      });
    }).next(() => (this.ji = null, e.apply(t2)));
  }
  updateLimboDocument(t2, e) {
    return this.Hi(t2, e).next((t3) => {
      t3 ? this.zi.delete(e.toString()) : this.zi.add(e.toString());
    });
  }
  Ui(t2) {
    return 0;
  }
  Hi(t2, e) {
    return wi.or([() => wi.resolve(this.Qi.containsKey(e)), () => this.persistence.getTargetCache().containsKey(t2, e), () => this.persistence.Ki(t2, e)]);
  }
};
function Po(t2, e) {
  return `firestore_clients_${t2}_${e}`;
}
function Vo(t2, e, n) {
  let s = `firestore_mutations_${t2}_${n}`;
  return e.isAuthenticated() && (s += `_${e.uid}`), s;
}
function vo(t2, e) {
  return `firestore_targets_${t2}_${e}`;
}
var So = class {
  constructor(t2, e, n, s) {
    this.user = t2, this.batchId = e, this.state = n, this.error = s;
  }
  static Ji(t2, e, n) {
    const s = JSON.parse(n);
    let i, r = typeof s == "object" && ["pending", "acknowledged", "rejected"].indexOf(s.state) !== -1 && (s.error === void 0 || typeof s.error == "object");
    return r && s.error && (r = typeof s.error.message == "string" && typeof s.error.code == "string", r && (i = new Q2(s.error.code, s.error.message))), r ? new So(t2, e, s.state, i) : (F2("SharedClientState", `Failed to parse mutation state for ID '${e}': ${n}`), null);
  }
  Yi() {
    const t2 = {
      state: this.state,
      updateTimeMs: Date.now()
    };
    return this.error && (t2.error = {
      code: this.error.code,
      message: this.error.message
    }), JSON.stringify(t2);
  }
};
var Do = class {
  constructor(t2, e, n) {
    this.targetId = t2, this.state = e, this.error = n;
  }
  static Ji(t2, e) {
    const n = JSON.parse(e);
    let s, i = typeof n == "object" && ["not-current", "current", "rejected"].indexOf(n.state) !== -1 && (n.error === void 0 || typeof n.error == "object");
    return i && n.error && (i = typeof n.error.message == "string" && typeof n.error.code == "string", i && (s = new Q2(n.error.code, n.error.message))), i ? new Do(t2, n.state, s) : (F2("SharedClientState", `Failed to parse target state for ID '${t2}': ${e}`), null);
  }
  Yi() {
    const t2 = {
      state: this.state,
      updateTimeMs: Date.now()
    };
    return this.error && (t2.error = {
      code: this.error.code,
      message: this.error.message
    }), JSON.stringify(t2);
  }
};
var Co = class {
  constructor(t2, e) {
    this.clientId = t2, this.activeTargetIds = e;
  }
  static Ji(t2, e) {
    const n = JSON.parse(e);
    let s = typeof n == "object" && n.activeTargetIds instanceof Array, i = Jn();
    for (let t3 = 0; s && t3 < n.activeTargetIds.length; ++t3)
      s = Ct(n.activeTargetIds[t3]), i = i.add(n.activeTargetIds[t3]);
    return s ? new Co(t2, i) : (F2("SharedClientState", `Failed to parse client data for instance '${t2}': ${e}`), null);
  }
};
var xo = class {
  constructor(t2, e) {
    this.clientId = t2, this.onlineState = e;
  }
  static Ji(t2) {
    const e = JSON.parse(t2);
    return typeof e == "object" && ["Unknown", "Online", "Offline"].indexOf(e.onlineState) !== -1 && typeof e.clientId == "string" ? new xo(e.clientId, e.onlineState) : (F2("SharedClientState", `Failed to parse online state: ${t2}`), null);
  }
};
var No = class {
  constructor() {
    this.activeTargetIds = Jn();
  }
  Xi(t2) {
    this.activeTargetIds = this.activeTargetIds.add(t2);
  }
  Zi(t2) {
    this.activeTargetIds = this.activeTargetIds.delete(t2);
  }
  Yi() {
    const t2 = {
      activeTargetIds: this.activeTargetIds.toArray(),
      updateTimeMs: Date.now()
    };
    return JSON.stringify(t2);
  }
};
var ko = class {
  constructor(t2, e, n, s, i) {
    this.window = t2, this.Jn = e, this.persistenceKey = n, this.tr = s, this.syncEngine = null, this.onlineStateHandler = null, this.sequenceNumberHandler = null, this.er = this.nr.bind(this), this.sr = new Mn(rt), this.started = false, this.ir = [];
    const r = n.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    this.storage = this.window.localStorage, this.currentUser = i, this.rr = Po(this.persistenceKey, this.tr), this.ur = function(t3) {
      return `firestore_sequence_number_${t3}`;
    }(this.persistenceKey), this.sr = this.sr.insert(this.tr, new No()), this.ar = new RegExp(`^firestore_clients_${r}_([^_]*)$`), this.cr = new RegExp(`^firestore_mutations_${r}_(\\d+)(?:_(.*))?$`), this.hr = new RegExp(`^firestore_targets_${r}_(\\d+)$`), this.lr = function(t3) {
      return `firestore_online_state_${t3}`;
    }(this.persistenceKey), this.dr = function(t3) {
      return `firestore_bundle_loaded_v2_${t3}`;
    }(this.persistenceKey), this.window.addEventListener("storage", this.er);
  }
  static vt(t2) {
    return !(!t2 || !t2.localStorage);
  }
  async start() {
    const t2 = await this.syncEngine.Os();
    for (const e2 of t2) {
      if (e2 === this.tr)
        continue;
      const t3 = this.getItem(Po(this.persistenceKey, e2));
      if (t3) {
        const n = Co.Ji(e2, t3);
        n && (this.sr = this.sr.insert(n.clientId, n));
      }
    }
    this._r();
    const e = this.storage.getItem(this.lr);
    if (e) {
      const t3 = this.wr(e);
      t3 && this.mr(t3);
    }
    for (const t3 of this.ir)
      this.nr(t3);
    this.ir = [], this.window.addEventListener("pagehide", () => this.shutdown()), this.started = true;
  }
  writeSequenceNumber(t2) {
    this.setItem(this.ur, JSON.stringify(t2));
  }
  getAllActiveQueryTargets() {
    return this.gr(this.sr);
  }
  isActiveQueryTarget(t2) {
    let e = false;
    return this.sr.forEach((n, s) => {
      s.activeTargetIds.has(t2) && (e = true);
    }), e;
  }
  addPendingMutation(t2) {
    this.yr(t2, "pending");
  }
  updateMutationState(t2, e, n) {
    this.yr(t2, e, n), this.pr(t2);
  }
  addLocalQueryTarget(t2) {
    let e = "not-current";
    if (this.isActiveQueryTarget(t2)) {
      const n = this.storage.getItem(vo(this.persistenceKey, t2));
      if (n) {
        const s = Do.Ji(t2, n);
        s && (e = s.state);
      }
    }
    return this.Ir.Xi(t2), this._r(), e;
  }
  removeLocalQueryTarget(t2) {
    this.Ir.Zi(t2), this._r();
  }
  isLocalQueryTarget(t2) {
    return this.Ir.activeTargetIds.has(t2);
  }
  clearQueryState(t2) {
    this.removeItem(vo(this.persistenceKey, t2));
  }
  updateQueryState(t2, e, n) {
    this.Tr(t2, e, n);
  }
  handleUserChange(t2, e, n) {
    e.forEach((t3) => {
      this.pr(t3);
    }), this.currentUser = t2, n.forEach((t3) => {
      this.addPendingMutation(t3);
    });
  }
  setOnlineState(t2) {
    this.Er(t2);
  }
  notifyBundleLoaded(t2) {
    this.Ar(t2);
  }
  shutdown() {
    this.started && (this.window.removeEventListener("storage", this.er), this.removeItem(this.rr), this.started = false);
  }
  getItem(t2) {
    const e = this.storage.getItem(t2);
    return O2("SharedClientState", "READ", t2, e), e;
  }
  setItem(t2, e) {
    O2("SharedClientState", "SET", t2, e), this.storage.setItem(t2, e);
  }
  removeItem(t2) {
    O2("SharedClientState", "REMOVE", t2), this.storage.removeItem(t2);
  }
  nr(t2) {
    const e = t2;
    if (e.storageArea === this.storage) {
      if (O2("SharedClientState", "EVENT", e.key, e.newValue), e.key === this.rr)
        return void F2("Received WebStorage notification for local change. Another client might have garbage-collected our state");
      this.Jn.enqueueRetryable(async () => {
        if (this.started) {
          if (e.key !== null) {
            if (this.ar.test(e.key)) {
              if (e.newValue == null) {
                const t3 = this.Rr(e.key);
                return this.br(t3, null);
              }
              {
                const t3 = this.Pr(e.key, e.newValue);
                if (t3)
                  return this.br(t3.clientId, t3);
              }
            } else if (this.cr.test(e.key)) {
              if (e.newValue !== null) {
                const t3 = this.Vr(e.key, e.newValue);
                if (t3)
                  return this.vr(t3);
              }
            } else if (this.hr.test(e.key)) {
              if (e.newValue !== null) {
                const t3 = this.Sr(e.key, e.newValue);
                if (t3)
                  return this.Dr(t3);
              }
            } else if (e.key === this.lr) {
              if (e.newValue !== null) {
                const t3 = this.wr(e.newValue);
                if (t3)
                  return this.mr(t3);
              }
            } else if (e.key === this.ur) {
              const t3 = function(t4) {
                let e2 = nt.A;
                if (t4 != null)
                  try {
                    const n = JSON.parse(t4);
                    U2(typeof n == "number"), e2 = n;
                  } catch (t5) {
                    F2("SharedClientState", "Failed to read sequence number from WebStorage", t5);
                  }
                return e2;
              }(e.newValue);
              t3 !== nt.A && this.sequenceNumberHandler(t3);
            } else if (e.key === this.dr) {
              const t3 = this.Cr(e.newValue);
              await Promise.all(t3.map((t4) => this.syncEngine.Nr(t4)));
            }
          }
        } else
          this.ir.push(e);
      });
    }
  }
  get Ir() {
    return this.sr.get(this.tr);
  }
  _r() {
    this.setItem(this.rr, this.Ir.Yi());
  }
  yr(t2, e, n) {
    const s = new So(this.currentUser, t2, e, n), i = Vo(this.persistenceKey, this.currentUser, t2);
    this.setItem(i, s.Yi());
  }
  pr(t2) {
    const e = Vo(this.persistenceKey, this.currentUser, t2);
    this.removeItem(e);
  }
  Er(t2) {
    const e = {
      clientId: this.tr,
      onlineState: t2
    };
    this.storage.setItem(this.lr, JSON.stringify(e));
  }
  Tr(t2, e, n) {
    const s = vo(this.persistenceKey, t2), i = new Do(t2, e, n);
    this.setItem(s, i.Yi());
  }
  Ar(t2) {
    const e = JSON.stringify(Array.from(t2));
    this.setItem(this.dr, e);
  }
  Rr(t2) {
    const e = this.ar.exec(t2);
    return e ? e[1] : null;
  }
  Pr(t2, e) {
    const n = this.Rr(t2);
    return Co.Ji(n, e);
  }
  Vr(t2, e) {
    const n = this.cr.exec(t2), s = Number(n[1]), i = n[2] !== void 0 ? n[2] : null;
    return So.Ji(new C2(i), s, e);
  }
  Sr(t2, e) {
    const n = this.hr.exec(t2), s = Number(n[1]);
    return Do.Ji(s, e);
  }
  wr(t2) {
    return xo.Ji(t2);
  }
  Cr(t2) {
    return JSON.parse(t2);
  }
  async vr(t2) {
    if (t2.user.uid === this.currentUser.uid)
      return this.syncEngine.kr(t2.batchId, t2.state, t2.error);
    O2("SharedClientState", `Ignoring mutation for non-active user ${t2.user.uid}`);
  }
  Dr(t2) {
    return this.syncEngine.Mr(t2.targetId, t2.state, t2.error);
  }
  br(t2, e) {
    const n = e ? this.sr.insert(t2, e) : this.sr.remove(t2), s = this.gr(this.sr), i = this.gr(n), r = [], o = [];
    return i.forEach((t3) => {
      s.has(t3) || r.push(t3);
    }), s.forEach((t3) => {
      i.has(t3) || o.push(t3);
    }), this.syncEngine.Or(r, o).then(() => {
      this.sr = n;
    });
  }
  mr(t2) {
    this.sr.get(t2.clientId) && this.onlineStateHandler(t2.onlineState);
  }
  gr(t2) {
    let e = Jn();
    return t2.forEach((t3, n) => {
      e = e.unionWith(n.activeTargetIds);
    }), e;
  }
};
var Mo = class {
  constructor() {
    this.Fr = new No(), this.$r = {}, this.onlineStateHandler = null, this.sequenceNumberHandler = null;
  }
  addPendingMutation(t2) {
  }
  updateMutationState(t2, e, n) {
  }
  addLocalQueryTarget(t2) {
    return this.Fr.Xi(t2), this.$r[t2] || "not-current";
  }
  updateQueryState(t2, e, n) {
    this.$r[t2] = e;
  }
  removeLocalQueryTarget(t2) {
    this.Fr.Zi(t2);
  }
  isLocalQueryTarget(t2) {
    return this.Fr.activeTargetIds.has(t2);
  }
  clearQueryState(t2) {
    delete this.$r[t2];
  }
  getAllActiveQueryTargets() {
    return this.Fr.activeTargetIds;
  }
  isActiveQueryTarget(t2) {
    return this.Fr.activeTargetIds.has(t2);
  }
  start() {
    return this.Fr = new No(), Promise.resolve();
  }
  handleUserChange(t2, e, n) {
  }
  setOnlineState(t2) {
  }
  shutdown() {
  }
  writeSequenceNumber(t2) {
  }
  notifyBundleLoaded(t2) {
  }
};
var Oo = class {
  Br(t2) {
  }
  shutdown() {
  }
};
var Fo = class {
  constructor() {
    this.Lr = () => this.Ur(), this.qr = () => this.Gr(), this.Kr = [], this.Qr();
  }
  Br(t2) {
    this.Kr.push(t2);
  }
  shutdown() {
    window.removeEventListener("online", this.Lr), window.removeEventListener("offline", this.qr);
  }
  Qr() {
    window.addEventListener("online", this.Lr), window.addEventListener("offline", this.qr);
  }
  Ur() {
    O2("ConnectivityMonitor", "Network connectivity changed: AVAILABLE");
    for (const t2 of this.Kr)
      t2(0);
  }
  Gr() {
    O2("ConnectivityMonitor", "Network connectivity changed: UNAVAILABLE");
    for (const t2 of this.Kr)
      t2(1);
  }
  static vt() {
    return typeof window != "undefined" && window.addEventListener !== void 0 && window.removeEventListener !== void 0;
  }
};
var $o = {
  BatchGetDocuments: "batchGet",
  Commit: "commit",
  RunQuery: "runQuery"
};
var Bo = class {
  constructor(t2) {
    this.jr = t2.jr, this.Wr = t2.Wr;
  }
  zr(t2) {
    this.Hr = t2;
  }
  Jr(t2) {
    this.Yr = t2;
  }
  onMessage(t2) {
    this.Xr = t2;
  }
  close() {
    this.Wr();
  }
  send(t2) {
    this.jr(t2);
  }
  Zr() {
    this.Hr();
  }
  eo(t2) {
    this.Yr(t2);
  }
  no(t2) {
    this.Xr(t2);
  }
};
var Lo = class extends class {
  constructor(t2) {
    this.databaseInfo = t2, this.databaseId = t2.databaseId;
    const e = t2.ssl ? "https" : "http";
    this.so = e + "://" + t2.host, this.io = "projects/" + this.databaseId.projectId + "/databases/" + this.databaseId.database + "/documents";
  }
  ro(t2, e, n, s, i) {
    const r = this.oo(t2, e);
    O2("RestConnection", "Sending: ", r, n);
    const o = {};
    return this.uo(o, s, i), this.ao(t2, r, o, n).then((t3) => (O2("RestConnection", "Received: ", t3), t3), (e2) => {
      throw $("RestConnection", `${t2} failed with error: `, e2, "url: ", r, "request:", n), e2;
    });
  }
  co(t2, e, n, s, i) {
    return this.ro(t2, e, n, s, i);
  }
  uo(t2, e, n) {
    t2["X-Goog-Api-Client"] = "gl-js/ fire/" + x2, t2["Content-Type"] = "text/plain", this.databaseInfo.appId && (t2["X-Firebase-GMPID"] = this.databaseInfo.appId), e && e.headers.forEach((e2, n2) => t2[n2] = e2), n && n.headers.forEach((e2, n2) => t2[n2] = e2);
  }
  oo(t2, e) {
    const n = $o[t2];
    return `${this.so}/v1/${e}:${n}`;
  }
} {
  constructor(t2) {
    super(t2), this.forceLongPolling = t2.forceLongPolling, this.autoDetectLongPolling = t2.autoDetectLongPolling, this.useFetchStreams = t2.useFetchStreams;
  }
  ao(t2, e, n, s) {
    return new Promise((i, r) => {
      const o = new XhrIo();
      o.listenOnce(EventType.COMPLETE, () => {
        try {
          switch (o.getLastErrorCode()) {
            case ErrorCode.NO_ERROR:
              const e2 = o.getResponseJson();
              O2("Connection", "XHR received:", JSON.stringify(e2)), i(e2);
              break;
            case ErrorCode.TIMEOUT:
              O2("Connection", 'RPC "' + t2 + '" timed out'), r(new Q2(K2.DEADLINE_EXCEEDED, "Request time out"));
              break;
            case ErrorCode.HTTP_ERROR:
              const n2 = o.getStatus();
              if (O2("Connection", 'RPC "' + t2 + '" failed with status:', n2, "response text:", o.getResponseText()), n2 > 0) {
                const t3 = o.getResponseJson().error;
                if (t3 && t3.status && t3.message) {
                  const e3 = function(t4) {
                    const e4 = t4.toLowerCase().replace(/_/g, "-");
                    return Object.values(K2).indexOf(e4) >= 0 ? e4 : K2.UNKNOWN;
                  }(t3.status);
                  r(new Q2(e3, t3.message));
                } else
                  r(new Q2(K2.UNKNOWN, "Server responded with status " + o.getStatus()));
              } else
                r(new Q2(K2.UNAVAILABLE, "Connection failed."));
              break;
            default:
              L2();
          }
        } finally {
          O2("Connection", 'RPC "' + t2 + '" completed.');
        }
      });
      const u = JSON.stringify(s);
      o.send(e, "POST", u, n, 15);
    });
  }
  ho(t2, e, n) {
    const s = [this.so, "/", "google.firestore.v1.Firestore", "/", t2, "/channel"], i = createWebChannelTransport(), r = getStatEventTarget(), o = {
      httpSessionIdParam: "gsessionid",
      initMessageHeaders: {},
      messageUrlParams: {
        database: `projects/${this.databaseId.projectId}/databases/${this.databaseId.database}`
      },
      sendRawJson: true,
      supportsCrossDomainXhr: true,
      internalChannelParams: {
        forwardChannelRequestTimeoutMs: 6e5
      },
      forceLongPolling: this.forceLongPolling,
      detectBufferingProxy: this.autoDetectLongPolling
    };
    this.useFetchStreams && (o.xmlHttpFactory = new FetchXmlHttpFactory({})), this.uo(o.initMessageHeaders, e, n), isMobileCordova() || isReactNative() || isElectron() || isIE() || isUWP() || isBrowserExtension() || (o.httpHeadersOverwriteParam = "$httpHeaders");
    const u = s.join("");
    O2("Connection", "Creating WebChannel: " + u, o);
    const a = i.createWebChannel(u, o);
    let c = false, h = false;
    const l2 = new Bo({
      jr: (t3) => {
        h ? O2("Connection", "Not sending because WebChannel is closed:", t3) : (c || (O2("Connection", "Opening WebChannel transport."), a.open(), c = true), O2("Connection", "WebChannel sending:", t3), a.send(t3));
      },
      Wr: () => a.close()
    }), y2 = (t3, e2, n2) => {
      t3.listen(e2, (t4) => {
        try {
          n2(t4);
        } catch (t5) {
          setTimeout(() => {
            throw t5;
          }, 0);
        }
      });
    };
    return y2(a, WebChannel.EventType.OPEN, () => {
      h || O2("Connection", "WebChannel transport opened.");
    }), y2(a, WebChannel.EventType.CLOSE, () => {
      h || (h = true, O2("Connection", "WebChannel transport closed"), l2.eo());
    }), y2(a, WebChannel.EventType.ERROR, (t3) => {
      h || (h = true, $("Connection", "WebChannel transport errored:", t3), l2.eo(new Q2(K2.UNAVAILABLE, "The operation could not be completed")));
    }), y2(a, WebChannel.EventType.MESSAGE, (t3) => {
      var e2;
      if (!h) {
        const n2 = t3.data[0];
        U2(!!n2);
        const s2 = n2, i2 = s2.error || ((e2 = s2[0]) === null || e2 === void 0 ? void 0 : e2.error);
        if (i2) {
          O2("Connection", "WebChannel received error:", i2);
          const t4 = i2.status;
          let e3 = function(t5) {
            const e4 = Dn[t5];
            if (e4 !== void 0)
              return Nn(e4);
          }(t4), n3 = i2.message;
          e3 === void 0 && (e3 = K2.INTERNAL, n3 = "Unknown error status: " + t4 + " with message " + i2.message), h = true, l2.eo(new Q2(e3, n3)), a.close();
        } else
          O2("Connection", "WebChannel received:", n2), l2.no(n2);
      }
    }), y2(r, Event.STAT_EVENT, (t3) => {
      t3.stat === Stat.PROXY ? O2("Connection", "Detected buffering proxy") : t3.stat === Stat.NOPROXY && O2("Connection", "Detected no buffering proxy");
    }), setTimeout(() => {
      l2.Zr();
    }, 0), l2;
  }
};
function Uo() {
  return typeof window != "undefined" ? window : null;
}
function qo() {
  return typeof document != "undefined" ? document : null;
}
function Go(t2) {
  return new as(t2, true);
}
var Ko = class {
  constructor(t2, e, n = 1e3, s = 1.5, i = 6e4) {
    this.Jn = t2, this.timerId = e, this.lo = n, this.fo = s, this._o = i, this.wo = 0, this.mo = null, this.yo = Date.now(), this.reset();
  }
  reset() {
    this.wo = 0;
  }
  po() {
    this.wo = this._o;
  }
  Io(t2) {
    this.cancel();
    const e = Math.floor(this.wo + this.To()), n = Math.max(0, Date.now() - this.yo), s = Math.max(0, e - n);
    s > 0 && O2("ExponentialBackoff", `Backing off for ${s} ms (base delay: ${this.wo} ms, delay with jitter: ${e} ms, last attempt: ${n} ms ago)`), this.mo = this.Jn.enqueueAfterDelay(this.timerId, s, () => (this.yo = Date.now(), t2())), this.wo *= this.fo, this.wo < this.lo && (this.wo = this.lo), this.wo > this._o && (this.wo = this._o);
  }
  Eo() {
    this.mo !== null && (this.mo.skipDelay(), this.mo = null);
  }
  cancel() {
    this.mo !== null && (this.mo.cancel(), this.mo = null);
  }
  To() {
    return (Math.random() - 0.5) * this.wo;
  }
};
var Qo = class {
  constructor(t2, e, n, s, i, r, o, u) {
    this.Jn = t2, this.Ao = n, this.Ro = s, this.bo = i, this.authCredentialsProvider = r, this.appCheckCredentialsProvider = o, this.listener = u, this.state = 0, this.Po = 0, this.Vo = null, this.vo = null, this.stream = null, this.So = new Ko(t2, e);
  }
  Do() {
    return this.state === 1 || this.state === 5 || this.Co();
  }
  Co() {
    return this.state === 2 || this.state === 3;
  }
  start() {
    this.state !== 4 ? this.auth() : this.xo();
  }
  async stop() {
    this.Do() && await this.close(0);
  }
  No() {
    this.state = 0, this.So.reset();
  }
  ko() {
    this.Co() && this.Vo === null && (this.Vo = this.Jn.enqueueAfterDelay(this.Ao, 6e4, () => this.Mo()));
  }
  Oo(t2) {
    this.Fo(), this.stream.send(t2);
  }
  async Mo() {
    if (this.Co())
      return this.close(0);
  }
  Fo() {
    this.Vo && (this.Vo.cancel(), this.Vo = null);
  }
  $o() {
    this.vo && (this.vo.cancel(), this.vo = null);
  }
  async close(t2, e) {
    this.Fo(), this.$o(), this.So.cancel(), this.Po++, t2 !== 4 ? this.So.reset() : e && e.code === K2.RESOURCE_EXHAUSTED ? (F2(e.toString()), F2("Using maximum backoff delay to prevent overloading the backend."), this.So.po()) : e && e.code === K2.UNAUTHENTICATED && this.state !== 3 && (this.authCredentialsProvider.invalidateToken(), this.appCheckCredentialsProvider.invalidateToken()), this.stream !== null && (this.Bo(), this.stream.close(), this.stream = null), this.state = t2, await this.listener.Jr(e);
  }
  Bo() {
  }
  auth() {
    this.state = 1;
    const t2 = this.Lo(this.Po), e = this.Po;
    Promise.all([this.authCredentialsProvider.getToken(), this.appCheckCredentialsProvider.getToken()]).then(([t3, n]) => {
      this.Po === e && this.Uo(t3, n);
    }, (e2) => {
      t2(() => {
        const t3 = new Q2(K2.UNKNOWN, "Fetching auth token failed: " + e2.message);
        return this.qo(t3);
      });
    });
  }
  Uo(t2, e) {
    const n = this.Lo(this.Po);
    this.stream = this.Go(t2, e), this.stream.zr(() => {
      n(() => (this.state = 2, this.vo = this.Jn.enqueueAfterDelay(this.Ro, 1e4, () => (this.Co() && (this.state = 3), Promise.resolve())), this.listener.zr()));
    }), this.stream.Jr((t3) => {
      n(() => this.qo(t3));
    }), this.stream.onMessage((t3) => {
      n(() => this.onMessage(t3));
    });
  }
  xo() {
    this.state = 5, this.So.Io(async () => {
      this.state = 0, this.start();
    });
  }
  qo(t2) {
    return O2("PersistentStream", `close with error: ${t2}`), this.stream = null, this.close(4, t2);
  }
  Lo(t2) {
    return (e) => {
      this.Jn.enqueueAndForget(() => this.Po === t2 ? e() : (O2("PersistentStream", "stream callback skipped by getCloseGuardedDispatcher."), Promise.resolve()));
    };
  }
};
var jo = class extends Qo {
  constructor(t2, e, n, s, i, r) {
    super(t2, "listen_stream_connection_backoff", "listen_stream_idle", "health_check_timeout", e, n, s, r), this.M = i;
  }
  Go(t2, e) {
    return this.bo.ho("Listen", t2, e);
  }
  onMessage(t2) {
    this.So.reset();
    const e = Rs(this.M, t2), n = function(t3) {
      if (!("targetChange" in t3))
        return ct.min();
      const e2 = t3.targetChange;
      return e2.targetIds && e2.targetIds.length ? ct.min() : e2.readTime ? fs(e2.readTime) : ct.min();
    }(t2);
    return this.listener.Ko(e, n);
  }
  Qo(t2) {
    const e = {};
    e.database = ps(this.M), e.addTarget = function(t3, e2) {
      let n2;
      const s = e2.target;
      return n2 = we(s) ? {
        documents: vs(t3, s)
      } : {
        query: Ss(t3, s)
      }, n2.targetId = e2.targetId, e2.resumeToken.approximateByteSize() > 0 ? n2.resumeToken = hs(t3, e2.resumeToken) : e2.snapshotVersion.compareTo(ct.min()) > 0 && (n2.readTime = cs(t3, e2.snapshotVersion.toTimestamp())), n2;
    }(this.M, t2);
    const n = Cs(this.M, t2);
    n && (e.labels = n), this.Oo(e);
  }
  jo(t2) {
    const e = {};
    e.database = ps(this.M), e.removeTarget = t2, this.Oo(e);
  }
};
var Wo = class extends Qo {
  constructor(t2, e, n, s, i, r) {
    super(t2, "write_stream_connection_backoff", "write_stream_idle", "health_check_timeout", e, n, s, r), this.M = i, this.Wo = false;
  }
  get zo() {
    return this.Wo;
  }
  start() {
    this.Wo = false, this.lastStreamToken = void 0, super.start();
  }
  Bo() {
    this.Wo && this.Ho([]);
  }
  Go(t2, e) {
    return this.bo.ho("Write", t2, e);
  }
  onMessage(t2) {
    if (U2(!!t2.streamToken), this.lastStreamToken = t2.streamToken, this.Wo) {
      this.So.reset();
      const e = Vs(t2.writeResults, t2.commitTime), n = fs(t2.commitTime);
      return this.listener.Jo(n, e);
    }
    return U2(!t2.writeResults || t2.writeResults.length === 0), this.Wo = true, this.listener.Yo();
  }
  Xo() {
    const t2 = {};
    t2.database = ps(this.M), this.Oo(t2);
  }
  Ho(t2) {
    const e = {
      streamToken: this.lastStreamToken,
      writes: t2.map((t3) => bs(this.M, t3))
    };
    this.Oo(e);
  }
};
var zo = class extends class {
} {
  constructor(t2, e, n, s) {
    super(), this.authCredentials = t2, this.appCheckCredentials = e, this.bo = n, this.M = s, this.Zo = false;
  }
  tu() {
    if (this.Zo)
      throw new Q2(K2.FAILED_PRECONDITION, "The client has already been terminated.");
  }
  ro(t2, e, n) {
    return this.tu(), Promise.all([this.authCredentials.getToken(), this.appCheckCredentials.getToken()]).then(([s, i]) => this.bo.ro(t2, e, n, s, i)).catch((t3) => {
      throw t3.name === "FirebaseError" ? (t3.code === K2.UNAUTHENTICATED && (this.authCredentials.invalidateToken(), this.appCheckCredentials.invalidateToken()), t3) : new Q2(K2.UNKNOWN, t3.toString());
    });
  }
  co(t2, e, n) {
    return this.tu(), Promise.all([this.authCredentials.getToken(), this.appCheckCredentials.getToken()]).then(([s, i]) => this.bo.co(t2, e, n, s, i)).catch((t3) => {
      throw t3.name === "FirebaseError" ? (t3.code === K2.UNAUTHENTICATED && (this.authCredentials.invalidateToken(), this.appCheckCredentials.invalidateToken()), t3) : new Q2(K2.UNKNOWN, t3.toString());
    });
  }
  terminate() {
    this.Zo = true;
  }
};
var Ho = class {
  constructor(t2, e) {
    this.asyncQueue = t2, this.onlineStateHandler = e, this.state = "Unknown", this.eu = 0, this.nu = null, this.su = true;
  }
  iu() {
    this.eu === 0 && (this.ru("Unknown"), this.nu = this.asyncQueue.enqueueAfterDelay("online_state_timeout", 1e4, () => (this.nu = null, this.ou("Backend didn't respond within 10 seconds."), this.ru("Offline"), Promise.resolve())));
  }
  uu(t2) {
    this.state === "Online" ? this.ru("Unknown") : (this.eu++, this.eu >= 1 && (this.au(), this.ou(`Connection failed 1 times. Most recent error: ${t2.toString()}`), this.ru("Offline")));
  }
  set(t2) {
    this.au(), this.eu = 0, t2 === "Online" && (this.su = false), this.ru(t2);
  }
  ru(t2) {
    t2 !== this.state && (this.state = t2, this.onlineStateHandler(t2));
  }
  ou(t2) {
    const e = `Could not reach Cloud Firestore backend. ${t2}
This typically indicates that your device does not have a healthy Internet connection at the moment. The client will operate in offline mode until it is able to successfully connect to the backend.`;
    this.su ? (F2(e), this.su = false) : O2("OnlineStateTracker", e);
  }
  au() {
    this.nu !== null && (this.nu.cancel(), this.nu = null);
  }
};
var Jo = class {
  constructor(t2, e, n, s, i) {
    this.localStore = t2, this.datastore = e, this.asyncQueue = n, this.remoteSyncer = {}, this.cu = [], this.hu = /* @__PURE__ */ new Map(), this.lu = /* @__PURE__ */ new Set(), this.fu = [], this.du = i, this.du.Br((t3) => {
      n.enqueueAndForget(async () => {
        ru(this) && (O2("RemoteStore", "Restarting streams for network reachability change."), await async function(t4) {
          const e2 = G(t4);
          e2.lu.add(4), await Xo(e2), e2._u.set("Unknown"), e2.lu.delete(4), await Yo(e2);
        }(this));
      });
    }), this._u = new Ho(n, s);
  }
};
async function Yo(t2) {
  if (ru(t2))
    for (const e of t2.fu)
      await e(true);
}
async function Xo(t2) {
  for (const e of t2.fu)
    await e(false);
}
function Zo(t2, e) {
  const n = G(t2);
  n.hu.has(e.targetId) || (n.hu.set(e.targetId, e), iu(n) ? su(n) : Au(n).Co() && eu(n, e));
}
function tu(t2, e) {
  const n = G(t2), s = Au(n);
  n.hu.delete(e), s.Co() && nu(n, e), n.hu.size === 0 && (s.Co() ? s.ko() : ru(n) && n._u.set("Unknown"));
}
function eu(t2, e) {
  t2.wu.Z(e.targetId), Au(t2).Qo(e);
}
function nu(t2, e) {
  t2.wu.Z(e), Au(t2).jo(e);
}
function su(t2) {
  t2.wu = new ss({
    getRemoteKeysForTarget: (e) => t2.remoteSyncer.getRemoteKeysForTarget(e),
    Et: (e) => t2.hu.get(e) || null
  }), Au(t2).start(), t2._u.iu();
}
function iu(t2) {
  return ru(t2) && !Au(t2).Do() && t2.hu.size > 0;
}
function ru(t2) {
  return G(t2).lu.size === 0;
}
function ou(t2) {
  t2.wu = void 0;
}
async function uu(t2) {
  t2.hu.forEach((e, n) => {
    eu(t2, e);
  });
}
async function au(t2, e) {
  ou(t2), iu(t2) ? (t2._u.uu(e), su(t2)) : t2._u.set("Unknown");
}
async function cu(t2, e, n) {
  if (t2._u.set("Online"), e instanceof es && e.state === 2 && e.cause)
    try {
      await async function(t3, e2) {
        const n2 = e2.cause;
        for (const s of e2.targetIds)
          t3.hu.has(s) && (await t3.remoteSyncer.rejectListen(s, n2), t3.hu.delete(s), t3.wu.removeTarget(s));
      }(t2, e);
    } catch (n2) {
      O2("RemoteStore", "Failed to remove targets %s: %s ", e.targetIds.join(","), n2), await hu(t2, n2);
    }
  else if (e instanceof Zn ? t2.wu.ut(e) : e instanceof ts ? t2.wu._t(e) : t2.wu.ht(e), !n.isEqual(ct.min()))
    try {
      const e2 = await no(t2.localStore);
      n.compareTo(e2) >= 0 && await function(t3, e3) {
        const n2 = t3.wu.yt(e3);
        return n2.targetChanges.forEach((n3, s) => {
          if (n3.resumeToken.approximateByteSize() > 0) {
            const i = t3.hu.get(s);
            i && t3.hu.set(s, i.withResumeToken(n3.resumeToken, e3));
          }
        }), n2.targetMismatches.forEach((e4) => {
          const n3 = t3.hu.get(e4);
          if (!n3)
            return;
          t3.hu.set(e4, n3.withResumeToken(pt.EMPTY_BYTE_STRING, n3.snapshotVersion)), nu(t3, e4);
          const s = new Di(n3.target, e4, 1, n3.sequenceNumber);
          eu(t3, s);
        }), t3.remoteSyncer.applyRemoteEvent(n2);
      }(t2, n);
    } catch (e2) {
      O2("RemoteStore", "Failed to raise snapshot:", e2), await hu(t2, e2);
    }
}
async function hu(t2, e, n) {
  if (!Ii(e))
    throw e;
  t2.lu.add(1), await Xo(t2), t2._u.set("Offline"), n || (n = () => no(t2.localStore)), t2.asyncQueue.enqueueRetryable(async () => {
    O2("RemoteStore", "Retrying IndexedDB access"), await n(), t2.lu.delete(1), await Yo(t2);
  });
}
function lu(t2, e) {
  return e().catch((n) => hu(t2, n, e));
}
async function fu(t2) {
  const e = G(t2), n = Ru(e);
  let s = e.cu.length > 0 ? e.cu[e.cu.length - 1].batchId : -1;
  for (; du(e); )
    try {
      const t3 = await ro(e.localStore, s);
      if (t3 === null) {
        e.cu.length === 0 && n.ko();
        break;
      }
      s = t3.batchId, _u(e, t3);
    } catch (t3) {
      await hu(e, t3);
    }
  wu(e) && mu(e);
}
function du(t2) {
  return ru(t2) && t2.cu.length < 10;
}
function _u(t2, e) {
  t2.cu.push(e);
  const n = Ru(t2);
  n.Co() && n.zo && n.Ho(e.mutations);
}
function wu(t2) {
  return ru(t2) && !Ru(t2).Do() && t2.cu.length > 0;
}
function mu(t2) {
  Ru(t2).start();
}
async function gu(t2) {
  Ru(t2).Xo();
}
async function yu(t2) {
  const e = Ru(t2);
  for (const n of t2.cu)
    e.Ho(n.mutations);
}
async function pu(t2, e, n) {
  const s = t2.cu.shift(), i = vi.from(s, e, n);
  await lu(t2, () => t2.remoteSyncer.applySuccessfulWrite(i)), await fu(t2);
}
async function Iu(t2, e) {
  e && Ru(t2).zo && await async function(t3, e2) {
    if (n = e2.code, xn(n) && n !== K2.ABORTED) {
      const n2 = t3.cu.shift();
      Ru(t3).No(), await lu(t3, () => t3.remoteSyncer.rejectFailedWrite(n2.batchId, e2)), await fu(t3);
    }
    var n;
  }(t2, e), wu(t2) && mu(t2);
}
async function Tu(t2, e) {
  const n = G(t2);
  n.asyncQueue.verifyOperationInProgress(), O2("RemoteStore", "RemoteStore received new credentials");
  const s = ru(n);
  n.lu.add(3), await Xo(n), s && n._u.set("Unknown"), await n.remoteSyncer.handleCredentialChange(e), n.lu.delete(3), await Yo(n);
}
async function Eu(t2, e) {
  const n = G(t2);
  e ? (n.lu.delete(2), await Yo(n)) : e || (n.lu.add(2), await Xo(n), n._u.set("Unknown"));
}
function Au(t2) {
  return t2.mu || (t2.mu = function(t3, e, n) {
    const s = G(t3);
    return s.tu(), new jo(e, s.bo, s.authCredentials, s.appCheckCredentials, s.M, n);
  }(t2.datastore, t2.asyncQueue, {
    zr: uu.bind(null, t2),
    Jr: au.bind(null, t2),
    Ko: cu.bind(null, t2)
  }), t2.fu.push(async (e) => {
    e ? (t2.mu.No(), iu(t2) ? su(t2) : t2._u.set("Unknown")) : (await t2.mu.stop(), ou(t2));
  })), t2.mu;
}
function Ru(t2) {
  return t2.gu || (t2.gu = function(t3, e, n) {
    const s = G(t3);
    return s.tu(), new Wo(e, s.bo, s.authCredentials, s.appCheckCredentials, s.M, n);
  }(t2.datastore, t2.asyncQueue, {
    zr: gu.bind(null, t2),
    Jr: Iu.bind(null, t2),
    Yo: yu.bind(null, t2),
    Jo: pu.bind(null, t2)
  }), t2.fu.push(async (e) => {
    e ? (t2.gu.No(), await fu(t2)) : (await t2.gu.stop(), t2.cu.length > 0 && (O2("RemoteStore", `Stopping write stream with ${t2.cu.length} pending writes`), t2.cu = []));
  })), t2.gu;
}
var bu = class {
  constructor(t2, e, n, s, i) {
    this.asyncQueue = t2, this.timerId = e, this.targetTimeMs = n, this.op = s, this.removalCallback = i, this.deferred = new j(), this.then = this.deferred.promise.then.bind(this.deferred.promise), this.deferred.promise.catch((t3) => {
    });
  }
  static createAndSchedule(t2, e, n, s, i) {
    const r = Date.now() + n, o = new bu(t2, e, r, s, i);
    return o.start(n), o;
  }
  start(t2) {
    this.timerHandle = setTimeout(() => this.handleDelayElapsed(), t2);
  }
  skipDelay() {
    return this.handleDelayElapsed();
  }
  cancel(t2) {
    this.timerHandle !== null && (this.clearTimeout(), this.deferred.reject(new Q2(K2.CANCELLED, "Operation cancelled" + (t2 ? ": " + t2 : ""))));
  }
  handleDelayElapsed() {
    this.asyncQueue.enqueueAndForget(() => this.timerHandle !== null ? (this.clearTimeout(), this.op().then((t2) => this.deferred.resolve(t2))) : Promise.resolve());
  }
  clearTimeout() {
    this.timerHandle !== null && (this.removalCallback(this), clearTimeout(this.timerHandle), this.timerHandle = null);
  }
};
function Pu(t2, e) {
  if (F2("AsyncQueue", `${e}: ${t2}`), Ii(t2))
    return new Q2(K2.UNAVAILABLE, `${e}: ${t2}`);
  throw t2;
}
var Vu = class {
  constructor(t2) {
    this.comparator = t2 ? (e, n) => t2(e, n) || xt.comparator(e.key, n.key) : (t3, e) => xt.comparator(t3.key, e.key), this.keyedMap = Kn(), this.sortedSet = new Mn(this.comparator);
  }
  static emptySet(t2) {
    return new Vu(t2.comparator);
  }
  has(t2) {
    return this.keyedMap.get(t2) != null;
  }
  get(t2) {
    return this.keyedMap.get(t2);
  }
  first() {
    return this.sortedSet.minKey();
  }
  last() {
    return this.sortedSet.maxKey();
  }
  isEmpty() {
    return this.sortedSet.isEmpty();
  }
  indexOf(t2) {
    const e = this.keyedMap.get(t2);
    return e ? this.sortedSet.indexOf(e) : -1;
  }
  get size() {
    return this.sortedSet.size;
  }
  forEach(t2) {
    this.sortedSet.inorderTraversal((e, n) => (t2(e), false));
  }
  add(t2) {
    const e = this.delete(t2.key);
    return e.copy(e.keyedMap.insert(t2.key, t2), e.sortedSet.insert(t2, null));
  }
  delete(t2) {
    const e = this.get(t2);
    return e ? this.copy(this.keyedMap.remove(t2), this.sortedSet.remove(e)) : this;
  }
  isEqual(t2) {
    if (!(t2 instanceof Vu))
      return false;
    if (this.size !== t2.size)
      return false;
    const e = this.sortedSet.getIterator(), n = t2.sortedSet.getIterator();
    for (; e.hasNext(); ) {
      const t3 = e.getNext().key, s = n.getNext().key;
      if (!t3.isEqual(s))
        return false;
    }
    return true;
  }
  toString() {
    const t2 = [];
    return this.forEach((e) => {
      t2.push(e.toString());
    }), t2.length === 0 ? "DocumentSet ()" : "DocumentSet (\n  " + t2.join("  \n") + "\n)";
  }
  copy(t2, e) {
    const n = new Vu();
    return n.comparator = this.comparator, n.keyedMap = t2, n.sortedSet = e, n;
  }
};
var vu = class {
  constructor() {
    this.yu = new Mn(xt.comparator);
  }
  track(t2) {
    const e = t2.doc.key, n = this.yu.get(e);
    n ? t2.type !== 0 && n.type === 3 ? this.yu = this.yu.insert(e, t2) : t2.type === 3 && n.type !== 1 ? this.yu = this.yu.insert(e, {
      type: n.type,
      doc: t2.doc
    }) : t2.type === 2 && n.type === 2 ? this.yu = this.yu.insert(e, {
      type: 2,
      doc: t2.doc
    }) : t2.type === 2 && n.type === 0 ? this.yu = this.yu.insert(e, {
      type: 0,
      doc: t2.doc
    }) : t2.type === 1 && n.type === 0 ? this.yu = this.yu.remove(e) : t2.type === 1 && n.type === 2 ? this.yu = this.yu.insert(e, {
      type: 1,
      doc: n.doc
    }) : t2.type === 0 && n.type === 1 ? this.yu = this.yu.insert(e, {
      type: 2,
      doc: t2.doc
    }) : L2() : this.yu = this.yu.insert(e, t2);
  }
  pu() {
    const t2 = [];
    return this.yu.inorderTraversal((e, n) => {
      t2.push(n);
    }), t2;
  }
};
var Su = class {
  constructor(t2, e, n, s, i, r, o, u) {
    this.query = t2, this.docs = e, this.oldDocs = n, this.docChanges = s, this.mutatedKeys = i, this.fromCache = r, this.syncStateChanged = o, this.excludesMetadataChanges = u;
  }
  static fromInitialDocuments(t2, e, n, s) {
    const i = [];
    return e.forEach((t3) => {
      i.push({
        type: 0,
        doc: t3
      });
    }), new Su(t2, e, Vu.emptySet(e), i, n, s, true, false);
  }
  get hasPendingWrites() {
    return !this.mutatedKeys.isEmpty();
  }
  isEqual(t2) {
    if (!(this.fromCache === t2.fromCache && this.syncStateChanged === t2.syncStateChanged && this.mutatedKeys.isEqual(t2.mutatedKeys) && qe(this.query, t2.query) && this.docs.isEqual(t2.docs) && this.oldDocs.isEqual(t2.oldDocs)))
      return false;
    const e = this.docChanges, n = t2.docChanges;
    if (e.length !== n.length)
      return false;
    for (let t3 = 0; t3 < e.length; t3++)
      if (e[t3].type !== n[t3].type || !e[t3].doc.isEqual(n[t3].doc))
        return false;
    return true;
  }
};
var Du = class {
  constructor() {
    this.Iu = void 0, this.listeners = [];
  }
};
var Cu = class {
  constructor() {
    this.queries = new kn((t2) => Ge(t2), qe), this.onlineState = "Unknown", this.Tu = /* @__PURE__ */ new Set();
  }
};
async function xu(t2, e) {
  const n = G(t2), s = e.query;
  let i = false, r = n.queries.get(s);
  if (r || (i = true, r = new Du()), i)
    try {
      r.Iu = await n.onListen(s);
    } catch (t3) {
      const n2 = Pu(t3, `Initialization of query '${Ke(e.query)}' failed`);
      return void e.onError(n2);
    }
  if (n.queries.set(s, r), r.listeners.push(e), e.Eu(n.onlineState), r.Iu) {
    e.Au(r.Iu) && Ou(n);
  }
}
async function Nu(t2, e) {
  const n = G(t2), s = e.query;
  let i = false;
  const r = n.queries.get(s);
  if (r) {
    const t3 = r.listeners.indexOf(e);
    t3 >= 0 && (r.listeners.splice(t3, 1), i = r.listeners.length === 0);
  }
  if (i)
    return n.queries.delete(s), n.onUnlisten(s);
}
function ku(t2, e) {
  const n = G(t2);
  let s = false;
  for (const t3 of e) {
    const e2 = t3.query, i = n.queries.get(e2);
    if (i) {
      for (const e3 of i.listeners)
        e3.Au(t3) && (s = true);
      i.Iu = t3;
    }
  }
  s && Ou(n);
}
function Mu(t2, e, n) {
  const s = G(t2), i = s.queries.get(e);
  if (i)
    for (const t3 of i.listeners)
      t3.onError(n);
  s.queries.delete(e);
}
function Ou(t2) {
  t2.Tu.forEach((t3) => {
    t3.next();
  });
}
var Fu = class {
  constructor(t2, e, n) {
    this.query = t2, this.Ru = e, this.bu = false, this.Pu = null, this.onlineState = "Unknown", this.options = n || {};
  }
  Au(t2) {
    if (!this.options.includeMetadataChanges) {
      const e2 = [];
      for (const n of t2.docChanges)
        n.type !== 3 && e2.push(n);
      t2 = new Su(t2.query, t2.docs, t2.oldDocs, e2, t2.mutatedKeys, t2.fromCache, t2.syncStateChanged, true);
    }
    let e = false;
    return this.bu ? this.Vu(t2) && (this.Ru.next(t2), e = true) : this.vu(t2, this.onlineState) && (this.Su(t2), e = true), this.Pu = t2, e;
  }
  onError(t2) {
    this.Ru.error(t2);
  }
  Eu(t2) {
    this.onlineState = t2;
    let e = false;
    return this.Pu && !this.bu && this.vu(this.Pu, t2) && (this.Su(this.Pu), e = true), e;
  }
  vu(t2, e) {
    if (!t2.fromCache)
      return true;
    const n = e !== "Offline";
    return (!this.options.Du || !n) && (!t2.docs.isEmpty() || e === "Offline");
  }
  Vu(t2) {
    if (t2.docChanges.length > 0)
      return true;
    const e = this.Pu && this.Pu.hasPendingWrites !== t2.hasPendingWrites;
    return !(!t2.syncStateChanged && !e) && this.options.includeMetadataChanges === true;
  }
  Su(t2) {
    t2 = Su.fromInitialDocuments(t2.query, t2.docs, t2.mutatedKeys, t2.fromCache), this.bu = true, this.Ru.next(t2);
  }
};
var $u = class {
  constructor(t2, e) {
    this.payload = t2, this.byteLength = e;
  }
  Cu() {
    return "metadata" in this.payload;
  }
};
var Bu = class {
  constructor(t2) {
    this.M = t2;
  }
  li(t2) {
    return ms(this.M, t2);
  }
  fi(t2) {
    return t2.metadata.exists ? Es(this.M, t2.document, false) : te.newNoDocument(this.li(t2.metadata.name), this.di(t2.metadata.readTime));
  }
  di(t2) {
    return fs(t2);
  }
};
var Lu = class {
  constructor(t2, e, n) {
    this.xu = t2, this.localStore = e, this.M = n, this.queries = [], this.documents = [], this.collectionGroups = /* @__PURE__ */ new Set(), this.progress = Uu(t2);
  }
  Nu(t2) {
    this.progress.bytesLoaded += t2.byteLength;
    let e = this.progress.documentsLoaded;
    if (t2.payload.namedQuery)
      this.queries.push(t2.payload.namedQuery);
    else if (t2.payload.documentMetadata) {
      this.documents.push({
        metadata: t2.payload.documentMetadata
      }), t2.payload.documentMetadata.exists || ++e;
      const n = _t.fromString(t2.payload.documentMetadata.name);
      this.collectionGroups.add(n.get(n.length - 2));
    } else
      t2.payload.document && (this.documents[this.documents.length - 1].document = t2.payload.document, ++e);
    return e !== this.progress.documentsLoaded ? (this.progress.documentsLoaded = e, Object.assign({}, this.progress)) : null;
  }
  ku(t2) {
    const e = /* @__PURE__ */ new Map(), n = new Bu(this.M);
    for (const s of t2)
      if (s.metadata.queries) {
        const t3 = n.li(s.metadata.name);
        for (const n2 of s.metadata.queries) {
          const s2 = (e.get(n2) || zn()).add(t3);
          e.set(n2, s2);
        }
      }
    return e;
  }
  async complete() {
    const t2 = await fo(this.localStore, new Bu(this.M), this.documents, this.xu.id), e = this.ku(this.documents);
    for (const t3 of this.queries)
      await _o(this.localStore, t3, e.get(t3.name));
    return this.progress.taskState = "Success", {
      progress: this.progress,
      Mu: this.collectionGroups,
      Ou: t2
    };
  }
};
function Uu(t2) {
  return {
    taskState: "Running",
    documentsLoaded: 0,
    bytesLoaded: 0,
    totalDocuments: t2.totalDocuments,
    totalBytes: t2.totalBytes
  };
}
var qu = class {
  constructor(t2) {
    this.key = t2;
  }
};
var Gu = class {
  constructor(t2) {
    this.key = t2;
  }
};
var Ku = class {
  constructor(t2, e) {
    this.query = t2, this.Fu = e, this.$u = null, this.current = false, this.Bu = zn(), this.mutatedKeys = zn(), this.Lu = We(t2), this.Uu = new Vu(this.Lu);
  }
  get qu() {
    return this.Fu;
  }
  Gu(t2, e) {
    const n = e ? e.Ku : new vu(), s = e ? e.Uu : this.Uu;
    let i = e ? e.mutatedKeys : this.mutatedKeys, r = s, o = false;
    const u = ke(this.query) && s.size === this.query.limit ? s.last() : null, a = Me(this.query) && s.size === this.query.limit ? s.first() : null;
    if (t2.inorderTraversal((t3, e2) => {
      const c = s.get(t3), h = Qe(this.query, e2) ? e2 : null, l2 = !!c && this.mutatedKeys.has(c.key), f = !!h && (h.hasLocalMutations || this.mutatedKeys.has(h.key) && h.hasCommittedMutations);
      let d = false;
      if (c && h) {
        c.data.isEqual(h.data) ? l2 !== f && (n.track({
          type: 3,
          doc: h
        }), d = true) : this.Qu(c, h) || (n.track({
          type: 2,
          doc: h
        }), d = true, (u && this.Lu(h, u) > 0 || a && this.Lu(h, a) < 0) && (o = true));
      } else
        !c && h ? (n.track({
          type: 0,
          doc: h
        }), d = true) : c && !h && (n.track({
          type: 1,
          doc: c
        }), d = true, (u || a) && (o = true));
      d && (h ? (r = r.add(h), i = f ? i.add(t3) : i.delete(t3)) : (r = r.delete(t3), i = i.delete(t3)));
    }), ke(this.query) || Me(this.query))
      for (; r.size > this.query.limit; ) {
        const t3 = ke(this.query) ? r.last() : r.first();
        r = r.delete(t3.key), i = i.delete(t3.key), n.track({
          type: 1,
          doc: t3
        });
      }
    return {
      Uu: r,
      Ku: n,
      ei: o,
      mutatedKeys: i
    };
  }
  Qu(t2, e) {
    return t2.hasLocalMutations && e.hasCommittedMutations && !e.hasLocalMutations;
  }
  applyChanges(t2, e, n) {
    const s = this.Uu;
    this.Uu = t2.Uu, this.mutatedKeys = t2.mutatedKeys;
    const i = t2.Ku.pu();
    i.sort((t3, e2) => function(t4, e3) {
      const n2 = (t5) => {
        switch (t5) {
          case 0:
            return 1;
          case 2:
          case 3:
            return 2;
          case 1:
            return 0;
          default:
            return L2();
        }
      };
      return n2(t4) - n2(e3);
    }(t3.type, e2.type) || this.Lu(t3.doc, e2.doc)), this.ju(n);
    const r = e ? this.Wu() : [], o = this.Bu.size === 0 && this.current ? 1 : 0, u = o !== this.$u;
    if (this.$u = o, i.length !== 0 || u) {
      return {
        snapshot: new Su(this.query, t2.Uu, s, i, t2.mutatedKeys, o === 0, u, false),
        zu: r
      };
    }
    return {
      zu: r
    };
  }
  Eu(t2) {
    return this.current && t2 === "Offline" ? (this.current = false, this.applyChanges({
      Uu: this.Uu,
      Ku: new vu(),
      mutatedKeys: this.mutatedKeys,
      ei: false
    }, false)) : {
      zu: []
    };
  }
  Hu(t2) {
    return !this.Fu.has(t2) && (!!this.Uu.has(t2) && !this.Uu.get(t2).hasLocalMutations);
  }
  ju(t2) {
    t2 && (t2.addedDocuments.forEach((t3) => this.Fu = this.Fu.add(t3)), t2.modifiedDocuments.forEach((t3) => {
    }), t2.removedDocuments.forEach((t3) => this.Fu = this.Fu.delete(t3)), this.current = t2.current);
  }
  Wu() {
    if (!this.current)
      return [];
    const t2 = this.Bu;
    this.Bu = zn(), this.Uu.forEach((t3) => {
      this.Hu(t3.key) && (this.Bu = this.Bu.add(t3.key));
    });
    const e = [];
    return t2.forEach((t3) => {
      this.Bu.has(t3) || e.push(new Gu(t3));
    }), this.Bu.forEach((n) => {
      t2.has(n) || e.push(new qu(n));
    }), e;
  }
  Ju(t2) {
    this.Fu = t2.hi, this.Bu = zn();
    const e = this.Gu(t2.documents);
    return this.applyChanges(e, true);
  }
  Yu() {
    return Su.fromInitialDocuments(this.query, this.Uu, this.mutatedKeys, this.$u === 0);
  }
};
var Qu = class {
  constructor(t2, e, n) {
    this.query = t2, this.targetId = e, this.view = n;
  }
};
var ju = class {
  constructor(t2) {
    this.key = t2, this.Xu = false;
  }
};
var Wu = class {
  constructor(t2, e, n, s, i, r) {
    this.localStore = t2, this.remoteStore = e, this.eventManager = n, this.sharedClientState = s, this.currentUser = i, this.maxConcurrentLimboResolutions = r, this.Zu = {}, this.ta = new kn((t3) => Ge(t3), qe), this.ea = /* @__PURE__ */ new Map(), this.na = /* @__PURE__ */ new Set(), this.sa = new Mn(xt.comparator), this.ia = /* @__PURE__ */ new Map(), this.ra = new go(), this.oa = {}, this.ua = /* @__PURE__ */ new Map(), this.aa = Er.gn(), this.onlineState = "Unknown", this.ca = void 0;
  }
  get isPrimaryClient() {
    return this.ca === true;
  }
};
async function zu(t2, e) {
  const n = Aa2(t2);
  let s, i;
  const r = n.ta.get(e);
  if (r)
    s = r.targetId, n.sharedClientState.addLocalQueryTarget(s), i = r.view.Yu();
  else {
    const t3 = await oo(n.localStore, Le(e));
    n.isPrimaryClient && Zo(n.remoteStore, t3);
    const r2 = n.sharedClientState.addLocalQueryTarget(t3.targetId);
    s = t3.targetId, i = await Hu(n, e, s, r2 === "current");
  }
  return i;
}
async function Hu(t2, e, n, s) {
  t2.ha = (e2, n2, s2) => async function(t3, e3, n3, s3) {
    let i2 = e3.view.Gu(n3);
    i2.ei && (i2 = await ao(t3.localStore, e3.query, false).then(({ documents: t4 }) => e3.view.Gu(t4, i2)));
    const r2 = s3 && s3.targetChanges.get(e3.targetId), o2 = e3.view.applyChanges(i2, t3.isPrimaryClient, r2);
    return aa2(t3, e3.targetId, o2.zu), o2.snapshot;
  }(t2, e2, n2, s2);
  const i = await ao(t2.localStore, e, true), r = new Ku(e, i.hi), o = r.Gu(i.documents), u = Xn.createSynthesizedTargetChangeForCurrentChange(n, s && t2.onlineState !== "Offline"), a = r.applyChanges(o, t2.isPrimaryClient, u);
  aa2(t2, n, a.zu);
  const c = new Qu(e, n, r);
  return t2.ta.set(e, c), t2.ea.has(n) ? t2.ea.get(n).push(e) : t2.ea.set(n, [e]), a.snapshot;
}
async function Ju(t2, e) {
  const n = G(t2), s = n.ta.get(e), i = n.ea.get(s.targetId);
  if (i.length > 1)
    return n.ea.set(s.targetId, i.filter((t3) => !qe(t3, e))), void n.ta.delete(e);
  if (n.isPrimaryClient) {
    n.sharedClientState.removeLocalQueryTarget(s.targetId);
    n.sharedClientState.isActiveQueryTarget(s.targetId) || await uo(n.localStore, s.targetId, false).then(() => {
      n.sharedClientState.clearQueryState(s.targetId), tu(n.remoteStore, s.targetId), oa2(n, s.targetId);
    }).catch(Vr);
  } else
    oa2(n, s.targetId), await uo(n.localStore, s.targetId, true);
}
async function Yu(t2, e, n) {
  const s = Ra2(t2);
  try {
    const t3 = await function(t4, e2) {
      const n2 = G(t4), s2 = at.now(), i = e2.reduce((t5, e3) => t5.add(e3.key), zn());
      let r;
      return n2.persistence.runTransaction("Locally write mutations", "readwrite", (t5) => n2.ai.qs(t5, i).next((i2) => {
        r = i2;
        const o = [];
        for (const t6 of e2) {
          const e3 = pn(t6, r.get(t6.key));
          e3 != null && o.push(new An(t6.key, e3, Zt(e3.value.mapValue), _n.exists(true)));
        }
        return n2.$s.addMutationBatch(t5, s2, o, e2);
      })).then((t5) => (t5.applyToLocalDocumentSet(r), {
        batchId: t5.batchId,
        changes: r
      }));
    }(s.localStore, e);
    s.sharedClientState.addPendingMutation(t3.batchId), function(t4, e2, n2) {
      let s2 = t4.oa[t4.currentUser.toKey()];
      s2 || (s2 = new Mn(rt));
      s2 = s2.insert(e2, n2), t4.oa[t4.currentUser.toKey()] = s2;
    }(s, t3.batchId, n), await la2(s, t3.changes), await fu(s.remoteStore);
  } catch (t3) {
    const e2 = Pu(t3, "Failed to persist write");
    n.reject(e2);
  }
}
async function Xu(t2, e) {
  const n = G(t2);
  try {
    const t3 = await so(n.localStore, e);
    e.targetChanges.forEach((t4, e2) => {
      const s = n.ia.get(e2);
      s && (U2(t4.addedDocuments.size + t4.modifiedDocuments.size + t4.removedDocuments.size <= 1), t4.addedDocuments.size > 0 ? s.Xu = true : t4.modifiedDocuments.size > 0 ? U2(s.Xu) : t4.removedDocuments.size > 0 && (U2(s.Xu), s.Xu = false));
    }), await la2(n, t3, e);
  } catch (t3) {
    await Vr(t3);
  }
}
function Zu(t2, e, n) {
  const s = G(t2);
  if (s.isPrimaryClient && n === 0 || !s.isPrimaryClient && n === 1) {
    const t3 = [];
    s.ta.forEach((n2, s2) => {
      const i = s2.view.Eu(e);
      i.snapshot && t3.push(i.snapshot);
    }), function(t4, e2) {
      const n2 = G(t4);
      n2.onlineState = e2;
      let s2 = false;
      n2.queries.forEach((t5, n3) => {
        for (const t6 of n3.listeners)
          t6.Eu(e2) && (s2 = true);
      }), s2 && Ou(n2);
    }(s.eventManager, e), t3.length && s.Zu.Ko(t3), s.onlineState = e, s.isPrimaryClient && s.sharedClientState.setOnlineState(e);
  }
}
async function ta2(t2, e, n) {
  const s = G(t2);
  s.sharedClientState.updateQueryState(e, "rejected", n);
  const i = s.ia.get(e), r = i && i.key;
  if (r) {
    let t3 = new Mn(xt.comparator);
    t3 = t3.insert(r, te.newNoDocument(r, ct.min()));
    const n2 = zn().add(r), i2 = new Yn(ct.min(), /* @__PURE__ */ new Map(), new $n(rt), t3, n2);
    await Xu(s, i2), s.sa = s.sa.remove(r), s.ia.delete(e), ha2(s);
  } else
    await uo(s.localStore, e, false).then(() => oa2(s, e, n)).catch(Vr);
}
async function ea2(t2, e) {
  const n = G(t2), s = e.batch.batchId;
  try {
    const t3 = await eo(n.localStore, e);
    ra2(n, s, null), ia2(n, s), n.sharedClientState.updateMutationState(s, "acknowledged"), await la2(n, t3);
  } catch (t3) {
    await Vr(t3);
  }
}
async function na2(t2, e, n) {
  const s = G(t2);
  try {
    const t3 = await function(t4, e2) {
      const n2 = G(t4);
      return n2.persistence.runTransaction("Reject batch", "readwrite-primary", (t5) => {
        let s2;
        return n2.$s.lookupMutationBatch(t5, e2).next((e3) => (U2(e3 !== null), s2 = e3.keys(), n2.$s.removeMutationBatch(t5, e3))).next(() => n2.$s.performConsistencyCheck(t5)).next(() => n2.ai.qs(t5, s2));
      });
    }(s.localStore, e);
    ra2(s, e, n), ia2(s, e), s.sharedClientState.updateMutationState(e, "rejected", n), await la2(s, t3);
  } catch (n2) {
    await Vr(n2);
  }
}
async function sa2(t2, e) {
  const n = G(t2);
  ru(n.remoteStore) || O2("SyncEngine", "The network is disabled. The task returned by 'awaitPendingWrites()' will not complete until the network is enabled.");
  try {
    const t3 = await function(t4) {
      const e2 = G(t4);
      return e2.persistence.runTransaction("Get highest unacknowledged batch id", "readonly", (t5) => e2.$s.getHighestUnacknowledgedBatchId(t5));
    }(n.localStore);
    if (t3 === -1)
      return void e.resolve();
    const s = n.ua.get(t3) || [];
    s.push(e), n.ua.set(t3, s);
  } catch (t3) {
    const n2 = Pu(t3, "Initialization of waitForPendingWrites() operation failed");
    e.reject(n2);
  }
}
function ia2(t2, e) {
  (t2.ua.get(e) || []).forEach((t3) => {
    t3.resolve();
  }), t2.ua.delete(e);
}
function ra2(t2, e, n) {
  const s = G(t2);
  let i = s.oa[s.currentUser.toKey()];
  if (i) {
    const t3 = i.get(e);
    t3 && (n ? t3.reject(n) : t3.resolve(), i = i.remove(e)), s.oa[s.currentUser.toKey()] = i;
  }
}
function oa2(t2, e, n = null) {
  t2.sharedClientState.removeLocalQueryTarget(e);
  for (const s of t2.ea.get(e))
    t2.ta.delete(s), n && t2.Zu.la(s, n);
  if (t2.ea.delete(e), t2.isPrimaryClient) {
    t2.ra.Ri(e).forEach((e2) => {
      t2.ra.containsKey(e2) || ua2(t2, e2);
    });
  }
}
function ua2(t2, e) {
  t2.na.delete(e.path.canonicalString());
  const n = t2.sa.get(e);
  n !== null && (tu(t2.remoteStore, n), t2.sa = t2.sa.remove(e), t2.ia.delete(n), ha2(t2));
}
function aa2(t2, e, n) {
  for (const s of n)
    if (s instanceof qu)
      t2.ra.addReference(s.key, e), ca(t2, s);
    else if (s instanceof Gu) {
      O2("SyncEngine", "Document no longer in limbo: " + s.key), t2.ra.removeReference(s.key, e);
      t2.ra.containsKey(s.key) || ua2(t2, s.key);
    } else
      L2();
}
function ca(t2, e) {
  const n = e.key, s = n.path.canonicalString();
  t2.sa.get(n) || t2.na.has(s) || (O2("SyncEngine", "New document in limbo: " + n), t2.na.add(s), ha2(t2));
}
function ha2(t2) {
  for (; t2.na.size > 0 && t2.sa.size < t2.maxConcurrentLimboResolutions; ) {
    const e = t2.na.values().next().value;
    t2.na.delete(e);
    const n = new xt(_t.fromString(e)), s = t2.aa.next();
    t2.ia.set(s, new ju(n)), t2.sa = t2.sa.insert(n, s), Zo(t2.remoteStore, new Di(Le(Ne(n.path)), s, 2, nt.A));
  }
}
async function la2(t2, e, n) {
  const s = G(t2), i = [], r = [], o = [];
  s.ta.isEmpty() || (s.ta.forEach((t3, u) => {
    o.push(s.ha(u, e, n).then((t4) => {
      if (t4) {
        s.isPrimaryClient && s.sharedClientState.updateQueryState(u.targetId, t4.fromCache ? "not-current" : "current"), i.push(t4);
        const e2 = Jr.Js(u.targetId, t4);
        r.push(e2);
      }
    }));
  }), await Promise.all(o), s.Zu.Ko(i), await async function(t3, e2) {
    const n2 = G(t3);
    try {
      await n2.persistence.runTransaction("notifyLocalViewChanges", "readwrite", (t4) => wi.forEach(e2, (e3) => wi.forEach(e3.zs, (s2) => n2.persistence.referenceDelegate.addReference(t4, e3.targetId, s2)).next(() => wi.forEach(e3.Hs, (s2) => n2.persistence.referenceDelegate.removeReference(t4, e3.targetId, s2)))));
    } catch (t4) {
      if (!Ii(t4))
        throw t4;
      O2("LocalStore", "Failed to update sequence numbers: " + t4);
    }
    for (const t4 of e2) {
      const e3 = t4.targetId;
      if (!t4.fromCache) {
        const t5 = n2.si.get(e3), s2 = t5.snapshotVersion, i2 = t5.withLastLimboFreeSnapshotVersion(s2);
        n2.si = n2.si.insert(e3, i2);
      }
    }
  }(s.localStore, r));
}
async function fa2(t2, e) {
  const n = G(t2);
  if (!n.currentUser.isEqual(e)) {
    O2("SyncEngine", "User change. New user:", e.toKey());
    const t3 = await to(n.localStore, e);
    n.currentUser = e, function(t4, e2) {
      t4.ua.forEach((t5) => {
        t5.forEach((t6) => {
          t6.reject(new Q2(K2.CANCELLED, e2));
        });
      }), t4.ua.clear();
    }(n, "'waitForPendingWrites' promise is rejected due to a user change."), n.sharedClientState.handleUserChange(e, t3.removedBatchIds, t3.addedBatchIds), await la2(n, t3.ci);
  }
}
function da2(t2, e) {
  const n = G(t2), s = n.ia.get(e);
  if (s && s.Xu)
    return zn().add(s.key);
  {
    let t3 = zn();
    const s2 = n.ea.get(e);
    if (!s2)
      return t3;
    for (const e2 of s2) {
      const s3 = n.ta.get(e2);
      t3 = t3.unionWith(s3.view.qu);
    }
    return t3;
  }
}
async function _a(t2, e) {
  const n = G(t2), s = await ao(n.localStore, e.query, true), i = e.view.Ju(s);
  return n.isPrimaryClient && aa2(n, e.targetId, i.zu), i;
}
async function wa(t2, e) {
  const n = G(t2);
  return ho(n.localStore, e).then((t3) => la2(n, t3));
}
async function ma2(t2, e, n, s) {
  const i = G(t2), r = await function(t3, e2) {
    const n2 = G(t3), s2 = G(n2.$s);
    return n2.persistence.runTransaction("Lookup mutation documents", "readonly", (t4) => s2.ln(t4, e2).next((e3) => e3 ? n2.ai.qs(t4, e3) : wi.resolve(null)));
  }(i.localStore, e);
  r !== null ? (n === "pending" ? await fu(i.remoteStore) : n === "acknowledged" || n === "rejected" ? (ra2(i, e, s || null), ia2(i, e), function(t3, e2) {
    G(G(t3).$s).dn(e2);
  }(i.localStore, e)) : L2(), await la2(i, r)) : O2("SyncEngine", "Cannot apply mutation batch with id: " + e);
}
async function ga(t2, e) {
  const n = G(t2);
  if (Aa2(n), Ra2(n), e === true && n.ca !== true) {
    const t3 = n.sharedClientState.getAllActiveQueryTargets(), e2 = await ya2(n, t3.toArray());
    n.ca = true, await Eu(n.remoteStore, true);
    for (const t4 of e2)
      Zo(n.remoteStore, t4);
  } else if (e === false && n.ca !== false) {
    const t3 = [];
    let e2 = Promise.resolve();
    n.ea.forEach((s, i) => {
      n.sharedClientState.isLocalQueryTarget(i) ? t3.push(i) : e2 = e2.then(() => (oa2(n, i), uo(n.localStore, i, true))), tu(n.remoteStore, i);
    }), await e2, await ya2(n, t3), function(t4) {
      const e3 = G(t4);
      e3.ia.forEach((t5, n2) => {
        tu(e3.remoteStore, n2);
      }), e3.ra.bi(), e3.ia = /* @__PURE__ */ new Map(), e3.sa = new Mn(xt.comparator);
    }(n), n.ca = false, await Eu(n.remoteStore, false);
  }
}
async function ya2(t2, e, n) {
  const s = G(t2), i = [], r = [];
  for (const t3 of e) {
    let e2;
    const n2 = s.ea.get(t3);
    if (n2 && n2.length !== 0) {
      e2 = await oo(s.localStore, Le(n2[0]));
      for (const t4 of n2) {
        const e3 = s.ta.get(t4), n3 = await _a(s, e3);
        n3.snapshot && r.push(n3.snapshot);
      }
    } else {
      const n3 = await co(s.localStore, t3);
      e2 = await oo(s.localStore, n3), await Hu(s, pa2(n3), t3, false);
    }
    i.push(e2);
  }
  return s.Zu.Ko(r), i;
}
function pa2(t2) {
  return xe(t2.path, t2.collectionGroup, t2.orderBy, t2.filters, t2.limit, "F", t2.startAt, t2.endAt);
}
function Ia2(t2) {
  const e = G(t2);
  return G(G(e.localStore).persistence).Os();
}
async function Ta(t2, e, n, s) {
  const i = G(t2);
  if (i.ca)
    return void O2("SyncEngine", "Ignoring unexpected query state notification.");
  const r = i.ea.get(e);
  if (r && r.length > 0)
    switch (n) {
      case "current":
      case "not-current": {
        const t3 = await ho(i.localStore, je(r[0])), s2 = Yn.createSynthesizedRemoteEventForCurrentChange(e, n === "current");
        await la2(i, t3, s2);
        break;
      }
      case "rejected":
        await uo(i.localStore, e, true), oa2(i, e, s);
        break;
      default:
        L2();
    }
}
async function Ea(t2, e, n) {
  const s = Aa2(t2);
  if (s.ca) {
    for (const t3 of e) {
      if (s.ea.has(t3)) {
        O2("SyncEngine", "Adding an already active target " + t3);
        continue;
      }
      const e2 = await co(s.localStore, t3), n2 = await oo(s.localStore, e2);
      await Hu(s, pa2(e2), n2.targetId, false), Zo(s.remoteStore, n2);
    }
    for (const t3 of n)
      s.ea.has(t3) && await uo(s.localStore, t3, false).then(() => {
        tu(s.remoteStore, t3), oa2(s, t3);
      }).catch(Vr);
  }
}
function Aa2(t2) {
  const e = G(t2);
  return e.remoteStore.remoteSyncer.applyRemoteEvent = Xu.bind(null, e), e.remoteStore.remoteSyncer.getRemoteKeysForTarget = da2.bind(null, e), e.remoteStore.remoteSyncer.rejectListen = ta2.bind(null, e), e.Zu.Ko = ku.bind(null, e.eventManager), e.Zu.la = Mu.bind(null, e.eventManager), e;
}
function Ra2(t2) {
  const e = G(t2);
  return e.remoteStore.remoteSyncer.applySuccessfulWrite = ea2.bind(null, e), e.remoteStore.remoteSyncer.rejectFailedWrite = na2.bind(null, e), e;
}
function ba2(t2, e, n) {
  const s = G(t2);
  (async function(t3, e2, n2) {
    try {
      const s2 = await e2.getMetadata();
      if (await function(t4, e3) {
        const n3 = G(t4), s3 = fs(e3.createTime);
        return n3.persistence.runTransaction("hasNewerBundle", "readonly", (t5) => n3.ds.getBundleMetadata(t5, e3.id)).then((t5) => !!t5 && t5.createTime.compareTo(s3) >= 0);
      }(t3.localStore, s2))
        return await e2.close(), n2._completeWith(function(t4) {
          return {
            taskState: "Success",
            documentsLoaded: t4.totalDocuments,
            bytesLoaded: t4.totalBytes,
            totalDocuments: t4.totalDocuments,
            totalBytes: t4.totalBytes
          };
        }(s2)), Promise.resolve(/* @__PURE__ */ new Set());
      n2._updateProgress(Uu(s2));
      const i = new Lu(s2, t3.localStore, e2.M);
      let r = await e2.fa();
      for (; r; ) {
        const t4 = await i.Nu(r);
        t4 && n2._updateProgress(t4), r = await e2.fa();
      }
      const o = await i.complete();
      return await la2(t3, o.Ou, void 0), await function(t4, e3) {
        const n3 = G(t4);
        return n3.persistence.runTransaction("Save bundle", "readwrite", (t5) => n3.ds.saveBundleMetadata(t5, e3));
      }(t3.localStore, s2), n2._completeWith(o.progress), Promise.resolve(o.Mu);
    } catch (t4) {
      return $("SyncEngine", `Loading bundle failed with ${t4}`), n2._failWith(t4), Promise.resolve(/* @__PURE__ */ new Set());
    }
  })(s, e, n).then((t3) => {
    s.sharedClientState.notifyBundleLoaded(t3);
  });
}
var Pa = class {
  constructor() {
    this.synchronizeTabs = false;
  }
  async initialize(t2) {
    this.M = Go(t2.databaseInfo.databaseId), this.sharedClientState = this.da(t2), this.persistence = this._a(t2), await this.persistence.start(), this.gcScheduler = this.wa(t2), this.localStore = this.ma(t2);
  }
  wa(t2) {
    return null;
  }
  ma(t2) {
    return Zr(this.persistence, new Yr(), t2.initialUser, this.M);
  }
  _a(t2) {
    return new Ao(bo.Wi, this.M);
  }
  da(t2) {
    return new Mo();
  }
  async terminate() {
    this.gcScheduler && this.gcScheduler.stop(), await this.sharedClientState.shutdown(), await this.persistence.shutdown();
  }
};
var Va2 = class extends Pa {
  constructor(t2, e, n) {
    super(), this.ga = t2, this.cacheSizeBytes = e, this.forceOwnership = n, this.synchronizeTabs = false;
  }
  async initialize(t2) {
    await super.initialize(t2), await this.ga.initialize(this, t2), await Ra2(this.ga.syncEngine), await fu(this.ga.remoteStore), await this.persistence.Is(() => (this.gcScheduler && !this.gcScheduler.started && this.gcScheduler.start(this.localStore), Promise.resolve()));
  }
  ma(t2) {
    return Zr(this.persistence, new Yr(), t2.initialUser, this.M);
  }
  wa(t2) {
    const e = this.persistence.referenceDelegate.garbageCollector;
    return new Dr(e, t2.asyncQueue);
  }
  _a(t2) {
    const e = zr(t2.databaseInfo.databaseId, t2.databaseInfo.persistenceKey), n = this.cacheSizeBytes !== void 0 ? _r.withCacheSize(this.cacheSizeBytes) : _r.DEFAULT;
    return new Qr(this.synchronizeTabs, e, t2.clientId, n, t2.asyncQueue, Uo(), qo(), this.M, this.sharedClientState, !!this.forceOwnership);
  }
  da(t2) {
    return new Mo();
  }
};
var va = class extends Va2 {
  constructor(t2, e) {
    super(t2, e, false), this.ga = t2, this.cacheSizeBytes = e, this.synchronizeTabs = true;
  }
  async initialize(t2) {
    await super.initialize(t2);
    const e = this.ga.syncEngine;
    this.sharedClientState instanceof ko && (this.sharedClientState.syncEngine = {
      kr: ma2.bind(null, e),
      Mr: Ta.bind(null, e),
      Or: Ea.bind(null, e),
      Os: Ia2.bind(null, e),
      Nr: wa.bind(null, e)
    }, await this.sharedClientState.start()), await this.persistence.Is(async (t3) => {
      await ga(this.ga.syncEngine, t3), this.gcScheduler && (t3 && !this.gcScheduler.started ? this.gcScheduler.start(this.localStore) : t3 || this.gcScheduler.stop());
    });
  }
  da(t2) {
    const e = Uo();
    if (!ko.vt(e))
      throw new Q2(K2.UNIMPLEMENTED, "IndexedDB persistence is only available on platforms that support LocalStorage.");
    const n = zr(t2.databaseInfo.databaseId, t2.databaseInfo.persistenceKey);
    return new ko(e, t2.asyncQueue, n, t2.clientId, t2.initialUser);
  }
};
var Sa2 = class {
  async initialize(t2, e) {
    this.localStore || (this.localStore = t2.localStore, this.sharedClientState = t2.sharedClientState, this.datastore = this.createDatastore(e), this.remoteStore = this.createRemoteStore(e), this.eventManager = this.createEventManager(e), this.syncEngine = this.createSyncEngine(e, !t2.synchronizeTabs), this.sharedClientState.onlineStateHandler = (t3) => Zu(this.syncEngine, t3, 1), this.remoteStore.remoteSyncer.handleCredentialChange = fa2.bind(null, this.syncEngine), await Eu(this.remoteStore, this.syncEngine.isPrimaryClient));
  }
  createEventManager(t2) {
    return new Cu();
  }
  createDatastore(t2) {
    const e = Go(t2.databaseInfo.databaseId), n = (s = t2.databaseInfo, new Lo(s));
    var s;
    return function(t3, e2, n2, s2) {
      return new zo(t3, e2, n2, s2);
    }(t2.authCredentials, t2.appCheckCredentials, n, e);
  }
  createRemoteStore(t2) {
    return e = this.localStore, n = this.datastore, s = t2.asyncQueue, i = (t3) => Zu(this.syncEngine, t3, 0), r = Fo.vt() ? new Fo() : new Oo(), new Jo(e, n, s, i, r);
    var e, n, s, i, r;
  }
  createSyncEngine(t2, e) {
    return function(t3, e2, n, s, i, r, o) {
      const u = new Wu(t3, e2, n, s, i, r);
      return o && (u.ca = true), u;
    }(this.localStore, this.remoteStore, this.eventManager, this.sharedClientState, t2.initialUser, t2.maxConcurrentLimboResolutions, e);
  }
  terminate() {
    return async function(t2) {
      const e = G(t2);
      O2("RemoteStore", "RemoteStore shutting down."), e.lu.add(5), await Xo(e), e.du.shutdown(), e._u.set("Unknown");
    }(this.remoteStore);
  }
};
function Da(t2, e = 10240) {
  let n = 0;
  return {
    async read() {
      if (n < t2.byteLength) {
        const s = {
          value: t2.slice(n, n + e),
          done: false
        };
        return n += e, s;
      }
      return {
        done: true
      };
    },
    async cancel() {
    },
    releaseLock() {
    },
    closed: Promise.reject("unimplemented")
  };
}
var Ca2 = class {
  constructor(t2) {
    this.observer = t2, this.muted = false;
  }
  next(t2) {
    this.observer.next && this.ya(this.observer.next, t2);
  }
  error(t2) {
    this.observer.error ? this.ya(this.observer.error, t2) : console.error("Uncaught Error in snapshot listener:", t2);
  }
  pa() {
    this.muted = true;
  }
  ya(t2, e) {
    this.muted || setTimeout(() => {
      this.muted || t2(e);
    }, 0);
  }
};
var xa2 = class {
  constructor(t2, e) {
    this.Ia = t2, this.M = e, this.metadata = new j(), this.buffer = new Uint8Array(), this.Ta = new TextDecoder("utf-8"), this.Ea().then((t3) => {
      t3 && t3.Cu() ? this.metadata.resolve(t3.payload.metadata) : this.metadata.reject(new Error(`The first element of the bundle is not a metadata, it is
             ${JSON.stringify(t3 == null ? void 0 : t3.payload)}`));
    }, (t3) => this.metadata.reject(t3));
  }
  close() {
    return this.Ia.cancel();
  }
  async getMetadata() {
    return this.metadata.promise;
  }
  async fa() {
    return await this.getMetadata(), this.Ea();
  }
  async Ea() {
    const t2 = await this.Aa();
    if (t2 === null)
      return null;
    const e = this.Ta.decode(t2), n = Number(e);
    isNaN(n) && this.Ra(`length string (${e}) is not valid number`);
    const s = await this.ba(n);
    return new $u(JSON.parse(s), t2.length + n);
  }
  Pa() {
    return this.buffer.findIndex((t2) => t2 === "{".charCodeAt(0));
  }
  async Aa() {
    for (; this.Pa() < 0; ) {
      if (await this.Va())
        break;
    }
    if (this.buffer.length === 0)
      return null;
    const t2 = this.Pa();
    t2 < 0 && this.Ra("Reached the end of bundle when a length string is expected.");
    const e = this.buffer.slice(0, t2);
    return this.buffer = this.buffer.slice(t2), e;
  }
  async ba(t2) {
    for (; this.buffer.length < t2; ) {
      await this.Va() && this.Ra("Reached the end of bundle when more is expected.");
    }
    const e = this.Ta.decode(this.buffer.slice(0, t2));
    return this.buffer = this.buffer.slice(t2), e;
  }
  Ra(t2) {
    throw this.Ia.cancel(), new Error(`Invalid bundle format: ${t2}`);
  }
  async Va() {
    const t2 = await this.Ia.read();
    if (!t2.done) {
      const e = new Uint8Array(this.buffer.length + t2.value.length);
      e.set(this.buffer), e.set(t2.value, this.buffer.length), this.buffer = e;
    }
    return t2.done;
  }
};
var Na2 = class {
  constructor(t2) {
    this.datastore = t2, this.readVersions = /* @__PURE__ */ new Map(), this.mutations = [], this.committed = false, this.lastWriteError = null, this.writtenDocs = /* @__PURE__ */ new Set();
  }
  async lookup(t2) {
    if (this.ensureCommitNotCalled(), this.mutations.length > 0)
      throw new Q2(K2.INVALID_ARGUMENT, "Firestore transactions require all reads to be executed before all writes.");
    const e = await async function(t3, e2) {
      const n = G(t3), s = ps(n.M) + "/documents", i = {
        documents: e2.map((t4) => ws(n.M, t4))
      }, r = await n.co("BatchGetDocuments", s, i), o = /* @__PURE__ */ new Map();
      r.forEach((t4) => {
        const e3 = As(n.M, t4);
        o.set(e3.key.toString(), e3);
      });
      const u = [];
      return e2.forEach((t4) => {
        const e3 = o.get(t4.toString());
        U2(!!e3), u.push(e3);
      }), u;
    }(this.datastore, t2);
    return e.forEach((t3) => this.recordVersion(t3)), e;
  }
  set(t2, e) {
    this.write(e.toMutation(t2, this.precondition(t2))), this.writtenDocs.add(t2.toString());
  }
  update(t2, e) {
    try {
      this.write(e.toMutation(t2, this.preconditionForUpdate(t2)));
    } catch (t3) {
      this.lastWriteError = t3;
    }
    this.writtenDocs.add(t2.toString());
  }
  delete(t2) {
    this.write(new Vn(t2, this.precondition(t2))), this.writtenDocs.add(t2.toString());
  }
  async commit() {
    if (this.ensureCommitNotCalled(), this.lastWriteError)
      throw this.lastWriteError;
    const t2 = this.readVersions;
    this.mutations.forEach((e) => {
      t2.delete(e.key.toString());
    }), t2.forEach((t3, e) => {
      const n = xt.fromPath(e);
      this.mutations.push(new vn(n, this.precondition(n)));
    }), await async function(t3, e) {
      const n = G(t3), s = ps(n.M) + "/documents", i = {
        writes: e.map((t4) => bs(n.M, t4))
      };
      await n.ro("Commit", s, i);
    }(this.datastore, this.mutations), this.committed = true;
  }
  recordVersion(t2) {
    let e;
    if (t2.isFoundDocument())
      e = t2.version;
    else {
      if (!t2.isNoDocument())
        throw L2();
      e = ct.min();
    }
    const n = this.readVersions.get(t2.key.toString());
    if (n) {
      if (!e.isEqual(n))
        throw new Q2(K2.ABORTED, "Document version changed between two reads.");
    } else
      this.readVersions.set(t2.key.toString(), e);
  }
  precondition(t2) {
    const e = this.readVersions.get(t2.toString());
    return !this.writtenDocs.has(t2.toString()) && e ? _n.updateTime(e) : _n.none();
  }
  preconditionForUpdate(t2) {
    const e = this.readVersions.get(t2.toString());
    if (!this.writtenDocs.has(t2.toString()) && e) {
      if (e.isEqual(ct.min()))
        throw new Q2(K2.INVALID_ARGUMENT, "Can't update a document that doesn't exist.");
      return _n.updateTime(e);
    }
    return _n.exists(true);
  }
  write(t2) {
    this.ensureCommitNotCalled(), this.mutations.push(t2);
  }
  ensureCommitNotCalled() {
  }
};
var ka2 = class {
  constructor(t2, e, n, s) {
    this.asyncQueue = t2, this.datastore = e, this.updateFunction = n, this.deferred = s, this.va = 5, this.So = new Ko(this.asyncQueue, "transaction_retry");
  }
  run() {
    this.va -= 1, this.Sa();
  }
  Sa() {
    this.So.Io(async () => {
      const t2 = new Na2(this.datastore), e = this.Da(t2);
      e && e.then((e2) => {
        this.asyncQueue.enqueueAndForget(() => t2.commit().then(() => {
          this.deferred.resolve(e2);
        }).catch((t3) => {
          this.Ca(t3);
        }));
      }).catch((t3) => {
        this.Ca(t3);
      });
    });
  }
  Da(t2) {
    try {
      const e = this.updateFunction(t2);
      return !St(e) && e.catch && e.then ? e : (this.deferred.reject(Error("Transaction callback must return a Promise")), null);
    } catch (t3) {
      return this.deferred.reject(t3), null;
    }
  }
  Ca(t2) {
    this.va > 0 && this.xa(t2) ? (this.va -= 1, this.asyncQueue.enqueueAndForget(() => (this.Sa(), Promise.resolve()))) : this.deferred.reject(t2);
  }
  xa(t2) {
    if (t2.name === "FirebaseError") {
      const e = t2.code;
      return e === "aborted" || e === "failed-precondition" || !xn(e);
    }
    return false;
  }
};
var Ma2 = class {
  constructor(t2, e, n, s) {
    this.authCredentials = t2, this.appCheckCredentials = e, this.asyncQueue = n, this.databaseInfo = s, this.user = C2.UNAUTHENTICATED, this.clientId = it.R(), this.authCredentialListener = () => Promise.resolve(), this.appCheckCredentialListener = () => Promise.resolve(), this.authCredentials.start(n, async (t3) => {
      O2("FirestoreClient", "Received user=", t3.uid), await this.authCredentialListener(t3), this.user = t3;
    }), this.appCheckCredentials.start(n, (t3) => (O2("FirestoreClient", "Received new app check token=", t3), this.appCheckCredentialListener(t3, this.user)));
  }
  async getConfiguration() {
    return {
      asyncQueue: this.asyncQueue,
      databaseInfo: this.databaseInfo,
      clientId: this.clientId,
      authCredentials: this.authCredentials,
      appCheckCredentials: this.appCheckCredentials,
      initialUser: this.user,
      maxConcurrentLimboResolutions: 100
    };
  }
  setCredentialChangeListener(t2) {
    this.authCredentialListener = t2;
  }
  setAppCheckTokenChangeListener(t2) {
    this.appCheckCredentialListener = t2;
  }
  verifyNotTerminated() {
    if (this.asyncQueue.isShuttingDown)
      throw new Q2(K2.FAILED_PRECONDITION, "The client has already been terminated.");
  }
  terminate() {
    this.asyncQueue.enterRestrictedMode();
    const t2 = new j();
    return this.asyncQueue.enqueueAndForgetEvenWhileRestricted(async () => {
      try {
        this.onlineComponents && await this.onlineComponents.terminate(), this.offlineComponents && await this.offlineComponents.terminate(), this.authCredentials.shutdown(), this.appCheckCredentials.shutdown(), t2.resolve();
      } catch (e) {
        const n = Pu(e, "Failed to shutdown persistence");
        t2.reject(n);
      }
    }), t2.promise;
  }
};
async function Oa(t2, e) {
  t2.asyncQueue.verifyOperationInProgress(), O2("FirestoreClient", "Initializing OfflineComponentProvider");
  const n = await t2.getConfiguration();
  await e.initialize(n);
  let s = n.initialUser;
  t2.setCredentialChangeListener(async (t3) => {
    s.isEqual(t3) || (await to(e.localStore, t3), s = t3);
  }), e.persistence.setDatabaseDeletedListener(() => t2.terminate()), t2.offlineComponents = e;
}
async function Fa2(t2, e) {
  t2.asyncQueue.verifyOperationInProgress();
  const n = await $a2(t2);
  O2("FirestoreClient", "Initializing OnlineComponentProvider");
  const s = await t2.getConfiguration();
  await e.initialize(n, s), t2.setCredentialChangeListener((t3) => Tu(e.remoteStore, t3)), t2.setAppCheckTokenChangeListener((t3, n2) => Tu(e.remoteStore, n2)), t2.onlineComponents = e;
}
async function $a2(t2) {
  return t2.offlineComponents || (O2("FirestoreClient", "Using default OfflineComponentProvider"), await Oa(t2, new Pa())), t2.offlineComponents;
}
async function Ba(t2) {
  return t2.onlineComponents || (O2("FirestoreClient", "Using default OnlineComponentProvider"), await Fa2(t2, new Sa2())), t2.onlineComponents;
}
function La2(t2) {
  return $a2(t2).then((t3) => t3.persistence);
}
function Ua2(t2) {
  return $a2(t2).then((t3) => t3.localStore);
}
function qa2(t2) {
  return Ba(t2).then((t3) => t3.remoteStore);
}
function Ga2(t2) {
  return Ba(t2).then((t3) => t3.syncEngine);
}
async function Ka2(t2) {
  const e = await Ba(t2), n = e.eventManager;
  return n.onListen = zu.bind(null, e.syncEngine), n.onUnlisten = Ju.bind(null, e.syncEngine), n;
}
function Qa(t2) {
  return t2.asyncQueue.enqueue(async () => {
    const e = await La2(t2), n = await qa2(t2);
    return e.setNetworkEnabled(true), function(t3) {
      const e2 = G(t3);
      return e2.lu.delete(0), Yo(e2);
    }(n);
  });
}
function ja2(t2) {
  return t2.asyncQueue.enqueue(async () => {
    const e = await La2(t2), n = await qa2(t2);
    return e.setNetworkEnabled(false), async function(t3) {
      const e2 = G(t3);
      e2.lu.add(0), await Xo(e2), e2._u.set("Offline");
    }(n);
  });
}
function Wa2(t2, e) {
  const n = new j();
  return t2.asyncQueue.enqueueAndForget(async () => async function(t3, e2, n2) {
    try {
      const s = await function(t4, e3) {
        const n3 = G(t4);
        return n3.persistence.runTransaction("read document", "readonly", (t5) => n3.ai.Bs(t5, e3));
      }(t3, e2);
      s.isFoundDocument() ? n2.resolve(s) : s.isNoDocument() ? n2.resolve(null) : n2.reject(new Q2(K2.UNAVAILABLE, "Failed to get document from cache. (However, this document may exist on the server. Run again without setting 'source' in the GetOptions to attempt to retrieve the document from the server.)"));
    } catch (t4) {
      const s = Pu(t4, `Failed to get document '${e2} from cache`);
      n2.reject(s);
    }
  }(await Ua2(t2), e, n)), n.promise;
}
function za2(t2, e, n = {}) {
  const s = new j();
  return t2.asyncQueue.enqueueAndForget(async () => function(t3, e2, n2, s2, i) {
    const r = new Ca2({
      next: (r2) => {
        e2.enqueueAndForget(() => Nu(t3, o));
        const u = r2.docs.has(n2);
        !u && r2.fromCache ? i.reject(new Q2(K2.UNAVAILABLE, "Failed to get document because the client is offline.")) : u && r2.fromCache && s2 && s2.source === "server" ? i.reject(new Q2(K2.UNAVAILABLE, 'Failed to get document from server. (However, this document does exist in the local cache. Run again without setting source to "server" to retrieve the cached document.)')) : i.resolve(r2);
      },
      error: (t4) => i.reject(t4)
    }), o = new Fu(Ne(n2.path), r, {
      includeMetadataChanges: true,
      Du: true
    });
    return xu(t3, o);
  }(await Ka2(t2), t2.asyncQueue, e, n, s)), s.promise;
}
function Ha2(t2, e) {
  const n = new j();
  return t2.asyncQueue.enqueueAndForget(async () => async function(t3, e2, n2) {
    try {
      const s = await ao(t3, e2, true), i = new Ku(e2, s.hi), r = i.Gu(s.documents), o = i.applyChanges(r, false);
      n2.resolve(o.snapshot);
    } catch (t4) {
      const s = Pu(t4, `Failed to execute query '${e2} against cache`);
      n2.reject(s);
    }
  }(await Ua2(t2), e, n)), n.promise;
}
function Ja2(t2, e, n = {}) {
  const s = new j();
  return t2.asyncQueue.enqueueAndForget(async () => function(t3, e2, n2, s2, i) {
    const r = new Ca2({
      next: (n3) => {
        e2.enqueueAndForget(() => Nu(t3, o)), n3.fromCache && s2.source === "server" ? i.reject(new Q2(K2.UNAVAILABLE, 'Failed to get documents from server. (However, these documents may exist in the local cache. Run again without setting source to "server" to retrieve the cached documents.)')) : i.resolve(n3);
      },
      error: (t4) => i.reject(t4)
    }), o = new Fu(n2, r, {
      includeMetadataChanges: true,
      Du: true
    });
    return xu(t3, o);
  }(await Ka2(t2), t2.asyncQueue, e, n, s)), s.promise;
}
function Ya2(t2, e) {
  const n = new Ca2(e);
  return t2.asyncQueue.enqueueAndForget(async () => function(t3, e2) {
    G(t3).Tu.add(e2), e2.next();
  }(await Ka2(t2), n)), () => {
    n.pa(), t2.asyncQueue.enqueueAndForget(async () => function(t3, e2) {
      G(t3).Tu.delete(e2);
    }(await Ka2(t2), n));
  };
}
function Xa2(t2, e) {
  const n = new j();
  return t2.asyncQueue.enqueueAndForget(async () => {
    const s = await function(t3) {
      return Ba(t3).then((t4) => t4.datastore);
    }(t2);
    new ka2(t2.asyncQueue, s, e, n).run();
  }), n.promise;
}
function Za2(t2, e, n, s) {
  const i = function(t3, e2) {
    let n2;
    n2 = typeof t3 == "string" ? new TextEncoder().encode(t3) : t3;
    return function(t4, e3) {
      return new xa2(t4, e3);
    }(function(t4, e3) {
      if (t4 instanceof Uint8Array)
        return Da(t4, e3);
      if (t4 instanceof ArrayBuffer)
        return Da(new Uint8Array(t4), e3);
      if (t4 instanceof ReadableStream)
        return t4.getReader();
      throw new Error("Source of `toByteStreamReader` has to be a ArrayBuffer or ReadableStream");
    }(n2), e2);
  }(n, Go(e));
  t2.asyncQueue.enqueueAndForget(async () => {
    ba2(await Ga2(t2), i, s);
  });
}
function tc2(t2, e) {
  return t2.asyncQueue.enqueue(async () => function(t3, e2) {
    const n = G(t3);
    return n.persistence.runTransaction("Get named query", "readonly", (t4) => n.ds.getNamedQuery(t4, e2));
  }(await Ua2(t2), e));
}
var ec2 = /* @__PURE__ */ new Map();
function nc2(t2, e, n) {
  if (!n)
    throw new Q2(K2.INVALID_ARGUMENT, `Function ${t2}() cannot be called with an empty ${e}.`);
}
function sc2(t2, e, n, s) {
  if (e === true && s === true)
    throw new Q2(K2.INVALID_ARGUMENT, `${t2} and ${n} cannot be used together.`);
}
function ic2(t2) {
  if (!xt.isDocumentKey(t2))
    throw new Q2(K2.INVALID_ARGUMENT, `Invalid document reference. Document references must have an even number of segments, but ${t2} has ${t2.length}.`);
}
function rc2(t2) {
  if (xt.isDocumentKey(t2))
    throw new Q2(K2.INVALID_ARGUMENT, `Invalid collection reference. Collection references must have an odd number of segments, but ${t2} has ${t2.length}.`);
}
function oc2(t2) {
  if (t2 === void 0)
    return "undefined";
  if (t2 === null)
    return "null";
  if (typeof t2 == "string")
    return t2.length > 20 && (t2 = `${t2.substring(0, 20)}...`), JSON.stringify(t2);
  if (typeof t2 == "number" || typeof t2 == "boolean")
    return "" + t2;
  if (typeof t2 == "object") {
    if (t2 instanceof Array)
      return "an array";
    {
      const e = function(t3) {
        if (t3.constructor)
          return t3.constructor.name;
        return null;
      }(t2);
      return e ? `a custom ${e} object` : "an object";
    }
  }
  return typeof t2 == "function" ? "a function" : L2();
}
function uc2(t2, e) {
  if ("_delegate" in t2 && (t2 = t2._delegate), !(t2 instanceof e)) {
    if (e.name === t2.constructor.name)
      throw new Q2(K2.INVALID_ARGUMENT, "Type does not match the expected instance. Did you pass a reference from a different Firestore SDK?");
    {
      const n = oc2(t2);
      throw new Q2(K2.INVALID_ARGUMENT, `Expected type '${e.name}', but it was: ${n}`);
    }
  }
  return t2;
}
function ac2(t2, e) {
  if (e <= 0)
    throw new Q2(K2.INVALID_ARGUMENT, `Function ${t2}() requires a positive number, but it was: ${e}.`);
}
var cc2 = class {
  constructor(t2) {
    var e;
    if (t2.host === void 0) {
      if (t2.ssl !== void 0)
        throw new Q2(K2.INVALID_ARGUMENT, "Can't provide ssl option if host option is not set");
      this.host = "firestore.googleapis.com", this.ssl = true;
    } else
      this.host = t2.host, this.ssl = (e = t2.ssl) === null || e === void 0 || e;
    if (this.credentials = t2.credentials, this.ignoreUndefinedProperties = !!t2.ignoreUndefinedProperties, t2.cacheSizeBytes === void 0)
      this.cacheSizeBytes = 41943040;
    else {
      if (t2.cacheSizeBytes !== -1 && t2.cacheSizeBytes < 1048576)
        throw new Q2(K2.INVALID_ARGUMENT, "cacheSizeBytes must be at least 1048576");
      this.cacheSizeBytes = t2.cacheSizeBytes;
    }
    this.experimentalForceLongPolling = !!t2.experimentalForceLongPolling, this.experimentalAutoDetectLongPolling = !!t2.experimentalAutoDetectLongPolling, this.useFetchStreams = !!t2.useFetchStreams, sc2("experimentalForceLongPolling", t2.experimentalForceLongPolling, "experimentalAutoDetectLongPolling", t2.experimentalAutoDetectLongPolling);
  }
  isEqual(t2) {
    return this.host === t2.host && this.ssl === t2.ssl && this.credentials === t2.credentials && this.cacheSizeBytes === t2.cacheSizeBytes && this.experimentalForceLongPolling === t2.experimentalForceLongPolling && this.experimentalAutoDetectLongPolling === t2.experimentalAutoDetectLongPolling && this.ignoreUndefinedProperties === t2.ignoreUndefinedProperties && this.useFetchStreams === t2.useFetchStreams;
  }
};
var hc2 = class {
  constructor(t2, e, n) {
    this._authCredentials = e, this._appCheckCredentials = n, this.type = "firestore-lite", this._persistenceKey = "(lite)", this._settings = new cc2({}), this._settingsFrozen = false, t2 instanceof vt ? this._databaseId = t2 : (this._app = t2, this._databaseId = function(t3) {
      if (!Object.prototype.hasOwnProperty.apply(t3.options, ["projectId"]))
        throw new Q2(K2.INVALID_ARGUMENT, '"projectId" not provided in firebase.initializeApp.');
      return new vt(t3.options.projectId);
    }(t2));
  }
  get app() {
    if (!this._app)
      throw new Q2(K2.FAILED_PRECONDITION, "Firestore was not initialized using the Firebase SDK. 'app' is not available");
    return this._app;
  }
  get _initialized() {
    return this._settingsFrozen;
  }
  get _terminated() {
    return this._terminateTask !== void 0;
  }
  _setSettings(t2) {
    if (this._settingsFrozen)
      throw new Q2(K2.FAILED_PRECONDITION, "Firestore has already been started and its settings can no longer be changed. You can only modify settings before calling any other methods on a Firestore object.");
    this._settings = new cc2(t2), t2.credentials !== void 0 && (this._authCredentials = function(t3) {
      if (!t3)
        return new z2();
      switch (t3.type) {
        case "gapi":
          const e = t3.client;
          return U2(!(typeof e != "object" || e === null || !e.auth || !e.auth.getAuthHeaderValueForFirstParty)), new X2(e, t3.sessionIndex || "0", t3.iamToken || null);
        case "provider":
          return t3.client;
        default:
          throw new Q2(K2.INVALID_ARGUMENT, "makeAuthCredentialsProvider failed due to invalid credential type");
      }
    }(t2.credentials));
  }
  _getSettings() {
    return this._settings;
  }
  _freezeSettings() {
    return this._settingsFrozen = true, this._settings;
  }
  _delete() {
    return this._terminateTask || (this._terminateTask = this._terminate()), this._terminateTask;
  }
  toJSON() {
    return {
      app: this._app,
      databaseId: this._databaseId,
      settings: this._settings
    };
  }
  _terminate() {
    return function(t2) {
      const e = ec2.get(t2);
      e && (O2("ComponentProvider", "Removing Datastore"), ec2.delete(t2), e.terminate());
    }(this), Promise.resolve();
  }
};
function lc2(t2, e, n, s = {}) {
  var i;
  const r = (t2 = uc2(t2, hc2))._getSettings();
  if (r.host !== "firestore.googleapis.com" && r.host !== e && $("Host has been set in both settings() and useEmulator(), emulator host will be used"), t2._setSettings(Object.assign(Object.assign({}, r), {
    host: `${e}:${n}`,
    ssl: false
  })), s.mockUserToken) {
    let e2, n2;
    if (typeof s.mockUserToken == "string")
      e2 = s.mockUserToken, n2 = C2.MOCK_USER;
    else {
      e2 = createMockUserToken(s.mockUserToken, (i = t2._app) === null || i === void 0 ? void 0 : i.options.projectId);
      const r2 = s.mockUserToken.sub || s.mockUserToken.user_id;
      if (!r2)
        throw new Q2(K2.INVALID_ARGUMENT, "mockUserToken must contain 'sub' or 'user_id' field!");
      n2 = new C2(r2);
    }
    t2._authCredentials = new H2(new W2(e2, n2));
  }
}
var fc2 = class {
  constructor(t2, e, n) {
    this.converter = e, this._key = n, this.type = "document", this.firestore = t2;
  }
  get _path() {
    return this._key.path;
  }
  get id() {
    return this._key.path.lastSegment();
  }
  get path() {
    return this._key.path.canonicalString();
  }
  get parent() {
    return new _c(this.firestore, this.converter, this._key.path.popLast());
  }
  withConverter(t2) {
    return new fc2(this.firestore, t2, this._key);
  }
};
var dc2 = class {
  constructor(t2, e, n) {
    this.converter = e, this._query = n, this.type = "query", this.firestore = t2;
  }
  withConverter(t2) {
    return new dc2(this.firestore, t2, this._query);
  }
};
var _c = class extends dc2 {
  constructor(t2, e, n) {
    super(t2, e, Ne(n)), this._path = n, this.type = "collection";
  }
  get id() {
    return this._query.path.lastSegment();
  }
  get path() {
    return this._query.path.canonicalString();
  }
  get parent() {
    const t2 = this._path.popLast();
    return t2.isEmpty() ? null : new fc2(this.firestore, null, new xt(t2));
  }
  withConverter(t2) {
    return new _c(this.firestore, t2, this._path);
  }
};
function wc2(t2, e, ...n) {
  if (t2 = getModularInstance(t2), nc2("collection", "path", e), t2 instanceof hc2) {
    const s = _t.fromString(e, ...n);
    return rc2(s), new _c(t2, null, s);
  }
  {
    if (!(t2 instanceof fc2 || t2 instanceof _c))
      throw new Q2(K2.INVALID_ARGUMENT, "Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore");
    const s = t2._path.child(_t.fromString(e, ...n));
    return rc2(s), new _c(t2.firestore, null, s);
  }
}
function mc2(t2, e) {
  if (t2 = uc2(t2, hc2), nc2("collectionGroup", "collection id", e), e.indexOf("/") >= 0)
    throw new Q2(K2.INVALID_ARGUMENT, `Invalid collection ID '${e}' passed to function collectionGroup(). Collection IDs must not contain '/'.`);
  return new dc2(t2, null, function(t3) {
    return new Ce(_t.emptyPath(), t3);
  }(e));
}
function gc2(t2, e, ...n) {
  if (t2 = getModularInstance(t2), arguments.length === 1 && (e = it.R()), nc2("doc", "path", e), t2 instanceof hc2) {
    const s = _t.fromString(e, ...n);
    return ic2(s), new fc2(t2, null, new xt(s));
  }
  {
    if (!(t2 instanceof fc2 || t2 instanceof _c))
      throw new Q2(K2.INVALID_ARGUMENT, "Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore");
    const s = t2._path.child(_t.fromString(e, ...n));
    return ic2(s), new fc2(t2.firestore, t2 instanceof _c ? t2.converter : null, new xt(s));
  }
}
function yc2(t2, e) {
  return t2 = getModularInstance(t2), e = getModularInstance(e), (t2 instanceof fc2 || t2 instanceof _c) && (e instanceof fc2 || e instanceof _c) && (t2.firestore === e.firestore && t2.path === e.path && t2.converter === e.converter);
}
function pc2(t2, e) {
  return t2 = getModularInstance(t2), e = getModularInstance(e), t2 instanceof dc2 && e instanceof dc2 && (t2.firestore === e.firestore && qe(t2._query, e._query) && t2.converter === e.converter);
}
var Ic2 = class {
  constructor() {
    this.Na = Promise.resolve(), this.ka = [], this.Ma = false, this.Oa = [], this.Fa = null, this.$a = false, this.Ba = false, this.La = [], this.So = new Ko(this, "async_queue_retry"), this.Ua = () => {
      const t3 = qo();
      t3 && O2("AsyncQueue", "Visibility state changed to " + t3.visibilityState), this.So.Eo();
    };
    const t2 = qo();
    t2 && typeof t2.addEventListener == "function" && t2.addEventListener("visibilitychange", this.Ua);
  }
  get isShuttingDown() {
    return this.Ma;
  }
  enqueueAndForget(t2) {
    this.enqueue(t2);
  }
  enqueueAndForgetEvenWhileRestricted(t2) {
    this.qa(), this.Ga(t2);
  }
  enterRestrictedMode(t2) {
    if (!this.Ma) {
      this.Ma = true, this.Ba = t2 || false;
      const e = qo();
      e && typeof e.removeEventListener == "function" && e.removeEventListener("visibilitychange", this.Ua);
    }
  }
  enqueue(t2) {
    if (this.qa(), this.Ma)
      return new Promise(() => {
      });
    const e = new j();
    return this.Ga(() => this.Ma && this.Ba ? Promise.resolve() : (t2().then(e.resolve, e.reject), e.promise)).then(() => e.promise);
  }
  enqueueRetryable(t2) {
    this.enqueueAndForget(() => (this.ka.push(t2), this.Ka()));
  }
  async Ka() {
    if (this.ka.length !== 0) {
      try {
        await this.ka[0](), this.ka.shift(), this.So.reset();
      } catch (t2) {
        if (!Ii(t2))
          throw t2;
        O2("AsyncQueue", "Operation failed with retryable error: " + t2);
      }
      this.ka.length > 0 && this.So.Io(() => this.Ka());
    }
  }
  Ga(t2) {
    const e = this.Na.then(() => (this.$a = true, t2().catch((t3) => {
      this.Fa = t3, this.$a = false;
      const e2 = function(t4) {
        let e3 = t4.message || "";
        t4.stack && (e3 = t4.stack.includes(t4.message) ? t4.stack : t4.message + "\n" + t4.stack);
        return e3;
      }(t3);
      throw F2("INTERNAL UNHANDLED ERROR: ", e2), t3;
    }).then((t3) => (this.$a = false, t3))));
    return this.Na = e, e;
  }
  enqueueAfterDelay(t2, e, n) {
    this.qa(), this.La.indexOf(t2) > -1 && (e = 0);
    const s = bu.createAndSchedule(this, t2, e, n, (t3) => this.Qa(t3));
    return this.Oa.push(s), s;
  }
  qa() {
    this.Fa && L2();
  }
  verifyOperationInProgress() {
  }
  async ja() {
    let t2;
    do {
      t2 = this.Na, await t2;
    } while (t2 !== this.Na);
  }
  Wa(t2) {
    for (const e of this.Oa)
      if (e.timerId === t2)
        return true;
    return false;
  }
  za(t2) {
    return this.ja().then(() => {
      this.Oa.sort((t3, e) => t3.targetTimeMs - e.targetTimeMs);
      for (const e of this.Oa)
        if (e.skipDelay(), t2 !== "all" && e.timerId === t2)
          break;
      return this.ja();
    });
  }
  Ha(t2) {
    this.La.push(t2);
  }
  Qa(t2) {
    const e = this.Oa.indexOf(t2);
    this.Oa.splice(e, 1);
  }
};
function Tc2(t2) {
  return function(t3, e) {
    if (typeof t3 != "object" || t3 === null)
      return false;
    const n = t3;
    for (const t4 of e)
      if (t4 in n && typeof n[t4] == "function")
        return true;
    return false;
  }(t2, ["next", "error", "complete"]);
}
var Ec2 = class {
  constructor() {
    this._progressObserver = {}, this._taskCompletionResolver = new j(), this._lastProgress = {
      taskState: "Running",
      totalBytes: 0,
      totalDocuments: 0,
      bytesLoaded: 0,
      documentsLoaded: 0
    };
  }
  onProgress(t2, e, n) {
    this._progressObserver = {
      next: t2,
      error: e,
      complete: n
    };
  }
  catch(t2) {
    return this._taskCompletionResolver.promise.catch(t2);
  }
  then(t2, e) {
    return this._taskCompletionResolver.promise.then(t2, e);
  }
  _completeWith(t2) {
    this._updateProgress(t2), this._progressObserver.complete && this._progressObserver.complete(), this._taskCompletionResolver.resolve(t2);
  }
  _failWith(t2) {
    this._lastProgress.taskState = "Error", this._progressObserver.next && this._progressObserver.next(this._lastProgress), this._progressObserver.error && this._progressObserver.error(t2), this._taskCompletionResolver.reject(t2);
  }
  _updateProgress(t2) {
    this._lastProgress = t2, this._progressObserver.next && this._progressObserver.next(t2);
  }
};
var Ac2 = -1;
var Rc2 = class extends hc2 {
  constructor(t2, e, n) {
    super(t2, e, n), this.type = "firestore", this._queue = new Ic2(), this._persistenceKey = "name" in t2 ? t2.name : "[DEFAULT]";
  }
  _terminate() {
    return this._firestoreClient || vc2(this), this._firestoreClient.terminate();
  }
};
function bc2(t2, e) {
  const n = _getProvider(t2, "firestore");
  if (n.isInitialized()) {
    const t3 = n.getImmediate(), s = n.getOptions();
    if (deepEqual(s, e))
      return t3;
    throw new Q2(K2.FAILED_PRECONDITION, "initializeFirestore() has already been called with different options. To avoid this error, call initializeFirestore() with the same options as when it was originally called, or call getFirestore() to return the already initialized instance.");
  }
  if (e.cacheSizeBytes !== void 0 && e.cacheSizeBytes !== -1 && e.cacheSizeBytes < 1048576)
    throw new Q2(K2.INVALID_ARGUMENT, "cacheSizeBytes must be at least 1048576");
  return n.initialize({
    options: e
  });
}
function Pc2(e = getApp()) {
  return _getProvider(e, "firestore").getImmediate();
}
function Vc2(t2) {
  return t2._firestoreClient || vc2(t2), t2._firestoreClient.verifyNotTerminated(), t2._firestoreClient;
}
function vc2(t2) {
  var e;
  const n = t2._freezeSettings(), s = function(t3, e2, n2, s2) {
    return new Vt(t3, e2, n2, s2.host, s2.ssl, s2.experimentalForceLongPolling, s2.experimentalAutoDetectLongPolling, s2.useFetchStreams);
  }(t2._databaseId, ((e = t2._app) === null || e === void 0 ? void 0 : e.options.appId) || "", t2._persistenceKey, n);
  t2._firestoreClient = new Ma2(t2._authCredentials, t2._appCheckCredentials, t2._queue, s);
}
function Sc2(t2, e) {
  Bc2(t2 = uc2(t2, Rc2));
  const n = Vc2(t2), s = t2._freezeSettings(), i = new Sa2();
  return Cc2(n, i, new Va2(i, s.cacheSizeBytes, e == null ? void 0 : e.forceOwnership));
}
function Dc2(t2) {
  Bc2(t2 = uc2(t2, Rc2));
  const e = Vc2(t2), n = t2._freezeSettings(), s = new Sa2();
  return Cc2(e, s, new va(s, n.cacheSizeBytes));
}
function Cc2(t2, e, n) {
  const s = new j();
  return t2.asyncQueue.enqueue(async () => {
    try {
      await Oa(t2, n), await Fa2(t2, e), s.resolve();
    } catch (t3) {
      if (!function(t4) {
        if (t4.name === "FirebaseError")
          return t4.code === K2.FAILED_PRECONDITION || t4.code === K2.UNIMPLEMENTED;
        if (typeof DOMException != "undefined" && t4 instanceof DOMException)
          return t4.code === 22 || t4.code === 20 || t4.code === 11;
        return true;
      }(t3))
        throw t3;
      console.warn("Error enabling offline persistence. Falling back to persistence disabled: " + t3), s.reject(t3);
    }
  }).then(() => s.promise);
}
function xc2(t2) {
  if (t2._initialized && !t2._terminated)
    throw new Q2(K2.FAILED_PRECONDITION, "Persistence can only be cleared before a Firestore instance is initialized or after it is terminated.");
  const e = new j();
  return t2._queue.enqueueAndForgetEvenWhileRestricted(async () => {
    try {
      await async function(t3) {
        if (!gi.vt())
          return Promise.resolve();
        const e2 = t3 + "main";
        await gi.delete(e2);
      }(zr(t2._databaseId, t2._persistenceKey)), e.resolve();
    } catch (t3) {
      e.reject(t3);
    }
  }), e.promise;
}
function Nc2(t2) {
  return function(t3) {
    const e = new j();
    return t3.asyncQueue.enqueueAndForget(async () => sa2(await Ga2(t3), e)), e.promise;
  }(Vc2(t2 = uc2(t2, Rc2)));
}
function kc2(t2) {
  return Qa(Vc2(t2 = uc2(t2, Rc2)));
}
function Mc2(t2) {
  return ja2(Vc2(t2 = uc2(t2, Rc2)));
}
function Oc2(t2) {
  return _removeServiceInstance(t2.app, "firestore"), t2._delete();
}
function Fc2(t2, e) {
  const n = Vc2(t2 = uc2(t2, Rc2)), s = new Ec2();
  return Za2(n, t2._databaseId, e, s), s;
}
function $c2(t2, e) {
  return tc2(Vc2(t2 = uc2(t2, Rc2)), e).then((e2) => e2 ? new dc2(t2, null, e2.query) : null);
}
function Bc2(t2) {
  if (t2._initialized || t2._terminated)
    throw new Q2(K2.FAILED_PRECONDITION, "Firestore has already been started and persistence can no longer be enabled. You can only enable persistence before calling any other methods on a Firestore object.");
}
var Lc2 = class {
  constructor(...t2) {
    for (let e = 0; e < t2.length; ++e)
      if (t2[e].length === 0)
        throw new Q2(K2.INVALID_ARGUMENT, "Invalid field name at argument $(i + 1). Field names must not be empty.");
    this._internalPath = new mt(t2);
  }
  isEqual(t2) {
    return this._internalPath.isEqual(t2._internalPath);
  }
};
function Uc2() {
  return new Lc2("__name__");
}
var qc2 = class {
  constructor(t2) {
    this._byteString = t2;
  }
  static fromBase64String(t2) {
    try {
      return new qc2(pt.fromBase64String(t2));
    } catch (t3) {
      throw new Q2(K2.INVALID_ARGUMENT, "Failed to construct data from Base64 string: " + t3);
    }
  }
  static fromUint8Array(t2) {
    return new qc2(pt.fromUint8Array(t2));
  }
  toBase64() {
    return this._byteString.toBase64();
  }
  toUint8Array() {
    return this._byteString.toUint8Array();
  }
  toString() {
    return "Bytes(base64: " + this.toBase64() + ")";
  }
  isEqual(t2) {
    return this._byteString.isEqual(t2._byteString);
  }
};
var Gc2 = class {
  constructor(t2) {
    this._methodName = t2;
  }
};
var Kc2 = class {
  constructor(t2, e) {
    if (!isFinite(t2) || t2 < -90 || t2 > 90)
      throw new Q2(K2.INVALID_ARGUMENT, "Latitude must be a number between -90 and 90, but was: " + t2);
    if (!isFinite(e) || e < -180 || e > 180)
      throw new Q2(K2.INVALID_ARGUMENT, "Longitude must be a number between -180 and 180, but was: " + e);
    this._lat = t2, this._long = e;
  }
  get latitude() {
    return this._lat;
  }
  get longitude() {
    return this._long;
  }
  isEqual(t2) {
    return this._lat === t2._lat && this._long === t2._long;
  }
  toJSON() {
    return {
      latitude: this._lat,
      longitude: this._long
    };
  }
  _compareTo(t2) {
    return rt(this._lat, t2._lat) || rt(this._long, t2._long);
  }
};
var Qc2 = /^__.*__$/;
var jc2 = class {
  constructor(t2, e, n) {
    this.data = t2, this.fieldMask = e, this.fieldTransforms = n;
  }
  toMutation(t2, e) {
    return this.fieldMask !== null ? new An(t2, this.data, this.fieldMask, e, this.fieldTransforms) : new En(t2, this.data, e, this.fieldTransforms);
  }
};
var Wc2 = class {
  constructor(t2, e, n) {
    this.data = t2, this.fieldMask = e, this.fieldTransforms = n;
  }
  toMutation(t2, e) {
    return new An(t2, this.data, this.fieldMask, e, this.fieldTransforms);
  }
};
function zc2(t2) {
  switch (t2) {
    case 0:
    case 2:
    case 1:
      return true;
    case 3:
    case 4:
      return false;
    default:
      throw L2();
  }
}
var Hc2 = class {
  constructor(t2, e, n, s, i, r) {
    this.settings = t2, this.databaseId = e, this.M = n, this.ignoreUndefinedProperties = s, i === void 0 && this.Ja(), this.fieldTransforms = i || [], this.fieldMask = r || [];
  }
  get path() {
    return this.settings.path;
  }
  get Ya() {
    return this.settings.Ya;
  }
  Xa(t2) {
    return new Hc2(Object.assign(Object.assign({}, this.settings), t2), this.databaseId, this.M, this.ignoreUndefinedProperties, this.fieldTransforms, this.fieldMask);
  }
  Za(t2) {
    var e;
    const n = (e = this.path) === null || e === void 0 ? void 0 : e.child(t2), s = this.Xa({
      path: n,
      tc: false
    });
    return s.ec(t2), s;
  }
  nc(t2) {
    var e;
    const n = (e = this.path) === null || e === void 0 ? void 0 : e.child(t2), s = this.Xa({
      path: n,
      tc: false
    });
    return s.Ja(), s;
  }
  sc(t2) {
    return this.Xa({
      path: void 0,
      tc: true
    });
  }
  ic(t2) {
    return wh(t2, this.settings.methodName, this.settings.rc || false, this.path, this.settings.oc);
  }
  contains(t2) {
    return this.fieldMask.find((e) => t2.isPrefixOf(e)) !== void 0 || this.fieldTransforms.find((e) => t2.isPrefixOf(e.field)) !== void 0;
  }
  Ja() {
    if (this.path)
      for (let t2 = 0; t2 < this.path.length; t2++)
        this.ec(this.path.get(t2));
  }
  ec(t2) {
    if (t2.length === 0)
      throw this.ic("Document fields must not be empty");
    if (zc2(this.Ya) && Qc2.test(t2))
      throw this.ic('Document fields cannot begin and end with "__"');
  }
};
var Jc2 = class {
  constructor(t2, e, n) {
    this.databaseId = t2, this.ignoreUndefinedProperties = e, this.M = n || Go(t2);
  }
  uc(t2, e, n, s = false) {
    return new Hc2({
      Ya: t2,
      methodName: e,
      oc: n,
      path: mt.emptyPath(),
      tc: false,
      rc: s
    }, this.databaseId, this.M, this.ignoreUndefinedProperties);
  }
};
function Yc2(t2) {
  const e = t2._freezeSettings(), n = Go(t2._databaseId);
  return new Jc2(t2._databaseId, !!e.ignoreUndefinedProperties, n);
}
function Xc2(t2, e, n, s, i, r = {}) {
  const o = t2.uc(r.merge || r.mergeFields ? 2 : 0, e, n, i);
  lh("Data must be an object, but it was:", o, s);
  const u = ch(s, o);
  let a, c;
  if (r.merge)
    a = new gt(o.fieldMask), c = o.fieldTransforms;
  else if (r.mergeFields) {
    const t3 = [];
    for (const s2 of r.mergeFields) {
      const i2 = fh(e, s2, n);
      if (!o.contains(i2))
        throw new Q2(K2.INVALID_ARGUMENT, `Field '${i2}' is specified in your field mask but missing from your input data.`);
      mh(t3, i2) || t3.push(i2);
    }
    a = new gt(t3), c = o.fieldTransforms.filter((t4) => a.covers(t4.field));
  } else
    a = null, c = o.fieldTransforms;
  return new jc2(new Xt(u), a, c);
}
var Zc2 = class extends Gc2 {
  _toFieldTransform(t2) {
    if (t2.Ya !== 2)
      throw t2.Ya === 1 ? t2.ic(`${this._methodName}() can only appear at the top level of your update data`) : t2.ic(`${this._methodName}() cannot be used with set() unless you pass {merge:true}`);
    return t2.fieldMask.push(t2.path), null;
  }
  isEqual(t2) {
    return t2 instanceof Zc2;
  }
};
function th(t2, e, n) {
  return new Hc2({
    Ya: 3,
    oc: e.settings.oc,
    methodName: t2._methodName,
    tc: n
  }, e.databaseId, e.M, e.ignoreUndefinedProperties);
}
var eh = class extends Gc2 {
  _toFieldTransform(t2) {
    return new ln(t2.path, new nn());
  }
  isEqual(t2) {
    return t2 instanceof eh;
  }
};
var nh = class extends Gc2 {
  constructor(t2, e) {
    super(t2), this.ac = e;
  }
  _toFieldTransform(t2) {
    const e = th(this, t2, true), n = this.ac.map((t3) => ah(t3, e)), s = new sn(n);
    return new ln(t2.path, s);
  }
  isEqual(t2) {
    return this === t2;
  }
};
var sh = class extends Gc2 {
  constructor(t2, e) {
    super(t2), this.ac = e;
  }
  _toFieldTransform(t2) {
    const e = th(this, t2, true), n = this.ac.map((t3) => ah(t3, e)), s = new on(n);
    return new ln(t2.path, s);
  }
  isEqual(t2) {
    return this === t2;
  }
};
var ih = class extends Gc2 {
  constructor(t2, e) {
    super(t2), this.cc = e;
  }
  _toFieldTransform(t2) {
    const e = new an(t2.M, Ye(t2.M, this.cc));
    return new ln(t2.path, e);
  }
  isEqual(t2) {
    return this === t2;
  }
};
function rh(t2, e, n, s) {
  const i = t2.uc(1, e, n);
  lh("Data must be an object, but it was:", i, s);
  const r = [], o = Xt.empty();
  lt(s, (t3, s2) => {
    const u2 = _h(e, t3, n);
    s2 = getModularInstance(s2);
    const a = i.nc(u2);
    if (s2 instanceof Zc2)
      r.push(u2);
    else {
      const t4 = ah(s2, a);
      t4 != null && (r.push(u2), o.set(u2, t4));
    }
  });
  const u = new gt(r);
  return new Wc2(o, u, i.fieldTransforms);
}
function oh(t2, e, n, s, i, r) {
  const o = t2.uc(1, e, n), u = [fh(e, s, n)], a = [i];
  if (r.length % 2 != 0)
    throw new Q2(K2.INVALID_ARGUMENT, `Function ${e}() needs to be called with an even number of arguments that alternate between field names and values.`);
  for (let t3 = 0; t3 < r.length; t3 += 2)
    u.push(fh(e, r[t3])), a.push(r[t3 + 1]);
  const c = [], h = Xt.empty();
  for (let t3 = u.length - 1; t3 >= 0; --t3)
    if (!mh(c, u[t3])) {
      const e2 = u[t3];
      let n2 = a[t3];
      n2 = getModularInstance(n2);
      const s2 = o.nc(e2);
      if (n2 instanceof Zc2)
        c.push(e2);
      else {
        const t4 = ah(n2, s2);
        t4 != null && (c.push(e2), h.set(e2, t4));
      }
    }
  const l2 = new gt(c);
  return new Wc2(h, l2, o.fieldTransforms);
}
function uh(t2, e, n, s = false) {
  return ah(n, t2.uc(s ? 4 : 3, e));
}
function ah(t2, e) {
  if (hh(t2 = getModularInstance(t2)))
    return lh("Unsupported field value:", e, t2), ch(t2, e);
  if (t2 instanceof Gc2)
    return function(t3, e2) {
      if (!zc2(e2.Ya))
        throw e2.ic(`${t3._methodName}() can only be used with update() and set()`);
      if (!e2.path)
        throw e2.ic(`${t3._methodName}() is not currently supported inside arrays`);
      const n = t3._toFieldTransform(e2);
      n && e2.fieldTransforms.push(n);
    }(t2, e), null;
  if (t2 === void 0 && e.ignoreUndefinedProperties)
    return null;
  if (e.path && e.fieldMask.push(e.path), t2 instanceof Array) {
    if (e.settings.tc && e.Ya !== 4)
      throw e.ic("Nested arrays are not supported");
    return function(t3, e2) {
      const n = [];
      let s = 0;
      for (const i of t3) {
        let t4 = ah(i, e2.sc(s));
        t4 == null && (t4 = {
          nullValue: "NULL_VALUE"
        }), n.push(t4), s++;
      }
      return {
        arrayValue: {
          values: n
        }
      };
    }(t2, e);
  }
  return function(t3, e2) {
    if ((t3 = getModularInstance(t3)) === null)
      return {
        nullValue: "NULL_VALUE"
      };
    if (typeof t3 == "number")
      return Ye(e2.M, t3);
    if (typeof t3 == "boolean")
      return {
        booleanValue: t3
      };
    if (typeof t3 == "string")
      return {
        stringValue: t3
      };
    if (t3 instanceof Date) {
      const n = at.fromDate(t3);
      return {
        timestampValue: cs(e2.M, n)
      };
    }
    if (t3 instanceof at) {
      const n = new at(t3.seconds, 1e3 * Math.floor(t3.nanoseconds / 1e3));
      return {
        timestampValue: cs(e2.M, n)
      };
    }
    if (t3 instanceof Kc2)
      return {
        geoPointValue: {
          latitude: t3.latitude,
          longitude: t3.longitude
        }
      };
    if (t3 instanceof qc2)
      return {
        bytesValue: hs(e2.M, t3._byteString)
      };
    if (t3 instanceof fc2) {
      const n = e2.databaseId, s = t3.firestore._databaseId;
      if (!s.isEqual(n))
        throw e2.ic(`Document reference is for database ${s.projectId}/${s.database} but should be for database ${n.projectId}/${n.database}`);
      return {
        referenceValue: ds(t3.firestore._databaseId || e2.databaseId, t3._key.path)
      };
    }
    throw e2.ic(`Unsupported field value: ${oc2(t3)}`);
  }(t2, e);
}
function ch(t2, e) {
  const n = {};
  return ft(t2) ? e.path && e.path.length > 0 && e.fieldMask.push(e.path) : lt(t2, (t3, s) => {
    const i = ah(s, e.Za(t3));
    i != null && (n[t3] = i);
  }), {
    mapValue: {
      fields: n
    }
  };
}
function hh(t2) {
  return !(typeof t2 != "object" || t2 === null || t2 instanceof Array || t2 instanceof Date || t2 instanceof at || t2 instanceof Kc2 || t2 instanceof qc2 || t2 instanceof fc2 || t2 instanceof Gc2);
}
function lh(t2, e, n) {
  if (!hh(n) || !function(t3) {
    return typeof t3 == "object" && t3 !== null && (Object.getPrototypeOf(t3) === Object.prototype || Object.getPrototypeOf(t3) === null);
  }(n)) {
    const s = oc2(n);
    throw s === "an object" ? e.ic(t2 + " a custom object") : e.ic(t2 + " " + s);
  }
}
function fh(t2, e, n) {
  if ((e = getModularInstance(e)) instanceof Lc2)
    return e._internalPath;
  if (typeof e == "string")
    return _h(t2, e);
  throw wh("Field path arguments must be of type string or ", t2, false, void 0, n);
}
var dh = new RegExp("[~\\*/\\[\\]]");
function _h(t2, e, n) {
  if (e.search(dh) >= 0)
    throw wh(`Invalid field path (${e}). Paths must not contain '~', '*', '/', '[', or ']'`, t2, false, void 0, n);
  try {
    return new Lc2(...e.split("."))._internalPath;
  } catch (s) {
    throw wh(`Invalid field path (${e}). Paths must not be empty, begin with '.', end with '.', or contain '..'`, t2, false, void 0, n);
  }
}
function wh(t2, e, n, s, i) {
  const r = s && !s.isEmpty(), o = i !== void 0;
  let u = `Function ${e}() called with invalid data`;
  n && (u += " (via `toFirestore()`)"), u += ". ";
  let a = "";
  return (r || o) && (a += " (found", r && (a += ` in field ${s}`), o && (a += ` in document ${i}`), a += ")"), new Q2(K2.INVALID_ARGUMENT, u + t2 + a);
}
function mh(t2, e) {
  return t2.some((t3) => t3.isEqual(e));
}
var gh = class {
  constructor(t2, e, n, s, i) {
    this._firestore = t2, this._userDataWriter = e, this._key = n, this._document = s, this._converter = i;
  }
  get id() {
    return this._key.path.lastSegment();
  }
  get ref() {
    return new fc2(this._firestore, this._converter, this._key);
  }
  exists() {
    return this._document !== null;
  }
  data() {
    if (this._document) {
      if (this._converter) {
        const t2 = new yh(this._firestore, this._userDataWriter, this._key, this._document, null);
        return this._converter.fromFirestore(t2);
      }
      return this._userDataWriter.convertValue(this._document.data.value);
    }
  }
  get(t2) {
    if (this._document) {
      const e = this._document.data.field(ph("DocumentSnapshot.get", t2));
      if (e !== null)
        return this._userDataWriter.convertValue(e);
    }
  }
};
var yh = class extends gh {
  data() {
    return super.data();
  }
};
function ph(t2, e) {
  return typeof e == "string" ? _h(t2, e) : e instanceof Lc2 ? e._internalPath : e._delegate._internalPath;
}
var Ih = class {
  constructor(t2, e) {
    this.hasPendingWrites = t2, this.fromCache = e;
  }
  isEqual(t2) {
    return this.hasPendingWrites === t2.hasPendingWrites && this.fromCache === t2.fromCache;
  }
};
var Th = class extends gh {
  constructor(t2, e, n, s, i, r) {
    super(t2, e, n, s, r), this._firestore = t2, this._firestoreImpl = t2, this.metadata = i;
  }
  exists() {
    return super.exists();
  }
  data(t2 = {}) {
    if (this._document) {
      if (this._converter) {
        const e = new Eh(this._firestore, this._userDataWriter, this._key, this._document, this.metadata, null);
        return this._converter.fromFirestore(e, t2);
      }
      return this._userDataWriter.convertValue(this._document.data.value, t2.serverTimestamps);
    }
  }
  get(t2, e = {}) {
    if (this._document) {
      const n = this._document.data.field(ph("DocumentSnapshot.get", t2));
      if (n !== null)
        return this._userDataWriter.convertValue(n, e.serverTimestamps);
    }
  }
};
var Eh = class extends Th {
  data(t2 = {}) {
    return super.data(t2);
  }
};
var Ah = class {
  constructor(t2, e, n, s) {
    this._firestore = t2, this._userDataWriter = e, this._snapshot = s, this.metadata = new Ih(s.hasPendingWrites, s.fromCache), this.query = n;
  }
  get docs() {
    const t2 = [];
    return this.forEach((e) => t2.push(e)), t2;
  }
  get size() {
    return this._snapshot.docs.size;
  }
  get empty() {
    return this.size === 0;
  }
  forEach(t2, e) {
    this._snapshot.docs.forEach((n) => {
      t2.call(e, new Eh(this._firestore, this._userDataWriter, n.key, n, new Ih(this._snapshot.mutatedKeys.has(n.key), this._snapshot.fromCache), this.query.converter));
    });
  }
  docChanges(t2 = {}) {
    const e = !!t2.includeMetadataChanges;
    if (e && this._snapshot.excludesMetadataChanges)
      throw new Q2(K2.INVALID_ARGUMENT, "To include metadata changes with your document changes, you must also pass { includeMetadataChanges:true } to onSnapshot().");
    return this._cachedChanges && this._cachedChangesIncludeMetadataChanges === e || (this._cachedChanges = function(t3, e2) {
      if (t3._snapshot.oldDocs.isEmpty()) {
        let e3 = 0;
        return t3._snapshot.docChanges.map((n) => ({
          type: "added",
          doc: new Eh(t3._firestore, t3._userDataWriter, n.doc.key, n.doc, new Ih(t3._snapshot.mutatedKeys.has(n.doc.key), t3._snapshot.fromCache), t3.query.converter),
          oldIndex: -1,
          newIndex: e3++
        }));
      }
      {
        let n = t3._snapshot.oldDocs;
        return t3._snapshot.docChanges.filter((t4) => e2 || t4.type !== 3).map((e3) => {
          const s = new Eh(t3._firestore, t3._userDataWriter, e3.doc.key, e3.doc, new Ih(t3._snapshot.mutatedKeys.has(e3.doc.key), t3._snapshot.fromCache), t3.query.converter);
          let i = -1, r = -1;
          return e3.type !== 0 && (i = n.indexOf(e3.doc.key), n = n.delete(e3.doc.key)), e3.type !== 1 && (n = n.add(e3.doc), r = n.indexOf(e3.doc.key)), {
            type: Rh(e3.type),
            doc: s,
            oldIndex: i,
            newIndex: r
          };
        });
      }
    }(this, e), this._cachedChangesIncludeMetadataChanges = e), this._cachedChanges;
  }
};
function Rh(t2) {
  switch (t2) {
    case 0:
      return "added";
    case 2:
    case 3:
      return "modified";
    case 1:
      return "removed";
    default:
      return L2();
  }
}
function bh(t2, e) {
  return t2 instanceof Th && e instanceof Th ? t2._firestore === e._firestore && t2._key.isEqual(e._key) && (t2._document === null ? e._document === null : t2._document.isEqual(e._document)) && t2._converter === e._converter : t2 instanceof Ah && e instanceof Ah && (t2._firestore === e._firestore && pc2(t2.query, e.query) && t2.metadata.isEqual(e.metadata) && t2._snapshot.isEqual(e._snapshot));
}
function Ph(t2) {
  if (Me(t2) && t2.explicitOrderBy.length === 0)
    throw new Q2(K2.UNIMPLEMENTED, "limitToLast() queries require specifying at least one orderBy() clause");
}
var Vh = class {
};
function vh(t2, ...e) {
  for (const n of e)
    t2 = n._apply(t2);
  return t2;
}
var Sh = class extends Vh {
  constructor(t2, e, n) {
    super(), this.hc = t2, this.lc = e, this.fc = n, this.type = "where";
  }
  _apply(t2) {
    const e = Yc2(t2.firestore), n = function(t3, e2, n2, s, i, r, o) {
      let u;
      if (i.isKeyField()) {
        if (r === "array-contains" || r === "array-contains-any")
          throw new Q2(K2.INVALID_ARGUMENT, `Invalid Query. You can't perform '${r}' queries on documentId().`);
        if (r === "in" || r === "not-in") {
          Kh(o, r);
          const e3 = [];
          for (const n3 of o)
            e3.push(Gh(s, t3, n3));
          u = {
            arrayValue: {
              values: e3
            }
          };
        } else
          u = Gh(s, t3, o);
      } else
        r !== "in" && r !== "not-in" && r !== "array-contains-any" || Kh(o, r), u = uh(n2, e2, o, r === "in" || r === "not-in");
      const a = ge.create(i, r, u);
      return function(t4, e3) {
        if (e3.S()) {
          const n4 = Fe(t4);
          if (n4 !== null && !n4.isEqual(e3.field))
            throw new Q2(K2.INVALID_ARGUMENT, `Invalid query. All where filters with an inequality (<, <=, !=, not-in, >, or >=) must be on the same field. But you have inequality filters on '${n4.toString()}' and '${e3.field.toString()}'`);
          const s2 = Oe(t4);
          s2 !== null && Qh(t4, e3.field, s2);
        }
        const n3 = function(t5, e4) {
          for (const n4 of t5.filters)
            if (e4.indexOf(n4.op) >= 0)
              return n4.op;
          return null;
        }(t4, function(t5) {
          switch (t5) {
            case "!=":
              return ["!=", "not-in"];
            case "array-contains":
              return ["array-contains", "array-contains-any", "not-in"];
            case "in":
              return ["array-contains-any", "in", "not-in"];
            case "array-contains-any":
              return ["array-contains", "array-contains-any", "in", "not-in"];
            case "not-in":
              return ["array-contains", "array-contains-any", "in", "not-in", "!="];
            default:
              return [];
          }
        }(e3.op));
        if (n3 !== null)
          throw n3 === e3.op ? new Q2(K2.INVALID_ARGUMENT, `Invalid query. You cannot use more than one '${e3.op.toString()}' filter.`) : new Q2(K2.INVALID_ARGUMENT, `Invalid query. You cannot use '${e3.op.toString()}' filters with '${n3.toString()}' filters.`);
      }(t3, a), a;
    }(t2._query, "where", e, t2.firestore._databaseId, this.hc, this.lc, this.fc);
    return new dc2(t2.firestore, t2.converter, function(t3, e2) {
      const n2 = t3.filters.concat([e2]);
      return new Ce(t3.path, t3.collectionGroup, t3.explicitOrderBy.slice(), n2, t3.limit, t3.limitType, t3.startAt, t3.endAt);
    }(t2._query, n));
  }
};
function Dh(t2, e, n) {
  const s = e, i = ph("where", t2);
  return new Sh(i, s, n);
}
var Ch = class extends Vh {
  constructor(t2, e) {
    super(), this.hc = t2, this.dc = e, this.type = "orderBy";
  }
  _apply(t2) {
    const e = function(t3, e2, n) {
      if (t3.startAt !== null)
        throw new Q2(K2.INVALID_ARGUMENT, "Invalid query. You must not call startAt() or startAfter() before calling orderBy().");
      if (t3.endAt !== null)
        throw new Q2(K2.INVALID_ARGUMENT, "Invalid query. You must not call endAt() or endBefore() before calling orderBy().");
      const s = new Ve(e2, n);
      return function(t4, e3) {
        if (Oe(t4) === null) {
          const n2 = Fe(t4);
          n2 !== null && Qh(t4, n2, e3.field);
        }
      }(t3, s), s;
    }(t2._query, this.hc, this.dc);
    return new dc2(t2.firestore, t2.converter, function(t3, e2) {
      const n = t3.explicitOrderBy.concat([e2]);
      return new Ce(t3.path, t3.collectionGroup, n, t3.filters.slice(), t3.limit, t3.limitType, t3.startAt, t3.endAt);
    }(t2._query, e));
  }
};
function xh(t2, e = "asc") {
  const n = e, s = ph("orderBy", t2);
  return new Ch(s, n);
}
var Nh = class extends Vh {
  constructor(t2, e, n) {
    super(), this.type = t2, this._c = e, this.wc = n;
  }
  _apply(t2) {
    return new dc2(t2.firestore, t2.converter, Ue(t2._query, this._c, this.wc));
  }
};
function kh(t2) {
  return ac2("limit", t2), new Nh("limit", t2, "F");
}
function Mh(t2) {
  return ac2("limitToLast", t2), new Nh("limitToLast", t2, "L");
}
var Oh = class extends Vh {
  constructor(t2, e, n) {
    super(), this.type = t2, this.mc = e, this.gc = n;
  }
  _apply(t2) {
    const e = qh(t2, this.type, this.mc, this.gc);
    return new dc2(t2.firestore, t2.converter, function(t3, e2) {
      return new Ce(t3.path, t3.collectionGroup, t3.explicitOrderBy.slice(), t3.filters.slice(), t3.limit, t3.limitType, e2, t3.endAt);
    }(t2._query, e));
  }
};
function Fh(...t2) {
  return new Oh("startAt", t2, true);
}
function $h(...t2) {
  return new Oh("startAfter", t2, false);
}
var Bh = class extends Vh {
  constructor(t2, e, n) {
    super(), this.type = t2, this.mc = e, this.gc = n;
  }
  _apply(t2) {
    const e = qh(t2, this.type, this.mc, this.gc);
    return new dc2(t2.firestore, t2.converter, function(t3, e2) {
      return new Ce(t3.path, t3.collectionGroup, t3.explicitOrderBy.slice(), t3.filters.slice(), t3.limit, t3.limitType, t3.startAt, e2);
    }(t2._query, e));
  }
};
function Lh(...t2) {
  return new Bh("endBefore", t2, false);
}
function Uh(...t2) {
  return new Bh("endAt", t2, true);
}
function qh(t2, e, n, s) {
  if (n[0] = getModularInstance(n[0]), n[0] instanceof gh)
    return function(t3, e2, n2, s2, i) {
      if (!s2)
        throw new Q2(K2.NOT_FOUND, `Can't use a DocumentSnapshot that doesn't exist for ${n2}().`);
      const r = [];
      for (const n3 of Be(t3))
        if (n3.field.isKeyField())
          r.push(qt(e2, s2.key));
        else {
          const t4 = s2.data.field(n3.field);
          if (Rt(t4))
            throw new Q2(K2.INVALID_ARGUMENT, 'Invalid query. You are trying to start or end a query using a document for which the field "' + n3.field + '" is an uncommitted server timestamp. (Since the value of this field is unknown, you cannot start/end a query with it.)');
          if (t4 === null) {
            const t5 = n3.field.canonicalString();
            throw new Q2(K2.INVALID_ARGUMENT, `Invalid query. You are trying to start or end a query using a document for which the field '${t5}' (used as the orderBy) does not exist.`);
          }
          r.push(t4);
        }
      return new Pe(r, i);
    }(t2._query, t2.firestore._databaseId, e, n[0]._document, s);
  {
    const i = Yc2(t2.firestore);
    return function(t3, e2, n2, s2, i2, r) {
      const o = t3.explicitOrderBy;
      if (i2.length > o.length)
        throw new Q2(K2.INVALID_ARGUMENT, `Too many arguments provided to ${s2}(). The number of arguments must be less than or equal to the number of orderBy() clauses`);
      const u = [];
      for (let r2 = 0; r2 < i2.length; r2++) {
        const a = i2[r2];
        if (o[r2].field.isKeyField()) {
          if (typeof a != "string")
            throw new Q2(K2.INVALID_ARGUMENT, `Invalid query. Expected a string for document ID in ${s2}(), but got a ${typeof a}`);
          if (!$e(t3) && a.indexOf("/") !== -1)
            throw new Q2(K2.INVALID_ARGUMENT, `Invalid query. When querying a collection and ordering by documentId(), the value passed to ${s2}() must be a plain document ID, but '${a}' contains a slash.`);
          const n3 = t3.path.child(_t.fromString(a));
          if (!xt.isDocumentKey(n3))
            throw new Q2(K2.INVALID_ARGUMENT, `Invalid query. When querying a collection group and ordering by documentId(), the value passed to ${s2}() must result in a valid document path, but '${n3}' is not because it contains an odd number of segments.`);
          const i3 = new xt(n3);
          u.push(qt(e2, i3));
        } else {
          const t4 = uh(n2, s2, a);
          u.push(t4);
        }
      }
      return new Pe(u, r);
    }(t2._query, t2.firestore._databaseId, i, e, n, s);
  }
}
function Gh(t2, e, n) {
  if (typeof (n = getModularInstance(n)) == "string") {
    if (n === "")
      throw new Q2(K2.INVALID_ARGUMENT, "Invalid query. When querying with documentId(), you must provide a valid document ID, but it was an empty string.");
    if (!$e(e) && n.indexOf("/") !== -1)
      throw new Q2(K2.INVALID_ARGUMENT, `Invalid query. When querying a collection by documentId(), you must provide a plain document ID, but '${n}' contains a '/' character.`);
    const s = e.path.child(_t.fromString(n));
    if (!xt.isDocumentKey(s))
      throw new Q2(K2.INVALID_ARGUMENT, `Invalid query. When querying a collection group by documentId(), the value provided must result in a valid document path, but '${s}' is not because it has an odd number of segments (${s.length}).`);
    return qt(t2, new xt(s));
  }
  if (n instanceof fc2)
    return qt(t2, n._key);
  throw new Q2(K2.INVALID_ARGUMENT, `Invalid query. When querying with documentId(), you must provide a valid string or a DocumentReference, but it was: ${oc2(n)}.`);
}
function Kh(t2, e) {
  if (!Array.isArray(t2) || t2.length === 0)
    throw new Q2(K2.INVALID_ARGUMENT, `Invalid Query. A non-empty array is required for '${e.toString()}' filters.`);
  if (t2.length > 10)
    throw new Q2(K2.INVALID_ARGUMENT, `Invalid Query. '${e.toString()}' filters support a maximum of 10 elements in the value array.`);
}
function Qh(t2, e, n) {
  if (!n.isEqual(e))
    throw new Q2(K2.INVALID_ARGUMENT, `Invalid query. You have a where filter with an inequality (<, <=, !=, not-in, >, or >=) on field '${e.toString()}' and so you must also use '${e.toString()}' as your first argument to orderBy(), but your first orderBy() is on field '${n.toString()}' instead.`);
}
var jh = class {
  convertValue(t2, e = "none") {
    switch (Mt(t2)) {
      case 0:
        return null;
      case 1:
        return t2.booleanValue;
      case 2:
        return Et(t2.integerValue || t2.doubleValue);
      case 3:
        return this.convertTimestamp(t2.timestampValue);
      case 4:
        return this.convertServerTimestamp(t2, e);
      case 5:
        return t2.stringValue;
      case 6:
        return this.convertBytes(At(t2.bytesValue));
      case 7:
        return this.convertReference(t2.referenceValue);
      case 8:
        return this.convertGeoPoint(t2.geoPointValue);
      case 9:
        return this.convertArray(t2.arrayValue, e);
      case 10:
        return this.convertObject(t2.mapValue, e);
      default:
        throw L2();
    }
  }
  convertObject(t2, e) {
    const n = {};
    return lt(t2.fields, (t3, s) => {
      n[t3] = this.convertValue(s, e);
    }), n;
  }
  convertGeoPoint(t2) {
    return new Kc2(Et(t2.latitude), Et(t2.longitude));
  }
  convertArray(t2, e) {
    return (t2.values || []).map((t3) => this.convertValue(t3, e));
  }
  convertServerTimestamp(t2, e) {
    switch (e) {
      case "previous":
        const n = bt(t2);
        return n == null ? null : this.convertValue(n, e);
      case "estimate":
        return this.convertTimestamp(Pt(t2));
      default:
        return null;
    }
  }
  convertTimestamp(t2) {
    const e = Tt(t2);
    return new at(e.seconds, e.nanos);
  }
  convertDocumentKey(t2, e) {
    const n = _t.fromString(t2);
    U2(Ls(n));
    const s = new vt(n.get(1), n.get(3)), i = new xt(n.popFirst(5));
    return s.isEqual(e) || F2(`Document ${i} contains a document reference within a different database (${s.projectId}/${s.database}) which is not supported. It will be treated as a reference in the current database (${e.projectId}/${e.database}) instead.`), i;
  }
};
function Wh(t2, e, n) {
  let s;
  return s = t2 ? n && (n.merge || n.mergeFields) ? t2.toFirestore(e, n) : t2.toFirestore(e) : e, s;
}
var zh = class extends jh {
  constructor(t2) {
    super(), this.firestore = t2;
  }
  convertBytes(t2) {
    return new qc2(t2);
  }
  convertReference(t2) {
    const e = this.convertDocumentKey(t2, this.firestore._databaseId);
    return new fc2(this.firestore, null, e);
  }
};
var Hh = class {
  constructor(t2, e) {
    this._firestore = t2, this._commitHandler = e, this._mutations = [], this._committed = false, this._dataReader = Yc2(t2);
  }
  set(t2, e, n) {
    this._verifyNotCommitted();
    const s = Jh(t2, this._firestore), i = Wh(s.converter, e, n), r = Xc2(this._dataReader, "WriteBatch.set", s._key, i, s.converter !== null, n);
    return this._mutations.push(r.toMutation(s._key, _n.none())), this;
  }
  update(t2, e, n, ...s) {
    this._verifyNotCommitted();
    const i = Jh(t2, this._firestore);
    let r;
    return r = typeof (e = getModularInstance(e)) == "string" || e instanceof Lc2 ? oh(this._dataReader, "WriteBatch.update", i._key, e, n, s) : rh(this._dataReader, "WriteBatch.update", i._key, e), this._mutations.push(r.toMutation(i._key, _n.exists(true))), this;
  }
  delete(t2) {
    this._verifyNotCommitted();
    const e = Jh(t2, this._firestore);
    return this._mutations = this._mutations.concat(new Vn(e._key, _n.none())), this;
  }
  commit() {
    return this._verifyNotCommitted(), this._committed = true, this._mutations.length > 0 ? this._commitHandler(this._mutations) : Promise.resolve();
  }
  _verifyNotCommitted() {
    if (this._committed)
      throw new Q2(K2.FAILED_PRECONDITION, "A write batch can no longer be used after commit() has been called.");
  }
};
function Jh(t2, e) {
  if ((t2 = getModularInstance(t2)).firestore !== e)
    throw new Q2(K2.INVALID_ARGUMENT, "Provided document reference is from a different Firestore instance.");
  return t2;
}
function Yh(t2) {
  t2 = uc2(t2, fc2);
  const e = uc2(t2.firestore, Rc2);
  return za2(Vc2(e), t2._key).then((n) => ll(e, t2, n));
}
var Xh = class extends jh {
  constructor(t2) {
    super(), this.firestore = t2;
  }
  convertBytes(t2) {
    return new qc2(t2);
  }
  convertReference(t2) {
    const e = this.convertDocumentKey(t2, this.firestore._databaseId);
    return new fc2(this.firestore, null, e);
  }
};
function Zh(t2) {
  t2 = uc2(t2, fc2);
  const e = uc2(t2.firestore, Rc2), n = Vc2(e), s = new Xh(e);
  return Wa2(n, t2._key).then((n2) => new Th(e, s, t2._key, n2, new Ih(n2 !== null && n2.hasLocalMutations, true), t2.converter));
}
function tl(t2) {
  t2 = uc2(t2, fc2);
  const e = uc2(t2.firestore, Rc2);
  return za2(Vc2(e), t2._key, {
    source: "server"
  }).then((n) => ll(e, t2, n));
}
function el(t2) {
  t2 = uc2(t2, dc2);
  const e = uc2(t2.firestore, Rc2), n = Vc2(e), s = new Xh(e);
  return Ph(t2._query), Ja2(n, t2._query).then((n2) => new Ah(e, s, t2, n2));
}
function nl(t2) {
  t2 = uc2(t2, dc2);
  const e = uc2(t2.firestore, Rc2), n = Vc2(e), s = new Xh(e);
  return Ha2(n, t2._query).then((n2) => new Ah(e, s, t2, n2));
}
function sl(t2) {
  t2 = uc2(t2, dc2);
  const e = uc2(t2.firestore, Rc2), n = Vc2(e), s = new Xh(e);
  return Ja2(n, t2._query, {
    source: "server"
  }).then((n2) => new Ah(e, s, t2, n2));
}
function il(t2, e, n) {
  t2 = uc2(t2, fc2);
  const s = uc2(t2.firestore, Rc2), i = Wh(t2.converter, e, n);
  return hl(s, [Xc2(Yc2(s), "setDoc", t2._key, i, t2.converter !== null, n).toMutation(t2._key, _n.none())]);
}
function rl(t2, e, n, ...s) {
  t2 = uc2(t2, fc2);
  const i = uc2(t2.firestore, Rc2), r = Yc2(i);
  let o;
  o = typeof (e = getModularInstance(e)) == "string" || e instanceof Lc2 ? oh(r, "updateDoc", t2._key, e, n, s) : rh(r, "updateDoc", t2._key, e);
  return hl(i, [o.toMutation(t2._key, _n.exists(true))]);
}
function ol(t2) {
  return hl(uc2(t2.firestore, Rc2), [new Vn(t2._key, _n.none())]);
}
function ul(t2, e) {
  const n = uc2(t2.firestore, Rc2), s = gc2(t2), i = Wh(t2.converter, e);
  return hl(n, [Xc2(Yc2(t2.firestore), "addDoc", s._key, i, t2.converter !== null, {}).toMutation(s._key, _n.exists(false))]).then(() => s);
}
function al(t2, ...e) {
  var n, s, i;
  t2 = getModularInstance(t2);
  let r = {
    includeMetadataChanges: false
  }, o = 0;
  typeof e[o] != "object" || Tc2(e[o]) || (r = e[o], o++);
  const u = {
    includeMetadataChanges: r.includeMetadataChanges
  };
  if (Tc2(e[o])) {
    const t3 = e[o];
    e[o] = (n = t3.next) === null || n === void 0 ? void 0 : n.bind(t3), e[o + 1] = (s = t3.error) === null || s === void 0 ? void 0 : s.bind(t3), e[o + 2] = (i = t3.complete) === null || i === void 0 ? void 0 : i.bind(t3);
  }
  let a, c, h;
  if (t2 instanceof fc2)
    c = uc2(t2.firestore, Rc2), h = Ne(t2._key.path), a = {
      next: (n2) => {
        e[o] && e[o](ll(c, t2, n2));
      },
      error: e[o + 1],
      complete: e[o + 2]
    };
  else {
    const n2 = uc2(t2, dc2);
    c = uc2(n2.firestore, Rc2), h = n2._query;
    const s2 = new Xh(c);
    a = {
      next: (t3) => {
        e[o] && e[o](new Ah(c, s2, n2, t3));
      },
      error: e[o + 1],
      complete: e[o + 2]
    }, Ph(t2._query);
  }
  return function(t3, e2, n2, s2) {
    const i2 = new Ca2(s2), r2 = new Fu(e2, i2, n2);
    return t3.asyncQueue.enqueueAndForget(async () => xu(await Ka2(t3), r2)), () => {
      i2.pa(), t3.asyncQueue.enqueueAndForget(async () => Nu(await Ka2(t3), r2));
    };
  }(Vc2(c), h, u, a);
}
function cl(t2, e) {
  return Ya2(Vc2(t2 = uc2(t2, Rc2)), Tc2(e) ? e : {
    next: e
  });
}
function hl(t2, e) {
  return function(t3, e2) {
    const n = new j();
    return t3.asyncQueue.enqueueAndForget(async () => Yu(await Ga2(t3), e2, n)), n.promise;
  }(Vc2(t2), e);
}
function ll(t2, e, n) {
  const s = n.docs.get(e._key), i = new Xh(t2);
  return new Th(t2, i, e._key, s, new Ih(n.hasPendingWrites, n.fromCache), e.converter);
}
var fl = class extends class {
  constructor(t2, e) {
    this._firestore = t2, this._transaction = e, this._dataReader = Yc2(t2);
  }
  get(t2) {
    const e = Jh(t2, this._firestore), n = new zh(this._firestore);
    return this._transaction.lookup([e._key]).then((t3) => {
      if (!t3 || t3.length !== 1)
        return L2();
      const s = t3[0];
      if (s.isFoundDocument())
        return new gh(this._firestore, n, s.key, s, e.converter);
      if (s.isNoDocument())
        return new gh(this._firestore, n, e._key, null, e.converter);
      throw L2();
    });
  }
  set(t2, e, n) {
    const s = Jh(t2, this._firestore), i = Wh(s.converter, e, n), r = Xc2(this._dataReader, "Transaction.set", s._key, i, s.converter !== null, n);
    return this._transaction.set(s._key, r), this;
  }
  update(t2, e, n, ...s) {
    const i = Jh(t2, this._firestore);
    let r;
    return r = typeof (e = getModularInstance(e)) == "string" || e instanceof Lc2 ? oh(this._dataReader, "Transaction.update", i._key, e, n, s) : rh(this._dataReader, "Transaction.update", i._key, e), this._transaction.update(i._key, r), this;
  }
  delete(t2) {
    const e = Jh(t2, this._firestore);
    return this._transaction.delete(e._key), this;
  }
} {
  constructor(t2, e) {
    super(t2, e), this._firestore = t2;
  }
  get(t2) {
    const e = Jh(t2, this._firestore), n = new Xh(this._firestore);
    return super.get(t2).then((t3) => new Th(this._firestore, n, e._key, t3._document, new Ih(false, false), e.converter));
  }
};
function dl(t2, e) {
  return Xa2(Vc2(t2 = uc2(t2, Rc2)), (n) => e(new fl(t2, n)));
}
function _l() {
  return new Zc2("deleteField");
}
function wl() {
  return new eh("serverTimestamp");
}
function ml(...t2) {
  return new nh("arrayUnion", t2);
}
function gl(...t2) {
  return new sh("arrayRemove", t2);
}
function yl(t2) {
  return new ih("increment", t2);
}
function pl(t2) {
  return Vc2(t2 = uc2(t2, Rc2)), new Hh(t2, (e) => hl(t2, e));
}
function Il(t2, e) {
  Vc2(t2 = uc2(t2, Rc2));
  const n = typeof e == "string" ? function(t3) {
    try {
      return JSON.parse(t3);
    } catch (t4) {
      throw new Q2(K2.INVALID_ARGUMENT, "Failed to parse JSON:" + t4.message);
    }
  }(e) : e, s = [];
  if (Array.isArray(n.indexes))
    for (const t3 of n.indexes) {
      const e2 = Tl(t3, "collectionGroup"), n2 = [];
      if (Array.isArray(t3.fields))
        for (const e3 of t3.fields) {
          const t4 = _h("setIndexConfiguration", Tl(e3, "fieldPath"));
          e3.arrayConfig === "CONTAINS" ? n2.push(new ie(t4, 2)) : e3.order === "ASCENDING" ? n2.push(new ie(t4, 0)) : e3.order === "DESCENDING" && n2.push(new ie(t4, 1));
        }
      s.push(new ee(ee.UNKNOWN_ID, e2, n2, re.empty()));
    }
  return Promise.resolve();
}
function Tl(t2, e) {
  if (typeof t2[e] != "string")
    throw new Q2(K2.INVALID_ARGUMENT, "Missing string value for: " + e);
  return t2[e];
}
!function(t2, e = true) {
  !function(t3) {
    x2 = t3;
  }(SDK_VERSION), _registerComponent(new Component("firestore", (t3, { options: n }) => {
    const s = t3.getProvider("app").getImmediate(), i = new Rc2(s, new J2(t3.getProvider("auth-internal")), new tt(t3.getProvider("app-check-internal")));
    return n = Object.assign({
      useFetchStreams: e
    }, n), i._setSettings(n), i;
  }, "PUBLIC")), registerVersion(D2, "3.4.7", t2), registerVersion(D2, "3.4.7", "esm2017");
}();

export {
  M2 as M,
  $,
  q2 as q,
  Q2 as Q,
  z2 as z,
  et,
  at,
  mt,
  yt,
  vt,
  xt,
  sc2 as sc,
  uc2 as uc,
  lc2 as lc,
  fc2 as fc,
  dc2 as dc,
  _c,
  wc2 as wc,
  mc2 as mc,
  gc2 as gc,
  yc2 as yc,
  pc2 as pc,
  Ec2 as Ec,
  Ac2 as Ac,
  Rc2 as Rc,
  bc2 as bc,
  Pc2 as Pc,
  Vc2 as Vc,
  Sc2 as Sc,
  Dc2 as Dc,
  xc2 as xc,
  Nc2 as Nc,
  kc2 as kc,
  Mc2 as Mc,
  Oc2 as Oc,
  Fc2 as Fc,
  $c2 as $c,
  Lc2 as Lc,
  Uc2 as Uc,
  qc2 as qc,
  Gc2 as Gc,
  Kc2 as Kc,
  Ih,
  Th,
  Eh,
  Ah,
  bh,
  Vh,
  vh,
  Dh,
  xh,
  kh,
  Mh,
  Fh,
  $h,
  Lh,
  Uh,
  jh,
  Hh,
  Yh,
  Zh,
  tl,
  el,
  nl,
  sl,
  il,
  rl,
  ol,
  ul,
  al,
  cl,
  hl,
  fl,
  dl,
  _l,
  wl,
  ml,
  gl,
  yl,
  pl,
  Il
};
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
* @license
* Copyright 2017 Google LLC
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
/**
* @license
* Copyright 2020 Google LLC
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
//# sourceMappingURL=chunk-N53DHTGU.js.map
