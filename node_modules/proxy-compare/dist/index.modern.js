const e=Symbol(),t=Symbol(),r=Symbol(),n=Object.getPrototypeOf,o=new WeakMap,s=e=>e&&(o.has(e)?o.get(e):n(e)===Object.prototype||n(e)===Array.prototype),c=e=>"object"==typeof e&&null!==e,l=(n,o)=>{let s=!1;const c=(e,t)=>{if(!s){let r=e.a.get(n);r||(r=new Set,e.a.set(n,r)),r.add(t)}},l={f:o,get(e,t){return t===r?n:(c(this,t),a(e[t],this.a,this.c))},has(e,r){return r===t?(s=!0,this.a.delete(n),!0):(c(this,r),r in e)},ownKeys(t){return c(this,e),Reflect.ownKeys(t)}};return o&&(l.set=l.deleteProperty=()=>!1),l},a=(e,t,o)=>{if(!s(e))return e;const c=e[r]||e,a=(e=>Object.isFrozen(e)||Object.values(Object.getOwnPropertyDescriptors(e)).some(e=>!e.writable))(c);let i=o&&o.get(c);return i&&i.f===a||(i=l(c,a),i.p=new Proxy(a?(e=>{if(Array.isArray(e))return Array.from(e);const t=Object.getOwnPropertyDescriptors(e);return Object.values(t).forEach(e=>{e.configurable=!0}),Object.create(n(e),t)})(c):c,i),o&&o.set(c,i)),i.a=t,i.c=o,i.p},i=(e,t)=>{const r=Reflect.ownKeys(e),n=Reflect.ownKeys(t);return r.length!==n.length||r.some((e,t)=>e!==n[t])},u=(t,r,n,o)=>{if(Object.is(t,r))return!1;if(!c(t)||!c(r))return!0;const s=n.get(t);if(!s)return!0;if(o){const e=o.get(t);if(e&&e.n===r)return e.g;o.set(t,{n:r,g:!1})}let l=null;for(const c of s){const s=c===e?i(t,r):u(t[c],r[c],n,o);if(!0!==s&&!1!==s||(l=s),l)break}return null===l&&(l=!0),o&&o.set(t,{n:r,g:l}),l},f=e=>!!s(e)&&t in e,y=e=>s(e)&&e[r]||null,b=(e,t=!0)=>{o.set(e,t)},g=(e,t)=>{const r=[],n=new WeakSet,o=(e,s)=>{if(n.has(e))return;c(e)&&n.add(e);const l=t.get(e);l?l.forEach(t=>{o(e[t],s?[...s,t]:[t])}):s&&r.push(s)};return o(e),r};export{g as affectedToPathList,a as createProxy,y as getUntracked,u as isChanged,b as markToTrack,f as trackMemo};
//# sourceMappingURL=index.modern.mjs.map
